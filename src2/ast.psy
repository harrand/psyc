ast_expr_type ::= enum
{
	.unknown := 0;
	.symbol := 1;
	.literal := 2;
	.biop := 3;
	.unop := 4;
	.callfunc := 5;
	.ret := 6;
	.yld := 7;
	.strctinit := 8;
};

ast_biop_type ::= enum
{
	.assign := 0;
	.compare := 1;
	.comparen := 2;
	.less_than := 3;
	.less_than_equal := 4;
	.greater_than := 5;
	.greater_than_equal := 6;
	.plus := 7;
	.minus := 8;
	.multiply := 9;
	.divide := 10;
	.bitwise_or := 11;
	.logical_or := 12;
	.bitwise_and := 13;
	.logical_and := 14;
	.exor := 15;
	.bitleft := 16;
	.bitright := 17;
	.modulo := 18;
	.operator_at := 19;
	.field := 20;
	.ptr_field := 21;
	.cast := 22;
};

ast_biop_expr ::= struct
{
	type : ast_biop_type;
	ak_precedence : u64;
	def_precedence : u64;
};

ast_unop_type ::= enum
{
	.minus := 0;
	.bitwise_invert := 1;
	.logical_invert := 2;
	.op_ref := 3;
	.op_deref := 4;
	.op_defer := 5;
};

ast_unop_expr ::= struct
{
	type : ast_unop_type;
};

ast_literal_type ::= enum
{
	.lit_integral := 0;
	.lit_floating_point := 1;
	.lit_char := 2;
	.lit_string := 3;
	.lit_bool := 4;
	.lit_zero := 5;
};

ast_literal_expr ::= struct
{
	type : ast_literal_type;
	integral : s64;
	floating_point : f64;
	chars : u8&;
	chars_len : u64;
	boolean : bool;
};

ast_symbol_expr ::= struct
{
	symbol : u8&;
	len : u64;
};

ast_callfunc_expr ::= struct
{
	fnname : u8&;
	fnname_len : u64;
};

ast_expr ::= struct
{
	type : ast_expr_type;
	symbol : ast_symbol_expr;
	literal : ast_literal_expr;
	unop : ast_unop_expr;
	biop : ast_biop_expr;
	callfunc : ast_callfunc_expr;
};

ast_decl ::= struct
{
	name : u8&;
	name_len : u64;
	typename : u8&;
	typename_len : u64;
	extras : u8&;
	extras_size : u64;
};

ast_stmt ::= enum
{
	.unknown := 0;
	.stmt_expr := 1;
	.stmt_decl := 2;
	.stmt_region := 3;
	.stmt_struct := 4;
	.stmt_enum := 5;
	.stmt_fn := 6;
	.stmt_mac := 7;
	.stmt_if := 8;
	.stmt_while := 9;
	.stmt_for := 10;
	.stmt_init := 11;
	.stmt_strctinit := 12;
};

ast_region_stmt ::= struct
{
	name : u8&;
	name_len : u64;
};

ast_unparsed_token ::= struct
{
	tok : token_data;
};

ast_type ::= enum
{
	.unknown := 0;
	.unparsed_token := 2;
	.stmt_list := 3;
	.wipfn_blue := 4;
	.wipfn_red := 5;
	.wipfn_green := 6;
	.wipmacro_blue := 7;
	.wipmacro_red := 8;
	.wipmacro_green := 9;
	.wipdecl := 10;
	.wipcall := 11;
	.wipstruct := 12;
	.wipenum := 13;
	.wipregion := 14;
	.wipblk := 15;
	.wipbiop := 16;
	.wipif_blue := 17;
	.wipif_red := 18;
	.wipwhile_blue := 19;
	.wipwhile_red := 20;
	.wipfor_blue := 21;
	.wipfor_red := 22;
	.wipfor_yellow := 23;
	.wipfor_green := 24;
	.wipelse := 25;
	.wipinit := 26;
	.wipstrctinit := 27;
	.stmt := 28;
	.expr := 29;
	.decl := 30;
	.fnptrdecl := 31;
	.defstruct := 32;
	.defenum := 33;
	.region := 34;
	.fn := 35;
	.mac := 36;
	.defif := 37;
	.defelse := 38;
	.defwhile := 39;
	.deffor := 40;
	.init := 41;
	.composite := 42;
};

ast_fn ::= struct
{
	fn_name : u8&;
	fn_name_len : u64;
	ret_typename : u8&;
	ret_typename_len : u64;
	is_extern : bool;
};

ast_macro ::= struct
{
	mac_name : u8&;
	mac_name_len : u64;
	yld_typename : u8&;
	yld_typename_len : u64;
};

ast_wipcall ::= struct
{
	fnname : u8&;
	fnname_len : u64;
};

ast_struct ::= struct
{
	strctname : u8&;
	strctname_len : u64;
};

ast_enum ::= struct
{
	enmname : u8&;
	enmname_len : u64;
};

ast_if ::= struct
{
	is_static : bool;
};

ast_init ::= struct
{
	name : u8&;
	name_len : u64;
};

ast ::= struct
{
	type : ast_type;
	utok : ast_unparsed_token;
	stmt : ast_stmt;
	expr : ast_expr;
	decl : ast_decl;
	defstruct : ast_struct;
	defenum : ast_enum;
	wipcall : ast_wipcall;
	region : ast_region_stmt;
	init : ast_init;
	fn : ast_fn;
	mac : ast_macro;
	defif : ast_if;
	loc : srcloc;
	cursor_begin : u64;
	cursor_end : u64;

	childcount : u64;
	childcap : u64;
	children : v0 mut&;
};

ast_get_child ::= func(a : ast mut&, cid : u64 -> ast mut&)
{
	childrenptr ::= ((a->children)@ast mut&);
	return childrenptr at cid;
};

ast_add_child ::= func(a : ast mut&, child : ast, ar : arena mut& -> u64)
{
	if((a->children) == null)
	{
		(a->childcap) = 8;
		(a->children) = arena_push(ar, __sizeof(ast) * (a->childcap));
	}
	while((a->childcount) >= (a->childcap))
	{
		olddata ::= (a->children);
		oldcap ::= (a->childcap);

		(a->childcap) = ((a->childcap) * 2);
		(a->children) = arena_push(ar, __sizeof(ast) * (a->childcap));
		__memcpy(a->children, olddata, __sizeof(ast) * oldcap);
	}

	childrenptr ::= ((a->children)@ast mut&);
	deref(childrenptr at (a->childcount)) = child;
	childid ::= a->childcount;
	(a->childcount) = (a->childcount) + 1;
	return childid;
};

ast_emplace_child ::= func(a : ast mut&, child : ast, ar : arena mut& -> ast mut&)
{
	cid ::= ast_add_child(a, child, ar);
	return ast_get_child(a, cid);
};

ast_biop_get_lhs ::= func(a : ast -> ast mut&)
{
	if((a.childcount) < 1)
	{
		return zero;
	}
	childrenptr ::= ((a.children)@ast mut&);
	return childrenptr at 0;
};

ast_biop_get_rhs ::= func(a : ast -> ast mut&)
{
	if((a.childcount) < 2)
	{
		return zero;
	}
	childrenptr ::= ((a.children)@ast mut&);
	return childrenptr at 1;
};

ast_unop_get_operand ::= func(a : ast -> ast mut&)
{
	return ast_biop_get_lhs(a);
};

ast_biop_set_lhs ::= func(a : ast mut&, lhs : ast, ar : arena mut& -> v0)
{
	childrenptr ::= ((a->children)@ast mut&);
	c ::= a->childcount;
	if(c >= 1)
	{
		deref(childrenptr at 0) = lhs;
	}
	if(c == 0)
	{
		ast_add_child(a, lhs, ar);
	}
};

ast_biop_set_rhs ::= func(a : ast mut&, rhs : ast, ar : arena mut& -> v0)
{
	childrenptr ::= ((a->children)@ast mut&);
	c ::= a->childcount;
	if(c >= 2)
	{
		deref(childrenptr at 1) = rhs;
	}
	if(c == 1)
	{
		ast_add_child(a, rhs, ar);
	}
	if(c == 0)
	{
		ast_add_child(a, zero, ar);
		ast_add_child(a, rhs, ar);
	}
};

ast_unop_set_operand ::= func(a : ast mut&, operand : ast, ar : arena mut& -> v0)
{
	ast_biop_set_lhs(a, operand, ar);
};

make_biop_expr ::= func(biop : ast_biop_expr -> ast_expr)
{
	return ast_expr
	{
		.type := ast_expr_type.biop;
		.biop := biop;
	};
};

make_unop_expr ::= func(unop : ast_unop_expr -> ast_expr)
{
	return ast_expr
	{
		.type := ast_expr_type.unop;
		.unop := unop;
	};
};

make_literal_expr ::= func(lit : ast_literal_expr -> ast_expr)
{
	return ast_expr
	{
		.type := ast_expr_type.literal;
		.literal := lit;
	};
};

make_symbol_expr ::= func(symbol : ast_symbol_expr -> ast_expr)
{
	return ast_expr
	{
		.type := ast_expr_type.symbol;
		.symbol := symbol;
	};
};

make_callfunc_expr ::= func(call : ast_callfunc_expr -> ast_expr)
{
	return ast_expr
	{
		.type := ast_expr_type.callfunc;
		.callfunc := call;
	};
};

make_unparsed_token_ast ::= func(tok : token_data -> ast)
{
	lexeme ::= tok.lexeme;
	return ast
	{
		.type := ast_type.unparsed_token;
		.utok := ast_unparsed_token
		{
			.tok := tok;
		};
		.loc := tok.begin;
		.cursor_begin := lexeme.off;
		.cursor_end := (lexeme.off) + (lexeme.len);
		.childcount := zero;
		.childcap := zero;
		.children := zero;
	};
};

ast_verbose_print ::= func(a : ast&, tabcount : u64 -> v0)
{
	i : u64 mut;
	for(i = 0, i < tabcount, i = i + 1)
	{
		putchar(9);
	}
	if((a->type) != (ast_type.unparsed_token))
	{
		puts(__enmname(a->type));
	}
	if((a->type) == (ast_type.unparsed_token))
	{
		utok ::= a->utok;
		tokdata ::= utok.tok;
		puts("token.");
		puts(__enmname(tokdata.tok));
	}
	if((a->type) == (ast_type.expr))
	{
		puts("(");
		expr ::= a->expr;
		puts(__enmname(expr.type));
		puts(")");
	}
	if((a->type) == (ast_type.stmt))
	{
		puts("(");
		stmt ::= a->stmt;
		puts(__enmname(stmt));
		puts(")");
	}
	putchar(' ');
	print_srcloc(a->loc);
	putchar(10);

	childrenptr ::= ((a->children)@ast mut&);

	for(i = 0, i < (a->childcount), i = i + 1)
	{
		ast_verbose_print(childrenptr at i, tabcount + 1);
	}
};

interpret_numeric_literal ::= func(src : u8&, lexeme : lex_slice -> ast_literal_expr)
{
	src_begin : u8& mut := src at (lexeme.off);
	begin_cpy ::= src_begin;
	i : u64 mut := 0;

	sign : s64 mut := 1;
	if(deref(src_begin) == '-')
	{
		sign = -1;
		src_begin = src_begin at 1;
		i = i + 1;
	}
	ch : u8 mut;

	base : s64 mut := 10;
	if(deref(src_begin) == '0')
	{
		src_begin = src_begin at 1;
		ch = deref(src_begin);
		if(ch == 'x')
		{
			base = 16;
			src_begin = src_begin at 1;
			i = i + 1;
		}
		if(ch == 'b')
		{
			base = 2;
			src_begin = src_begin at 1;
			i = i + 1;
		}
	}

	ival : s64 mut := 0;
	fval : f64 mut := 0;

	digit_val : s64 mut := 0;
	frac_div : f64 mut := 1.0;

	is_integral : bool mut := true;
	while(i < (lexeme.len))
	{
		ch = deref(begin_cpy at i);
		if(ch == '.')
		{
			is_integral = false;
		}
		if(impl_is_digit(ch))
		{
			digit_val = (ch - '0');
		}
		if(ch >= 'a')
		{
			if(ch <= 'f')
			{
				digit_val = (10 + (ch - 'a'));
			}
		}

		if(digit_val >= base)
		{
			psyc_panic(srcloc_current(), "waaah it all went wrong");
		}

		if(is_integral)
		{
			ival = ((ival * base) + digit_val);
		}
		if(!is_integral)
		{
			if(impl_is_digit(ch))
			{
				frac_div = (frac_div / (base@f64));
				fval = (fval + ((digit_val@f64) * frac_div));
			}
		}

		i = i + 1;
	}

	ret : ast_literal_expr mut;
	if(is_integral)
	{
		ival = ival * sign;
		ret.type = (ast_literal_type.integral);
		ret.integral = ival;
	}
	if(!is_integral)
	{
		fval = fval + (ival@f64) * (sign@f64);
		ret.type = (ast_literal_type.floating_point);
		ret.floating_point = fval;
	}

	return ret;
};

ast_child_find_if ::= func(node : ast&, predicate : func(n : ast& -> bool) -> u64)
{
	// iterate over all children
	ccount ::= node->childcount;
	i : u64 mut;
	for(i = 0, i < ccount, i = i + 1)
	{
		if(predicate(ast_get_child(node@_, i)))
		{
			return i;
		}
	}
	return -1@_;
};

ast_unop_type_from_token ::= func(t : lex_token -> ast_unop_type)
{
	if(t == (lex_token.dash))
	{
		return ast_unop_type.minus;
	}
	if(t == (lex_token.bitwise_invert))
	{
		return ast_unop_type.bitwise_invert;
	}
	if(t == (lex_token.logical_invert))
	{
		return ast_unop_type.logical_invert;
	}
	if(t == (lex_token.keyword_ref))
	{
		return ast_unop_type.op_ref;
	}
	if(t == (lex_token.keyword_deref))
	{
		return ast_unop_type.op_deref;
	}
	return -1@ast_unop_type;	
};

ast_biop_type_from_token ::= func(t : lex_token -> ast_biop_type)
{
	if(t == (lex_token.assign))
	{
		return ast_biop_type.assign;
	}
	if(t == (lex_token.compare))
	{
		return ast_biop_type.compare;
	}
	if(t == (lex_token.comparen))
	{
		return ast_biop_type.comparen;
	}
	if(t == (lex_token.oanglebrack))
	{
		return ast_biop_type.less_than;
	}
	if(t == (lex_token.loreq))
	{
		return ast_biop_type.less_than_equal;
	}
	if(t == (lex_token.canglebrack))
	{
		return ast_biop_type.greater_than;
	}
	if(t == (lex_token.goreq))
	{
		return ast_biop_type.greater_than_equal;
	}
	if(t == (lex_token.plus))
	{
		return ast_biop_type.plus;
	}
	if(t == (lex_token.dash))
	{
		return ast_biop_type.minus;
	}
	if(t == (lex_token.asterisk))
	{
		return ast_biop_type.multiply;
	}
	if(t == (lex_token.fslash))
	{
		return ast_biop_type.divide;
	}
	if(t == (lex_token.bitwise_or))
	{
		return ast_biop_type.bitwise_or;
	}
	if(t == (lex_token.logical_or))
	{
		return ast_biop_type.logical_or;
	}
	if(t == (lex_token.bitwise_and))
	{
		return ast_biop_type.bitwise_and;
	}
	if(t == (lex_token.logical_and))
	{
		return ast_biop_type.logical_and;
	}
	if(t == (lex_token.oanglebrack2))
	{
		return ast_biop_type.bitleft;
	}
	if(t == (lex_token.canglebrack2))
	{
		return ast_biop_type.bitright;
	}
	if(t == (lex_token.modulo))
	{
		return ast_biop_type.modulo;
	}
	if(t == (lex_token.keyword_at))
	{
		return ast_biop_type.operator_at;
	}
	if(t == (lex_token.cast))
	{
		return ast_biop_type.cast;
	}
	if(t == (lex_token.dot))
	{
		return ast_biop_type.field;
	}
	if(t == (lex_token.arrow))
	{
		return ast_biop_type.ptr_field;
	}
	return -1@ast_biop_type;	
};

ast_biop_precedence ::= func(t : ast_biop_type -> u64)
{
	if(t == (ast_biop_type.assign))
	{
		// x + 5 = 5
		// should remain (x + 5) = 5
		// not x + (5 = 5)
		return 0;
	}
	if(t == (ast_biop_type.compare))
	{
		// x.y == 5
		// kepe it (x.y) == 5
		// not x.(y == 5)
		return 1;
	}
	if(t == (ast_biop_type.comparen))
	{
		return 1;
	}
	if(t == (ast_biop_type.less_than))
	{
		return 1;
	}
	if(t == (ast_biop_type.less_than_equal))
	{
		return 1;
	}
	if(t == (ast_biop_type.greater_than))
	{
		return 1;
	}
	if(t == (ast_biop_type.greater_than_equal))
	{
		return 1;
	}
	if(t == (ast_biop_type.plus))
	{
		return 1;
	}
	if(t == (ast_biop_type.minus))
	{
		return 1;
	}
	if(t == (ast_biop_type.multiply))
	{
		return 2;
	}
	if(t == (ast_biop_type.divide))
	{
		return 2;
	}
	if(t == (ast_biop_type.bitwise_or))
	{
		return 1;
	}
	if(t == (ast_biop_type.logical_or))
	{
		return 1;
	}
	if(t == (ast_biop_type.bitwise_and))
	{
		return 1;
	}
	if(t == (ast_biop_type.logical_and))
	{
		return 1;
	}
	if(t == (ast_biop_type.bitleft))
	{
		return 1;
	}
	if(t == (ast_biop_type.bitright))
	{
		return 1;
	}
	if(t == (ast_biop_type.modulo))
	{
		return 1;
	}
	if(t == (ast_biop_type.operator_at))
	{
		return 1;
	}
	if(t == (ast_biop_type.field))
	{
		return 999;
	}
	if(t == (ast_biop_type.ptr_field))
	{
		return 999;
	}
	if(t == (ast_biop_type.cast))
	{
		return 999;
	}
	psyc_panic(srcloc_current(), "unaccounted for biop type w.r.t precedence");
	return 0;
};

ast_try_get_symbol_from_expr ::= func(expr : ast_expr, sym : u8& mut&, len : u64 mut& -> bool)
{
	if((expr.type) == (ast_expr_type.symbol))
	{
		symbolexpr ::= expr.symbol;
		deref(sym) = (symbolexpr.symbol);
		deref(len) = (symbolexpr.len);
		return true;
	}
	if((expr.type) == (ast_expr_type.callfunc))
	{
		callfuncexpr ::= expr.callfunc;
		deref(sym) = (callfuncexpr.fnname);
		deref(len) = (callfuncexpr.fnname_len);
		return true;
	}
	return false;
};

ast_is_any_stmt ::= func(node : ast& -> bool)
{
	return (node->type) == (ast_type.stmt);
};

ast_is_stmt ::= func(node : ast&, t : ast_stmt -> bool)
{
	if(!ast_is_any_stmt(node))
	{
		return false;
	}
	return (node->stmt) == t;
};

ast_is_any_expr ::= func(node : ast& -> bool)
{
	nexpr ::= node->expr;
	// plain old expr
	if((node->type) == (ast_type.expr))
	{
		return true;
	}
	// expr stmt
	return ast_is_stmt(node, ast_stmt.stmt_expr);
};

ast_is_expr ::= func(node : ast&, t : ast_expr_type -> bool)
{
	nexpr ::= node->expr;
	if(ast_is_any_expr(node))
	{
		return (nexpr.type) == t;
	}
	return false;
};

ast_is_decl ::= func(node : ast& -> bool)
{
	if(ast_is_stmt(node, ast_stmt.stmt_decl))
	{
		return true;
	}
	return (node->type) == (ast_type.decl);
};
