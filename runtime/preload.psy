embed_data : struct
{
	data : u8?;
	size : u64;
};

srcloc : struct
{
	file : u8?;
	line : u64;
	column : u64;
};

_atomic_ordering : enum
{
	.monotonic := 2;
	.acquire := 3;
	.release := 4;
	.acqrel := 5;
	.seqcst := 6;
};

_atomic_op : enum
{
	.xchg := 0;
	.add := 1;
	.sub := 2;
	.and := 3;
	.nand := 4;
	.or := 5;
	.xor := 6;
	.smax := 7;
	.smin := 8;
	.umax := 9;
	.umin := 10;
};

program_args : struct
{
	argc : s32;
	argv : u8??;
	envp : u8??;
	thread_id : u32;
};

static_if(_win32)
{
	SYSTEM_INFO : struct
	{
		dwOemId : u32;
		dwPageSize : u32;
		lpMinimumApplicationAddress : v0?;
		lpMaximumApplicationAddress : v0?;
		dwActiveProcessorMask : s64;
		dwNumberOfProcessors : u32;
		dwProcessorType : u32;
		dwAllocationGranularity : u32;
		wProcessorLevel : u16;
		wProcessorRevision : u16;
	};
	GetSystemInfo : func(lpSystemInfo : SYSTEM_INFO mut? -> v0) extern;
	Sleep : func(dwMilliSeconds : u32 -> v0) extern;
}
else
{
	_syscall0 ::= asm(num : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,~{rcx},~{r11},~{memory}';

	_syscall1 ::= asm(num : u64 weak, arg0 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},~{rcx},~{r11},~{memory}';

	_syscall2 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},~{rcx},~{r11},~{memory}';

	_syscall3 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},~{rcx},~{r11},~{memory}';

	_syscall4 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak, arg3 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},{r10},~{rcx},~{r11},~{memory}';

	_syscall5 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak, arg3 : u64 weak, arg4 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},{r10},{r8},~{rcx},~{r11},~{memory}';

	_syscall6 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak, arg3 : u64 weak, arg4 : u64 weak, arg5 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},{r10},{r8},{r9},~{rcx},~{r11},~{memory}';

	impl_mask_count_bits : func(mask : u64?, nbytes : u64 -> u32)
	{
		count : u32 mut := 0;
		nwords ::= nbytes / sizeof u64;
		i : u64 mut;
		for(i = 0;  i < nwords;  i = i + 1)
		{
			v : u64 mut := [mask # i];
			while(v > 0)
			{
				count = (count + ((v & 1)@_));
				v = (v >> 1);
			}
		}
		return count;
	};

	timespec : struct
	{
		tv_sec : u64;
		tv_nsec : u64;
	};
}

// how many logical cores does the host machine have
hardware_thread_count : func( -> u32)
{
	static_if(_win32)
	{
		info ::= zero@SYSTEM_INFO mut;
		GetSystemInfo(ref info);
		return info.dwNumberOfProcessors;
	}
	else
	{
		sys_sched_getaffinity ::= 204;
		mask : u64[16] := zero;
		// assume never fails even though it can xD
		_syscall3(sys_sched_getaffinity, 0, sizeof mask, mask # 0);
		return impl_mask_count_bits(mask # 0, sizeof mask);
	}
};

// how many threads have been span off by the entrypoint?
program_thread_count : func( -> u32)
{
	N ::= hardware_thread_count();

	thread_count : s32 mut;
	if(_thread_format_relative)
	{
		thread_count = (N + _thread_count);
	}
	else
	{
		thread_count = _thread_count;
	}
	return thread_count@_;
};

barrier : struct
{
	touch_count : u32;
	generation : u32;
};

barrier_sync : func(_my_barrier : barrier mut?, count : u32 -> v0)
{
	gen ::= _my_barrier->generation;
	// atomically increment
	__atomic_rmw(_atomic_op.add, ref(_my_barrier->touch_count), 1, _atomic_ordering.monotonic);
	while(!__atomic_cmpxchg(ref(_my_barrier->touch_count), count, 0, _atomic_ordering.monotonic))
	{
		if(_my_barrier->generation != gen)
		{
			// someone else zeroed it and the b is done.
			return;
		}
		sleep(1);
	}
	// the touch count just hit max and ive just set it back to 0
	// everyone else is waiting on the same thing (which wont ever happen now ive just set it to zero)
	// i will increment the generation however and formally finish the b.
	__atomic_rmw(_atomic_op.add, ref(_my_barrier->generation), 1, _atomic_ordering.acqrel);
};

sleep : func(millis : u64 -> v0)
{
	static_if(_win32)
	{
		Sleep(millis@_);
	}
	else
	{
		t_secs ::= millis / 1000;
		t_millis ::= (millis - (t_secs * 1000));
		my_ts ::= timespec mut
		{
			.tv_sec := t_secs@_;
			.tv_nsec := (t_millis * 1000000)@_;
		};
		// note: rem is entirely useless here, but due to what can only be undefined behaviour the 2nd parameter (ref ts) does not resolve to the address of ts on release builds
		rem ::= zero@timespec mut;
		sys_nanosleep ::= 35;
		_syscall2(sys_nanosleep, ref my_ts, ref rem);
	}
};
