embed_data ::= struct
{
	data : u8?;
	size : u64;
};

srcloc ::= struct
{
	file : u8?;
	line : u64;
	column : u64;
};

_atomic_ordering ::= enum
{
	.monotonic := 2;
	.acquire := 3;
	.release := 4;
	.acqrel := 5;
	.seqcst := 6;
};

_atomic_op ::= enum
{
	.xchg := 0;
	.add := 1;
	.sub := 2;
	.and := 3;
	.nand := 4;
	.or := 5;
	.xor := 6;
	.smax := 7;
	.smin := 8;
	.umax := 9;
	.umin := 10;
};

program_args ::= struct
{
	argc : s32;
	argv : u8??;
	envp : u8??;
	thread_id : u32;
};

static if(_win32)
{
	SYSTEM_INFO ::= struct
	{
		dwOemId : u32;
		dwPageSize : u32;
		lpMinimumApplicationAddress : v0?;
		lpMaximumApplicationAddress : v0?;
		dwActiveProcessorMask : s64;
		dwNumberOfProcessors : u32;
		dwProcessorType : u32;
		dwAllocationGranularity : u32;
		wProcessorLevel : u16;
		wProcessorRevision : u16;
	};
	GetSystemInfo ::= func(lpSystemInfo : SYSTEM_INFO mut? -> v0) := extern;
	Sleep ::= func(dwMilliSeconds : u32 -> v0) := extern;
}
else
{
	_syscall0 ::= asm(num : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,~{rcx},~{r11},~{memory}';

	_syscall1 ::= asm(num : u64 weak, arg0 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},~{rcx},~{r11},~{memory}';

	_syscall2 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},~{rcx},~{r11},~{memory}';

	_syscall3 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},~{rcx},~{r11},~{memory}';

	_syscall4 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak, arg3 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},{r10},~{rcx},~{r11},~{memory}';

	_syscall5 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak, arg3 : u64 weak, arg4 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},{r10},{r8},~{rcx},~{r11},~{memory}';

	_syscall6 ::= asm(num : u64 weak, arg0 : u64 weak, arg1 : u64 weak, arg2 : u64 weak, arg3 : u64 weak, arg4 : u64 weak, arg5 : u64 weak -> u64 weak) :=
	'syscall' : '={rax},0,{rdi},{rsi},{rdx},{r10},{r8},{r9},~{rcx},~{r11},~{memory}';

	impl_mask_count_bits ::= func(mask : u64?, nbytes : u64 -> u32)
	{
		count : u32 mut := 0;
		nwords ::= nbytes / __sizeof(u64);
		i : u64 mut;
		for(i = 0, i < nwords, i = i + 1)
		{
			v : u64 mut := deref(mask # i);
			while(v > 0)
			{
				count = (count + ((v & 1)@_));
				v = (v >> 1);
			}
		}
		return count;
	};

	timespec ::= struct
	{
		tv_sec : u64;
		tv_nsec : u64;
	};
}

// how many logical cores does the host machine have
hardware_thread_count ::= func( -> u32)
{
	static if(_win32)
	{
		info ::= zero@SYSTEM_INFO mut;
		GetSystemInfo(ref info);
		return info.dwNumberOfProcessors;
	}
	else
	{
		sys_sched_getaffinity ::= 204;
		mask : u64[16] := zero;
		// assume never fails even though it can xD
		_syscall3(sys_sched_getaffinity, 0, __sizeof(mask), mask # 0);
		return impl_mask_count_bits(mask # 0, __sizeof(mask));
	}
};

// how many threads have been span off by the entrypoint?
program_thread_count ::= func( -> u32)
{
	N ::= hardware_thread_count();

	thread_count : s32 mut;
	if(_thread_format_relative)
	{
		thread_count = (N + _thread_count);
	}
	else
	{
		thread_count = _thread_count;
	}
	return thread_count@_;
};

barrier_t ::= struct
{
	touch_count : u32;
	generation : u32;
};

barrier_global : barrier_t mut := zero;

barrier ::= func(count : u32 -> v0)
{
	gen ::= barrier_global.generation;
	// atomically increment
	__atomic_rmw(_atomic_op.add, ref(barrier_global.touch_count), 1, _atomic_ordering.monotonic);
	while(!__atomic_cmpxchg(ref(barrier_global.touch_count), count, 0, _atomic_ordering.monotonic))
	{
		if(barrier_global.generation != gen)
		{
			// someone else zeroed it and the barrier is done.
			return;
		}
		sleep(1);
	}
	// the touch count just hit max and ive just set it back to 0
	// everyone else is waiting on the same thing (which wont ever happen now ive just set it to zero)
	// i will increment the generation however and formally finish the barrier.
	__atomic_rmw(_atomic_op.add, ref(barrier_global.generation), 1, _atomic_ordering.acqrel);
};

sleep ::= func(millis : u64 -> v0)
{
	static if(_win32)
	{
		Sleep(millis@_);
	}
	else
	{
		t_secs ::= millis / 1000;
		t_millis ::= (millis - (t_secs * 1000));
		my_ts ::= timespec mut
		{
			.tv_sec := t_secs@_;
			.tv_nsec := (t_millis * 1000000)@_;
		};
		// note: rem is entirely useless here, but due to what can only be undefined behaviour the 2nd parameter (ref ts) does not resolve to the address of ts on release builds
		rem ::= zero@timespec mut;
		sys_nanosleep ::= 35;
		_syscall2(sys_nanosleep, ref my_ts, ref rem);
	}
};
