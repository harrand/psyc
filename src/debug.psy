di_type ::= func(t : ty -> u64)
{
	if(ty_isbad(t))
	{
		psyc_panic(zero, "attempted to codegen di_type(badtype). semal should've caught this. compiler bug.");
	}
	if((t.tag) == (tytag.prim))
	{
		return di_primty(t.prim);
	}
	if((t.tag) == (tytag.enm))
	{
		return di_primty(primty.s64);
	}
	if((t.tag) == (tytag.ptr))
	{
		ptr ::= t.ptr;
		u ::= deref((ptr.underlying)@ty?);
		di_u ::= di_type(u);
		return LLVMDIBuilderCreatePointerType(db, di_u, 64, zero, zero, zero, zero);
	}
	if((t.tag) == (tytag.strct))
	{
		strct ::= t.strct;
		def ::= program_find_struct(strct.name, strct.name_len);
		if((def->codegen) == 0)
		{
			cg_struct(def@_);
		}
		return def->dbg;
	}
	if((t.tag) == (tytag.fn))
	{
		fn ::= t.fn;
		paramdata : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (fn.param_count + 1));

		ret_di ::= di_type(deref((fn.return_type)@ty?));
		param_tys ::= (fn.param_types)@ty?;

		i : u64 mut;
		deref(paramdata # 0) = ret_di;
		for(i = 0, i < (fn.param_count), i = i + 1)
		{
			deref(paramdata # (i + 1)) = di_type(deref(param_tys # i));
		}

		// todo: dont lie
		file_scope ::= prog.global;
		return LLVMDIBuilderCreateSubroutineType(db, file_scope.dbg, paramdata, fn.param_count + 1, zero);
	}
	if((t.tag) == (tytag.arr))
	{
		arr ::= t.arr;
		u_di ::= di_type(deref((arr.underlying)@ty?));
		subrange ::= LLVMDIBuilderGetOrCreateSubrange(db, 0, arr.len);
		size ::= LLVMABISizeOfType(LLVMGetModuleDataLayout(mod), cg_type(t));
		align ::= LLVMABIAlignmentOfType(LLVMGetModuleDataLayout(mod), cg_type(t));
		return LLVMDIBuilderCreateArrayType(db, size * 8, align * 8, u_di, ref subrange, 1);
	}
	psyc_panic(zero, "control flow reached end of di_type - compiler bug.");
	return 0;
};

dbg_setup_builder ::= func( -> v0)
{
	if(prog.debug_symbols)
	{
		args ::= ref(prog.compile_args);

		dirname_len : u64 weak mut;
		dirname : u8 mut? mut;
		directory_get_cwd(ref dirname, ref dirname_len, global_arena);

		di_buildfile ::= LLVMDIBuilderCreateFile(db, args->build_file, zstrlen(args->build_file), dirname, dirname_len - 1);
		LLVM_DWARF_SRC_LANG_C ::= 1;
		producer_str ::= "Psyc";
		is_optimized ::= prog.opt != zero;
		LLVMDWARFEmissionNone ::= 0;
		LLVMDWARFEmissionFull ::= 1;
		emission : s32 weak mut := LLVMDWARFEmissionNone;
		if(prog.debug_symbols)
		{
			emission = LLVMDWARFEmissionFull;
		}
		di_cu = LLVMDIBuilderCreateCompileUnit(db, LLVM_DWARF_SRC_LANG_C, di_buildfile, producer_str, zstrlen(producer_str), is_optimized@s32, zero, zero, zero, zero, zero, emission, zero, true@s32, false@s32, zero, zero, zero, zero);
		glob ::= ref(prog.global);
		glob->dbg = di_cu;
	}
};

dbg_create_file ::= func(f : scope mut? -> v0)
{
	dirname_len : u64 weak mut;
	dirname : u8 mut? mut;
	directory_get_cwd(ref dirname, ref dirname_len, global_arena);
	f->dbg = LLVMDIBuilderCreateFile(db, f->scope_label, f->scope_label_len, dirname, dirname_len - 1);
};

dbg_markup_struct ::= func(def : structdef mut? -> v0)
{
	if(prog.debug_symbols)
	{
		node ::= def->node;
		type ::= def->type;
		if(ty_isbad(type))
		{
			psyc_panic(node->loc, "cg_struct structdef's type was badtype. semal should've sorted this - compiler bug.");
		}
		strct ::= type.strct;
		memtys ::= (strct.member_types)@ty?;
		memcount ::= strct.member_count;
		di_memarr : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * memcount);

		// file scope is really not correct for both
		file_scope ::= def->file_scope@scope?;
		struct_scope ::= file_scope;

		i : u64 mut;
		dl ::= LLVMGetModuleDataLayout(mod);
		for(i = 0, i < memcount, i = i + 1)
		{
			memty ::= deref(memtys # i);
			cg_memty ::= cg_type(memty);
			di_memty ::= di_type(memty);
			//deref(di_memarr # i) = di_type(deref(memtys # i));
			mem_offset ::= LLVMOffsetOfElement(dl, def->codegen, i@_);
			mem_size ::= LLVMABISizeOfType(dl, cg_memty);
			mem_align ::= LLVMABIAlignmentOfType(dl, cg_memty);
			deref(di_memarr # i) = LLVMDIBuilderCreateMemberType(db, struct_scope->dbg, deref(strct.member_names # i), deref(strct.member_name_lens # i), file_scope->dbg, def->node->loc.line@_, mem_size * 8, mem_align * 8, mem_offset * 8, zero, di_memty);
		}

		// todo: get the bloody file the struct is defined in...
		struct_file_scope ::= (def->file_scope)@scope?;
		size ::= LLVMABISizeOfType(LLVMGetModuleDataLayout(mod), cg_type(type));
		align ::= LLVMABIAlignmentOfType(LLVMGetModuleDataLayout(mod), cg_type(type));
		def->dbg = LLVMDIBuilderCreateStructType(db, struct_file_scope->dbg, def->name, def->name_len, struct_file_scope->dbg, node->loc.line@_, size * 8, align * 8, zero, zero, di_memarr, memcount@_, zero, zero, def->name, def->name_len);
	}
};

dbg_markup_func ::= func(fn : function mut? -> v0)
{
	if(prog.debug_symbols)
	{
		funcscope ::= (fn->impl_scope)@scope mut?;
		node ::= fn->node;

		filescope ::= scope_get_parent_filescope(funcscope);
		file_di ::= filescope->dbg;
		metadata_ty : u64 := di_type(fn->type);
		di_subprogram ::= LLVMDIBuilderCreateFunction(db, file_di, fn->name, fn->name_len, fn->name, fn->name_len, file_di, node->loc.line@_, metadata_ty, false@s32, true@s32, node->loc.column@_, 256, false@s32);

		LLVMSetSubprogram(fn->codegen, di_subprogram);
		funcscope->dbg = di_subprogram;
	}
};

dbg_markup_location ::= func(ctx : context -> v0)
{
	if(ctx.typecheck_only)
	{
		return;
	}
	if(prog.debug_symbols)
	{
		n ::= ctx.node;

		s : scope mut? mut := ctx.local;
		parentfn ::= scope_get_parent_function(s);
		if(parentfn != zero)
		{
			s = (parentfn->impl_scope)@scope mut?;
			//putzstr("expr location ");
			//putloc(n->loc);
			//putzstr(" belongs to parent function named ");
			//putbytes(parentfn->name, parentfn->name_len);
			//putchar(10);
		}
		else
		{
			// we have no parent function
			// use file scope.
			s = scope_get_parent_filescope(s);
		}
		if(s == zero)
		{
			return;
		}
		di_scope : u64 mut := s->dbg;
		dloc ::= LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), n->loc.line@_, n->loc.column@_, di_scope, zero);
		LLVMSetCurrentDebugLocation2(ir, dloc);
	}
};

dbg_markup_local_variable ::= func(var : variable mut?, s : scope mut? -> v0)
{
	if(prog.debug_symbols)
	{
		loc ::= var->node->loc;

		parent_fn ::= scope_get_parent_function(s);
		fnscope ::= (parent_fn->impl_scope)@scope mut?;
		parent_file ::= scope_get_parent_filescope(s);
		divar ::= LLVMDIBuilderCreateAutoVariable(db, fnscope->dbg, var->name, var->name_len, parent_file->dbg, loc.line@_, di_type(var->type), false@s32, zero, zero);
		LLVMDIBuilderInsertDeclareAtEnd(db, var->codegen, divar, LLVMDIBuilderCreateExpression(db, zero, zero), LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), loc.line@_, loc.column@_, fnscope->dbg, zero), fnscope->codegen);
	}
};

dbg_markup_parameter ::= func(var : variable mut?, s : scope mut?, param_idx : u64 -> v0)
{
	if(prog.debug_symbols)
	{
		loc ::= var->node->loc;

		parent_fn ::= scope_get_parent_function(s);
		fnscope ::= (parent_fn->impl_scope)@scope mut?;
		parent_file ::= scope_get_parent_filescope(s);
		divar ::= LLVMDIBuilderCreateParameterVariable(db, fnscope->dbg, var->name, var->name_len, param_idx@_, parent_file->dbg, loc.line@_, di_type(var->type), zero, zero);
		LLVMDIBuilderInsertDeclareAtEnd(db, var->codegen, divar, LLVMDIBuilderCreateExpression(db, zero, zero), LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), loc.line@_, loc.column@_, fnscope->dbg, zero), fnscope->codegen);
	}
};

dbg_markup_global_variable ::= func(var : variable mut?, s : scope mut? -> v0)
{
	if(prog.debug_symbols)
	{
		loc ::= var->node->loc;
		filescope ::= (var->file_scope)@scope mut?;

		divar ::= LLVMDIBuilderCreateGlobalVariableExpression(db, filescope->dbg, var->name, var->name_len, var->name, var->name_len, filescope->dbg, loc.line@_, di_type(var->type), false@s32, LLVMDIBuilderCreateExpression(db, zero, zero), zero, zero);
		LLVMGlobalSetMetadata(var->codegen, LLVMGetMDKindID("dbg", 3), divar);
	}
};

dbg_finalise ::= func( -> v0)
{
	if(prog.debug_symbols)
	{
		static if(_win32)
		{
			dbg_setup_codeview();
		}
		LLVMDIBuilderFinalize(db);
	}
};

dbg_setup_codeview ::= func( -> v0)
{
	if(prog.debug_symbols)
	{
		codeview_str ::= "CodeView";
		i32_type ::= cg_type(ty_getprim(primty.s32, zero));
		val_metadata ::= LLVMValueAsMetadata(LLVMConstInt(i32_type, 1, true@s32));
		LLVMAddModuleFlag(mod, 0, codeview_str, zstrlen(codeview_str), val_metadata);
	}
};
