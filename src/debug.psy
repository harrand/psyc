dbg_setup_builder ::= func(prog : program mut? -> v0)
{
	args ::= ref(prog->compile_args);

	dirname_len : u64 weak mut;
	dirname : u8 mut? mut;
	directory_get_cwd(ref dirname, ref dirname_len, global_arena);

	di_buildfile ::= LLVMDIBuilderCreateFile(db, args->build_file, zstrlen(args->build_file), dirname, dirname_len - 1);
	LLVM_DWARF_SRC_LANG_C ::= 1;
	producer_str ::= "Psyc";
	is_optimized ::= prog->opt != zero;
	LLVMDWARFEmissionNone ::= 0;
	LLVMDWARFEmissionFull ::= 1;
	emission : s32 weak mut := LLVMDWARFEmissionNone;
	if(prog->debug_symbols)
	{
		emission = LLVMDWARFEmissionFull;
	}
	di_cu = LLVMDIBuilderCreateCompileUnit(db, LLVM_DWARF_SRC_LANG_C, di_buildfile, producer_str, zstrlen(producer_str), is_optimized@s32, zero, zero, zero, zero, zero, emission, zero, true@s32, false@s32, zero, zero, zero, zero);
	glob ::= ref(prog->global);
	glob->dbg = di_cu;
};

dbg_create_file ::= func(f : scope mut?, prog : program mut? -> v0)
{
	dirname_len : u64 weak mut;
	dirname : u8 mut? mut;
	directory_get_cwd(ref dirname, ref dirname_len, global_arena);
	f->dbg = LLVMDIBuilderCreateFile(db, f->scope_label, f->scope_label_len, dirname, dirname_len - 1);
};


dbg_markup_struct ::= func(def : structdef mut?, prog : program mut? -> v0)
{
	node ::= def->node;
	type ::= def->type;
	if(ty_isbad(type))
	{
		psyc_panic(node->loc, "cg_struct structdef's type was badtype. semal should've sorted this - compiler bug.");
	}
	strct ::= type.strct;
	memtys ::= (strct.member_types)@ty?;
	memcount ::= strct.member_count;
	di_memarr : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * memcount);

	i : u64 mut;
	for(i = 0, i < memcount, i = i + 1)
	{
		deref(di_memarr # i) = di_type(deref(memtys # i), prog);
	}

	// todo: get the bloody file the struct is defined in...
	struct_file_scope ::= (def->file_scope)@scope?;
	size ::= LLVMABISizeOfType(LLVMGetModuleDataLayout(mod), cg_type(type, prog));
	align ::= LLVMABIAlignmentOfType(LLVMGetModuleDataLayout(mod), cg_type(type, prog));
	def->dbg = LLVMDIBuilderCreateStructType(db, struct_file_scope->dbg, def->name, def->name_len, struct_file_scope->dbg, node->loc.line@_, size * 8, align * 8, zero, zero, di_memarr, memcount@_, zero, zero, def->name, def->name_len);
};

dbg_markup_func ::= func(fn : function mut?, prog : program mut? -> v0)
{
	funcscope ::= (fn->impl_scope)@scope mut?;
	node ::= fn->node;

	filescope ::= scope_get_parent_filescope(funcscope, prog);
	file_di ::= filescope->dbg;
	metadata_ty : u64 := di_type(fn->type, prog);
	di_subprogram ::= LLVMDIBuilderCreateFunction(db, file_di, fn->name, fn->name_len, fn->name, fn->name_len, file_di, node->loc.line@_, metadata_ty, false@s32, true@s32, node->loc.column@_, 256, false@s32);

	LLVMSetSubprogram(fn->codegen, di_subprogram);
	funcscope->dbg = di_subprogram;
};

dbg_markup_location ::= func(ctx : context, prog : program? -> v0)
{
	if(ctx.typecheck_only)
	{
		return;
	}
	n ::= ctx.node;

	s : scope mut? mut := ctx.local;
	parentfn ::= scope_get_parent_function(s, prog);
	if(parentfn != zero)
	{
		s = (parentfn->impl_scope)@scope mut?;
		//putzstr("expr location ");
		//putloc(n->loc);
		//putzstr(" belongs to parent function named ");
		//putbytes(parentfn->name, parentfn->name_len);
		//putchar(10);
	}
	else
	{
		// we have no parent function
		// use file scope.
		s = scope_get_parent_filescope(s, prog);
	}
	if(s == zero)
	{
		return;
	}
	di_scope : u64 mut := s->dbg;
	dloc ::= LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), n->loc.line@_, n->loc.column@_, di_scope, zero);
	LLVMSetCurrentDebugLocation2(ir, dloc);
};


dbg_finalise ::= func(prog : program mut? -> v0)
{
	if(prog->debug_symbols)
	{
		LLVMDIBuilderFinalize(db);
	}
};

dbg_setup_codeview ::= func(prog : program mut? -> v0)
{
	codeview_str ::= "CodeView";
	i32_type ::= cg_type(ty_getprim(primty.s32, zero), prog);
	val_metadata ::= LLVMValueAsMetadata(LLVMConstInt(i32_type, 1, true@s32));
	LLVMAddModuleFlag(prog->codegen, 0, codeview_str, zstrlen(codeview_str), val_metadata);
};
