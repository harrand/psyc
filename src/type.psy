psyc_deduced_typename ::= "auto";

// global arena used by the type system.
tyar : arena mut& mut;

// tell me which arena im using on startup
type_setup ::= func(a : arena mut&) -> v0
{
	tyar = a;
};

tyqual ::= enum
{
	.static := 1;
	.mut := 2;
	.weak := 4;
};

primty ::= enum
{
	.s64 := 1;
	.s32 := 2;
	.s16 := 3;
	.s8 := 4;

	.u64 := 5;
	.u32 := 6;
	.u16 := 7;
	.u8 := 8;

	.bool := 9;
	.f64 := 10;
	.f32 := 11;

	.v0 := 12;
};

ptrty ::= struct
{
	underlying : v0&;
};

arrty ::= struct
{
	underlying : v0&;
	len : u64;
};

structty ::= struct
{
	member_count : u64;
	member_types : v0&&;
	member_names : u8&&;
	name : u8&;
	name_len : u64;
};

enumty ::= struct
{
	entry_count : u64;
	entry_values : u64&;
	entry_names : u8&&;
	name : u8&;
	name_len : u64;
};

fnty ::= struct
{
	return_type : v0&;
	param_count : u64;
	param_types : v0&&;
};

tytag ::= enum
{
	.prim := 0;
	.ptr := 1;
	.arr := 2;
	.strct := 3;
	.enm := 4;
	.fn := 5;
	.badtype := 6;
};

ty ::= struct
{
	tag : tytag;
	qual : tyqual;

	prim : primty;
	ptr : ptrty;
	arr : arrty;
	strct : structty;
	enm : enumty;
	fn : fnty;
};

ty_badtype ::= func() -> ty
{
	return ty
	{
		.tag := tytag.badtype;
	};
};

putqual ::= func(q : tyqual) -> v0
{
	if(q == zero)
	{
		return;
	}
	if(q & (tyqual.static))
	{
		putchar(' ');
		puts(__enumname(tyqual.static));
	}
	if(q & (tyqual.weak))
	{
		putchar(' ');
		puts(__enumname(tyqual.weak));
	}
	if(q & (tyqual.mut))
	{
		putchar(' ');
		puts(__enumname(tyqual.mut));
	}
};

putprim ::= func(t : primty) -> v0
{
	puts(__enumname(t));
};

putty ::= func(t : ty) -> v0
{
	tag ::= t.tag;
	if(tag == (tytag.prim))
	{
		putprim(t.prim);
	}
	if(tag == (tytag.ptr))
	{
		ptr ::= t.ptr;
		underlying ::= (ptr.underlying)@ty&;
		putty(deref underlying);
		putchar('&');
	}
	if(tag == (tytag.arr))
	{
		arr ::= t.arr;
		underlying ::= (arr.underlying)@ty&;
		putty(deref underlying);
		putchar('#');
		putuint(arr.len);
	}
	if(tag == (tytag.badtype))
	{
		puts("<badtype>");
	}
	putqual(t.qual);
};

// make a pointer to an existing type
ty_ref ::= func(t : ty) -> ty
{
	underlying_data ::= arena_push(tyar, __sizeof(ty));
	__memcpy(underlying_data, ref t, __sizeof(ty));
	return ty
	{
		.tag := tytag.ptr;
		.ptr := ptrty
		{
			.underlying := underlying_data;
		};
	};
};

// deref a pointer. must be a pointer type
ty_deref ::= func(t : ty) -> ty
{
	ptr ::= t.ptr;
	u ::= (ptr.underlying)@ty&;
	return deref u;
};

// get the underlying type. must be a pointer or array type
ty_underlying ::= func(t : ty) -> ty
{
	tag ::= t.tag;
	if(tag == (tytag.ptr))
	{
		ptr ::= t.ptr;
		return deref((ptr.underlying)@ty&);
	}
	if(tag == (tytag.arr))
	{
		arr ::= t.arr;
		return deref((arr.underlying)@ty&);
	}
	psyc_panic(srcloc_current(), "failed get underlying type, you probably called ty_underlying on a type that doesnt have one");
	return zero;
};

// retrieve a primitive type that matches specifications. zero = no quals
ty_getprim ::= func(p : primty, q : tyqual) -> ty
{
	return ty
	{
		.tag := tytag.prim;
		.qual := q;
		.prim := p;
	};
};

// retrieve an array type t#len. zero = no quals
ty_getarr ::= func(t : ty, len : u64, q : tyqual) -> ty
{
	underlying_data ::= arena_push(tyar, __sizeof(ty));
	__memcpy(underlying_data, ref t, __sizeof(ty));
	return ty
	{
		.tag := tytag.arr;
		.qual := q;
		.arr := arrty
		{
			.underlying := underlying_data;
			.len := len;
		};
	};
};

ty_noquals ::= func(t : ty) -> bool
{
	return (t.qual) == zero;
};

// query as to whether a type has a given qualifier.
ty_hasqual ::= func(t : ty, q : tyqual) -> bool
{
	return ((t.qual) & q) != 0;
};

// box of types. used to store all types defined in a given lexical scope
tybox ::= struct
{
	structs : structty mut&;
	structs_size : u64;
	structs_cap : u64;
};

tybox_empty ::= func() -> tybox
{
	ret : tybox mut := zero;
	(ret.structs_cap) = 8;
	structs_bytes ::= __sizeof(deref (ret.structs)) * (ret.structs_cap);
	(ret.structs) = arena_push(tyar, structs_bytes);
	__memset(ret.structs, 0, structs_bytes);
	return ret;
};

tybox_find_struct ::= func(box : tybox&, s : structty) -> u64
{
	n ::= box->structs_size;
	i : u64 mut;
	ptr ::= box->structs;
	for(i = 0, i < n, i = i + 1)
	{
		cur ::= deref(ptr at i);
		if((cur.name_len) == (s.name_len))
		{
			if(cstreql_n(cur.name, s.name, cur.name_len))
			{
				return i;
			}
		}
	}
	return -1;
};

tybox_add_struct ::= func(box : tybox mut&, s : structty) -> v0
{
	id ::= (box->structs_size);
	(box->structs_size) = (box->structs_size) + 1;
	ptr ::= box->structs;
	deref(ptr at id) = s;
};

== build ==
{
	add_source_file("stdlib/io.psy");
}
