program_type ::= enum
{
	.executable := 0;
	.object := 1;
	.library := 2;
};

program_output ::= struct
{
	name : u8?;
	output_dir : u8?;
};

program_optimization ::= enum
{
	.o0 := 0;
	.o1 := 1;
	.o2 := 2;
	.o3 := 3;
};

program ::= struct
{
	compile_args : psyc_compile_args;
	output : program_output;
	name : u8?;
	name_len : u64;
	type : program_type;

	scopes : lexical_scope mut?;
	scopes_count : u64;
	scopes_cap : u64;

	source_files : source_file mut?;
	source_files_count : u64;
	source_files_cap : u64;

	queued_source_paths : u8? mut?;
	queued_source_path_lens : u64 mut?;
	queued_source_paths_count : u64;
	queued_source_paths_cap : u64;

	queued_build_paths : u8? mut?;
	queued_build_path_lens : u64 mut?;
	queued_build_path_configs : u8? mut?;
	queued_build_paths_count : u64;
	queued_build_paths_cap : u64;

	types : tybox;

	debug_symbols : bool;
	optimization : program_optimization;

	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

source_file ::= struct
{
	src : u8?;
	path : u8?;
};

variable ::= struct
{
	node : ast mut?;
	type : tyid;
	compile_time_storage : val;

	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

structure ::= struct
{
	node : ast mut?;
	// remember, cg and db belong in the structty
	type : tyid;
};

function ::= struct
{
	node : ast mut?;
	type : tyid;
	// todo: change type to lexical_scope mut? when circular dependencies (via pointers) are allowed
	scope : v0 mut? weak;
	name : u8?;
	name_len : u64;
	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

enumeration ::= struct
{
	node : ast mut?;
	type : tyid;
	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

assembly ::= struct
{
	node : ast mut?;
	name : u8?;
	name_len : u64;

	code : u8?;
	code_len : u64;
	constraints : u8?;
	constraints_len : u64;

	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

region ::= struct
{
	node : ast mut?;
	name : u8?;
	name_len : u64;
};

program_add_scope ::= func(-> lexical_scope mut?)
{
	if(prog.scopes == zero)
	{
		prog.scopes_cap = 8;
		prog.scopes = arena_alloc(global_arena, prog.scopes_cap * __sizeof(deref(prog.scopes)));
	}
	while(prog.scopes_count >= (prog.scopes_cap))
	{
		oldcap ::= prog.scopes_cap;
		olddata ::= prog.scopes;
		prog.scopes_cap = (prog.scopes_cap * 2);
		prog.scopes = arena_alloc(global_arena, prog.scopes_cap * __sizeof(deref(prog.scopes)));
		memcopy(prog.scopes, olddata, oldcap * __sizeof(deref(prog.scopes)));
	}
	i ::= prog.scopes_count;
	prog.scopes_count = (prog.scopes_count + 1);
	ptr ::= prog.scopes # i;
	// set the id internally. caller has to be careful not to overwrite it
	ptr->id = i;
	return ptr;
};

program_get_scope ::= func(id : u64 -> lexical_scope mut?)
{
	return prog.scopes # id;
};

program_scope ::= func(-> lexical_scope mut?)
{
	return program_get_scope(0);
};

program_push_source_file ::= func(file : source_file -> v0)
{
	if(prog.source_files == zero)
	{
		prog.source_files_cap = 8;
		prog.source_files = arena_alloc(global_arena, prog.source_files_cap * __sizeof(deref(prog.source_files)));
	}
	while(prog.source_files_count >= (prog.source_files_cap))
	{
		oldcap ::= prog.source_files_cap;
		olddata ::= prog.source_files;
		prog.source_files_cap = (prog.source_files_cap * 2);
		prog.source_files = arena_alloc(global_arena, prog.source_files_cap * __sizeof(deref(prog.source_files)));
		memcopy(prog.source_files, olddata, oldcap * __sizeof(deref(prog.source_files)));
	}
	i ::= prog.source_files_count;
	prog.source_files_count = (prog.source_files_count + 1);
	deref(prog.source_files # i) = file;
};

program_current_source_file ::= func(-> source_file)
{
	return deref(prog.source_files # (prog.source_files_count - 1));
};

program_find_source_file ::= func(path : u8? -> source_file?)
{
	len ::= zstrlen(path);
	i : u64 mut;
	for(i = 0, i < (prog.source_files_count), i = i + 1)
	{
		cur ::= prog.source_files # i;
		curlen ::= zstrlen(cur->path);
		if(len == curlen)
		{
			if(streql_n(cur->path, path, len))
			{
				return cur;
			}
		}
	}
	return zero;
};

program_queue_source_file ::= func(path : u8?, path_len : u64 -> v0)
{
	if(prog.queued_source_paths == zero)
	{
		prog.queued_source_paths_cap = 8;
		prog.queued_source_paths = arena_alloc(global_arena, prog.queued_source_paths_cap * __sizeof(deref(prog.queued_source_paths)));
		prog.queued_source_path_lens = arena_alloc(global_arena, prog.queued_source_paths_cap * __sizeof(deref(prog.queued_source_path_lens)));
	}
	while(prog.queued_source_paths_count >= (prog.queued_source_paths_cap))
	{
		oldcap ::= prog.queued_source_paths_cap;
		oldpathdata ::= prog.queued_source_paths;
		oldlendata ::= prog.queued_source_path_lens;

		prog.queued_source_paths_cap = (prog.queued_source_paths_cap * 2);
		prog.queued_source_paths = arena_alloc(global_arena, prog.queued_source_paths_cap * __sizeof(deref(prog.queued_source_paths)));
		prog.queued_source_path_lens = arena_alloc(global_arena, prog.queued_source_paths_cap * __sizeof(deref(prog.queued_source_path_lens)));
		memcopy(prog.queued_source_paths, oldpathdata, oldcap * __sizeof(deref(prog.queued_source_paths)));
		memcopy(prog.queued_source_path_lens, oldlendata, oldcap * __sizeof(deref(prog.queued_source_path_lens)));

		arena_free(global_arena, oldpathdata, oldcap * __sizeof(deref(prog.queued_source_paths)));
		arena_free(global_arena, oldlendata, oldcap * __sizeof(deref(prog.queued_source_path_lens)));
	}
	deref(prog.queued_source_paths # (prog.queued_source_paths_count)) = path;
	deref(prog.queued_source_path_lens # (prog.queued_source_paths_count)) = path_len;
	prog.queued_source_paths_count = (prog.queued_source_paths_count + 1);
};

program_queue_build_file ::= func(path : u8?, path_len : u64, config : u8? -> v0)
{
	if(prog.queued_build_paths == zero)
	{
		prog.queued_build_paths_cap = 8;
		prog.queued_build_paths = arena_alloc(global_arena, prog.queued_build_paths_cap * __sizeof(deref(prog.queued_build_paths)));
		prog.queued_build_path_lens = arena_alloc(global_arena, prog.queued_build_paths_cap * __sizeof(deref(prog.queued_build_path_lens)));
		prog.queued_build_path_configs = arena_alloc(global_arena, prog.queued_build_paths_cap * __sizeof(deref(prog.queued_build_path_configs)));
	}
	while(prog.queued_build_paths_count >= (prog.queued_build_paths_cap))
	{
		oldcap ::= prog.queued_build_paths_cap;
		oldpathdata ::= prog.queued_build_paths;
		oldlendata ::= prog.queued_build_path_lens;
		oldcfgdata ::= prog.queued_build_path_configs;

		prog.queued_build_paths_cap = (prog.queued_build_paths_cap * 2);
		prog.queued_build_paths = arena_alloc(global_arena, prog.queued_build_paths_cap * __sizeof(deref(prog.queued_build_paths)));
		prog.queued_build_path_lens = arena_alloc(global_arena, prog.queued_build_paths_cap * __sizeof(deref(prog.queued_build_path_lens)));
		prog.queued_build_path_configs = arena_alloc(global_arena, prog.queued_build_paths_cap * __sizeof(deref(prog.queued_build_path_configs)));
		memcopy(prog.queued_build_paths, oldpathdata, oldcap * __sizeof(deref(prog.queued_build_paths)));
		memcopy(prog.queued_build_path_lens, oldlendata, oldcap * __sizeof(deref(prog.queued_build_path_lens)));
		memcopy(prog.queued_build_path_configs, oldcfgdata, oldcap * __sizeof(deref(prog.queued_build_path_configs)));

		arena_free(global_arena, oldpathdata, oldcap * __sizeof(deref(prog.queued_build_paths)));
		arena_free(global_arena, oldlendata, oldcap * __sizeof(deref(prog.queued_build_path_lens)));
		arena_free(global_arena, oldcfgdata, oldcap * __sizeof(deref(prog.queued_build_path_configs)));
	}
	deref(prog.queued_build_paths # (prog.queued_build_paths_count)) = path;
	deref(prog.queued_build_path_lens # (prog.queued_build_paths_count)) = path_len;
	deref(prog.queued_build_path_configs # (prog.queued_build_paths_count)) = config;
	prog.queued_build_paths_count = (prog.queued_build_paths_count + 1);
};
