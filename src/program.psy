structure ::= struct
{
	name : u8?;
	name_len : u64;
	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

program ::= struct
{
	compile_args : psyc_compile_args;
	name : u8?;
	name_len : u64;

	scopes : lexical_scope mut?;
	scopes_count : u64;
	scopes_cap : u64;
};

function ::= struct
{
	node : ast mut?;
	// todo: change type to lexical_scope mut? when circular dependencies (via pointers) are allowed
	scope : v0 mut? weak;
};

scope_type ::= enum
{
	.program := 0;
	.file := 1;
	.function := 2;
};

lexical_scope ::= struct
{
	type : scope_type;
	name : u8?;
	name_len : u64;
	id : u64;
	parent_id : u64;

	functions : function mut?;
	functions_count : u64;
	functions_cap : u64;
};

scope_add_function ::= func(scope : lexical_scope mut? mut, fn : function -> v0)
{
	// naughty secret here:
	// if the scope is a file scope
	// we change ourselves to the program scope so the function becomes globally available
	// we could just have it in both but then the data could go out of sync
	// you can always use function.node->loc to get the original file location anyway.
	if(scope->type == (scope_type.file))
	{
		scope = program_scope();
	}

	if(scope->functions == zero)
	{
		scope->functions_cap = 8;
		scope->functions = arena_alloc(global_arena, scope->functions_cap * __sizeof(deref(scope->functions)));
	}
	while(scope->functions_count >= (scope->functions_cap))
	{
		oldcap ::= scope->functions_cap;
		olddata ::= scope->functions;
		scope->functions_cap = (scope->functions_cap * 2);
		scope->functions = arena_alloc(global_arena, scope->functions_cap * __sizeof(deref(scope->functions)));
		memcopy(scope->functions, olddata, oldcap * __sizeof(deref(scope->functions)));
	}
	deref(scope->functions # (scope->functions_count)) = fn;
	scope->functions_count = (scope->functions_count + 1);
};

program_add_scope ::= func(-> lexical_scope mut?)
{
	if(prog.scopes == zero)
	{
		prog.scopes_cap = 8;
		prog.scopes = arena_alloc(global_arena, prog.scopes_cap * __sizeof(deref(prog.scopes)));
	}
	while(prog.scopes_count >= (prog.scopes_cap))
	{
		oldcap ::= prog.scopes_cap;
		olddata ::= prog.scopes;
		prog.scopes_cap = (prog.scopes_cap * 2);
		prog.scopes = arena_alloc(global_arena, prog.scopes_cap * __sizeof(deref(prog.scopes)));
		memcopy(prog.scopes, olddata, oldcap * __sizeof(deref(prog.scopes)));
	}
	i ::= prog.scopes_count;
	prog.scopes_count = (prog.scopes_count + 1);
	ptr ::= prog.scopes # i;
	// set the id internally. caller has to be careful not to overwrite it
	ptr->id = i;
	return ptr;
};

program_get_scope ::= func(id : u64 -> lexical_scope mut?)
{
	return prog.scopes # id;
};

program_scope ::= func(-> lexical_scope mut?)
{
	return program_get_scope(0);
};

scope_get_parent ::= func(s : lexical_scope mut? -> lexical_scope mut?)
{
	if(s->parent_id == -1)
	{
		return zero;
	}
	return program_get_scope(s->parent_id);
};
