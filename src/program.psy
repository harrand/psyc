program_type : enum
{
	.executable := 0;
	.object := 1;
	.library := 2;
};

program_output : struct
{
	name : u8?;
	dir : u8?;
};

program_optimization : enum
{
	.o0 := 0;
	.o1 := 1;
	.o2 := 2;
	.o3 := 3;
};

program : struct
{
	compile_args : psyc_compile_args;
	output : program_output;
	type : program_type;

	scopes : lexical_scope mut?;
	scopes_count : u64;
	scopes_cap : u64;

	link_libraries : u8? mut?;
	link_libraries_lens : u64 mut?;
	link_libraries_count : u64;
	link_libraries_cap : u64;

	source_files : source_file mut?;
	source_files_count : u64;
	source_files_cap : u64;

	queued_source_paths : u8? mut?;
	queued_source_path_lens : u64 mut?;
	queued_source_paths_count : u64;
	queued_source_paths_cap : u64;

	queued_build_paths : u8? mut?;
	queued_build_path_lens : u64 mut?;
	queued_build_path_configs : u8? mut?;
	queued_build_paths_count : u64;
	queued_build_paths_cap : u64;

	queued_postbuild_commands : u8? mut?;
	queued_postbuild_command_lens : u64 mut?;
	queued_postbuild_commands_count : u64;
	queued_postbuild_commands_cap : u64;

	types : tybox;

	debug_symbols : bool;
	optimization : program_optimization;

	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

source_file : struct
{
	src : u8?;
	path : u8?;
};

variable : struct
{
	node : ast mut?;
	type : tyid;
	compile_time_storage : val;
	// if this variable is a parameter to a parent function, this is the param idx.
	// if its not a param, then this is -1
	param_idx : u64;

	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

structure : struct
{
	node : ast mut?;
	// remember, cg and db belong in the structty
	type : tyid;
};

function : struct
{
	node : ast mut?;
	type : tyid;
	// todo: change type to lexical_scope mut? when circular dependencies (via pointers) are allowed
	scope : lexical_scope mut?;
	name : u8?;
	name_len : u64;
	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

enumeration : struct
{
	node : ast mut?;
	type : tyid;
	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

assembly : struct
{
	node : ast mut?;
	name : u8?;
	name_len : u64;
	type : tyid;

	code : u8?;
	code_len : u64;
	constraints : u8?;
	constraints_len : u64;

	// opaque codegen handle
	cg : u64;
	// opaque debug information handle
	db : u64;
};

region : struct
{
	node : ast mut?;
	name : u8?;
	name_len : u64;
};

program_add_scope : func(data : lexical_scope -> lexical_scope mut?)
{
	if(prog.scopes == zero)
	{
		prog.scopes_cap = 8;
		prog.scopes = arena_alloc(global_arena, prog.scopes_cap * sizeof typeof([prog.scopes]));
	}
	while(prog.scopes_count >= (prog.scopes_cap))
	{
		oldcap ::= prog.scopes_cap;
		olddata ::= prog.scopes;
		prog.scopes_cap = (prog.scopes_cap * 2);
		prog.scopes = arena_alloc(global_arena, prog.scopes_cap * sizeof typeof([prog.scopes]));
		memcopy(prog.scopes, olddata, oldcap * sizeof typeof([prog.scopes]));
	}
	i ::= prog.scopes_count;
	prog.scopes_count = (prog.scopes_count + 1);
	ptr ::= prog.scopes # i;
	[ptr] = data;
	// set the id internally. caller has to be careful not to overwrite it
	ptr->id = i;
	return ptr;
};

program_get_scope : func(id : u64 -> lexical_scope mut?)
{
	return prog.scopes # id;
};

program_find_file_scope : func(name : u8?, name_len : u64 -> lexical_scope mut?)
{
	i : u64 mut;
	for(i = 0; i < (prog.scopes_count); i = i + 1)
	{
		cur ::= prog.scopes # i;
		if((cur->type == (scope_type.file)) && (cur->name_len == name_len))
		{
			if(streql_n(cur->name, name, name_len))
			{
				return cur;
			}
		}
	}
	return zero;
};

program_scope : func(-> lexical_scope mut?)
{
	return program_get_scope(0);
};

program_push_source_file : func(file : source_file -> v0)
{
	if(prog.source_files == zero)
	{
		prog.source_files_cap = 8;
		prog.source_files = arena_alloc(global_arena, prog.source_files_cap * sizeof typeof([prog.source_files]));
	}
	while(prog.source_files_count >= (prog.source_files_cap))
	{
		oldcap ::= prog.source_files_cap;
		olddata ::= prog.source_files;
		prog.source_files_cap = (prog.source_files_cap * 2);
		prog.source_files = arena_alloc(global_arena, prog.source_files_cap * sizeof typeof([prog.source_files]));
		memcopy(prog.source_files, olddata, oldcap * sizeof typeof([prog.source_files]));
	}
	i ::= prog.source_files_count;
	prog.source_files_count = (prog.source_files_count + 1);
	[prog.source_files # i] = file;
};

program_current_source_file : func(-> source_file)
{
	return [prog.source_files # (prog.source_files_count - 1)];
};

program_find_source_file_id : func(path : u8? -> u64)
{
	len ::= zstrlen(path);
	i : u64 mut;
	for(i = 0; i < (prog.source_files_count); i = i + 1)
	{
		cur ::= prog.source_files # i;
		curlen ::= zstrlen(cur->path);
		if(len == curlen)
		{
			if(streql_n(cur->path, path, len))
			{
				return i;
			}
		}
	}
	return ~0;
};

program_find_source_file : func(path : u8? -> source_file mut?)
{
	id ::= program_find_source_file_id(path);
	if(id == ~0)
	{
		return zero;
	}
	return prog.source_files # id;
};

program_add_link_library : func(path : u8?, path_len : u64 -> v0)
{
	if(prog.link_libraries == zero)
	{
		prog.link_libraries_cap = 8;
		prog.link_libraries = arena_alloc(global_arena, prog.link_libraries_cap * sizeof typeof([prog.link_libraries]));
		prog.link_libraries_lens = arena_alloc(global_arena, prog.link_libraries_cap * sizeof typeof([prog.link_libraries_lens]));
	}
	while(prog.link_libraries_count >= (prog.link_libraries_cap))
	{
		oldcap ::= prog.link_libraries_cap;
		oldpathdata ::= prog.link_libraries;
		oldlendata ::= prog.link_libraries_lens;

		prog.link_libraries_cap = (prog.link_libraries_cap * 2);
		prog.link_libraries = arena_alloc(global_arena, prog.link_libraries_cap * sizeof typeof([prog.link_libraries]));
		prog.link_libraries_lens = arena_alloc(global_arena, prog.link_libraries_cap * sizeof typeof([prog.link_libraries_lens]));
		memcopy(prog.link_libraries, oldpathdata, oldcap * sizeof typeof([prog.link_libraries]));
		memcopy(prog.link_libraries_lens, oldlendata, oldcap * sizeof typeof([prog.link_libraries_lens]));

		arena_free(global_arena, oldpathdata, oldcap * sizeof typeof([prog.link_libraries]));
		arena_free(global_arena, oldlendata, oldcap * sizeof typeof([prog.link_libraries_lens]));
	}
	[prog.link_libraries # (prog.link_libraries_count)] = path;
	[prog.link_libraries_lens # (prog.link_libraries_count)] = path_len;
	prog.link_libraries_count = (prog.link_libraries_count + 1);
};

program_queue_source_file : func(path : u8?, path_len : u64 -> v0)
{
	if(prog.queued_source_paths == zero)
	{
		prog.queued_source_paths_cap = 8;
		prog.queued_source_paths = arena_alloc(global_arena, prog.queued_source_paths_cap * sizeof typeof([prog.queued_source_paths]));
		prog.queued_source_path_lens = arena_alloc(global_arena, prog.queued_source_paths_cap * sizeof typeof([prog.queued_source_path_lens]));
	}
	while(prog.queued_source_paths_count >= (prog.queued_source_paths_cap))
	{
		oldcap ::= prog.queued_source_paths_cap;
		oldpathdata ::= prog.queued_source_paths;
		oldlendata ::= prog.queued_source_path_lens;

		prog.queued_source_paths_cap = (prog.queued_source_paths_cap * 2);
		prog.queued_source_paths = arena_alloc(global_arena, prog.queued_source_paths_cap * sizeof typeof([prog.queued_source_paths]));
		prog.queued_source_path_lens = arena_alloc(global_arena, prog.queued_source_paths_cap * sizeof typeof([prog.queued_source_path_lens]));
		memcopy(prog.queued_source_paths, oldpathdata, oldcap * sizeof typeof([prog.queued_source_paths]));
		memcopy(prog.queued_source_path_lens, oldlendata, oldcap * sizeof typeof([prog.queued_source_path_lens]));

		arena_free(global_arena, oldpathdata, oldcap * sizeof typeof([prog.queued_source_paths]));
		arena_free(global_arena, oldlendata, oldcap * sizeof typeof([prog.queued_source_path_lens]));
	}
	// let's have a nice absolute path so if our cwd changes its no biggie
	cwd : u8? mut;
	cwdlen : u64 mut;
	directory_get_cwd(ref cwd, ref cwdlen, string_arena);
	absolute_path_len ::= cwdlen + path_len;
	absolute_path : u8 mut? := arena_alloc(string_arena, absolute_path_len);
	memcopy(absolute_path # 0, cwd, cwdlen);
	// cwdlen - 1 because it includes the null terminator for some god-forsaken reason
	[absolute_path # (cwdlen - 1)] = '/';
	memcopy(absolute_path # cwdlen, path, path_len);
	
	[prog.queued_source_paths # (prog.queued_source_paths_count)] = absolute_path;
	[prog.queued_source_path_lens # (prog.queued_source_paths_count)] = absolute_path_len;
	prog.queued_source_paths_count = (prog.queued_source_paths_count + 1);
};

program_queue_build_file : func(path : u8?, path_len : u64, config : u8? -> v0)
{
	if(prog.queued_build_paths == zero)
	{
		prog.queued_build_paths_cap = 8;
		prog.queued_build_paths = arena_alloc(global_arena, prog.queued_build_paths_cap * sizeof typeof([prog.queued_build_paths]));
		prog.queued_build_path_lens = arena_alloc(global_arena, prog.queued_build_paths_cap * sizeof typeof([prog.queued_build_path_lens]));
		prog.queued_build_path_configs = arena_alloc(global_arena, prog.queued_build_paths_cap * sizeof typeof([prog.queued_build_path_configs]));
	}
	while(prog.queued_build_paths_count >= (prog.queued_build_paths_cap))
	{
		oldcap ::= prog.queued_build_paths_cap;
		oldpathdata ::= prog.queued_build_paths;
		oldlendata ::= prog.queued_build_path_lens;
		oldcfgdata ::= prog.queued_build_path_configs;

		prog.queued_build_paths_cap = (prog.queued_build_paths_cap * 2);
		prog.queued_build_paths = arena_alloc(global_arena, prog.queued_build_paths_cap * sizeof typeof([prog.queued_build_paths]));
		prog.queued_build_path_lens = arena_alloc(global_arena, prog.queued_build_paths_cap * sizeof typeof([prog.queued_build_path_lens]));
		prog.queued_build_path_configs = arena_alloc(global_arena, prog.queued_build_paths_cap * sizeof typeof([prog.queued_build_path_configs]));
		memcopy(prog.queued_build_paths, oldpathdata, oldcap * sizeof typeof([prog.queued_build_paths]));
		memcopy(prog.queued_build_path_lens, oldlendata, oldcap * sizeof typeof([prog.queued_build_path_lens]));
		memcopy(prog.queued_build_path_configs, oldcfgdata, oldcap * sizeof typeof([prog.queued_build_path_configs]));

		arena_free(global_arena, oldpathdata, oldcap * sizeof typeof([prog.queued_build_paths]));
		arena_free(global_arena, oldlendata, oldcap * sizeof typeof([prog.queued_build_path_lens]));
		arena_free(global_arena, oldcfgdata, oldcap * sizeof typeof([prog.queued_build_path_configs]));
	}
	[prog.queued_build_paths # (prog.queued_build_paths_count)] = path;
	[prog.queued_build_path_lens # (prog.queued_build_paths_count)] = path_len;
	[prog.queued_build_path_configs # (prog.queued_build_paths_count)] = config;
	prog.queued_build_paths_count = (prog.queued_build_paths_count + 1);
};

program_queue_postbuild_command : func(path : u8?, path_len : u64 -> v0)
{
	if(prog.queued_postbuild_commands == zero)
	{
		prog.queued_postbuild_commands_cap = 8;
		prog.queued_postbuild_commands = arena_alloc(global_arena, prog.queued_postbuild_commands_cap * sizeof typeof([prog.queued_postbuild_commands]));
		prog.queued_postbuild_command_lens = arena_alloc(global_arena, prog.queued_postbuild_commands_cap * sizeof typeof([prog.queued_postbuild_command_lens]));
	}
	while(prog.queued_postbuild_commands_count >= (prog.queued_postbuild_commands_cap))
	{
		oldcap ::= prog.queued_postbuild_commands_cap;
		oldpathdata ::= prog.queued_postbuild_commands;
		oldlendata ::= prog.queued_postbuild_command_lens;

		prog.queued_postbuild_commands_cap = (prog.queued_postbuild_commands_cap * 2);
		prog.queued_postbuild_commands = arena_alloc(global_arena, prog.queued_postbuild_commands_cap * sizeof typeof([prog.queued_postbuild_commands]));
		prog.queued_postbuild_command_lens = arena_alloc(global_arena, prog.queued_postbuild_commands_cap * sizeof typeof([prog.queued_postbuild_command_lens]));
		memcopy(prog.queued_postbuild_commands, oldpathdata, oldcap * sizeof typeof([prog.queued_postbuild_commands]));
		memcopy(prog.queued_postbuild_command_lens, oldlendata, oldcap * sizeof typeof([prog.queued_postbuild_command_lens]));

		arena_free(global_arena, oldpathdata, oldcap * sizeof typeof([prog.queued_postbuild_commands]));
		arena_free(global_arena, oldlendata, oldcap * sizeof typeof([prog.queued_postbuild_command_lens]));
	}
	[prog.queued_postbuild_commands # (prog.queued_postbuild_commands_count)] = path;
	[prog.queued_postbuild_command_lens # (prog.queued_postbuild_commands_count)] = path_len;
	prog.queued_postbuild_commands_count = (prog.queued_postbuild_commands_count + 1);
};
