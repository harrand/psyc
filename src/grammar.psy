grammar_install ::= func(-> v0)
{
	grammar_exprify();
	grammar_typename();
	grammar_decl();

	grammar_decl_init_expr(ast_expr_tag.zero_value);
};

grammar_exprify ::= func(-> v0)
{
	// symbol expression
	grammar_hashtable_insert(state1(
		token(lex_token.symbol),
	zero, zero),
	grammar_rule{.fn := rule_token_symbol2symbol_expr;});

	// literal expression (char)
	grammar_hashtable_insert(state1(
		token(lex_token.char_literal),
	zero, zero),
	grammar_rule{.fn := rule_token_char_literal2literal_expr;});

	// literal expression (string)
	grammar_hashtable_insert(state1(
		token(lex_token.string_literal),
	zero, zero),
	grammar_rule{.fn := rule_token_string_literal2literal_expr;});

	// literal expression (bool): 'true' and 'false'
	grammar_hashtable_insert(state1(
		token(lex_token.keyword_true),
	zero, zero),
	grammar_rule{.fn := rule_token_keyword_true2literal_expr;});
	grammar_hashtable_insert(state1(
		token(lex_token.keyword_false),
	zero, zero),
	grammar_rule{.fn := rule_token_keyword_false2literal_expr;});

	/// zero expression
	grammar_hashtable_insert(state1(
		token(lex_token.keyword_zero),
	zero, zero),
	grammar_rule{.fn := rule_token_keyword_zero2literal_expr;});
};

grammar_typename ::= func(-> v0)
{
	// normally a symbol by itself (e.g 'foo' is a symbol expression)
	// in the case that we have an await_typename stashed however we can say its a typename
	grammar_hashtable_insert(state1(
		token(lex_token.symbol),
	zero, decl(ast_decl_tag.await_type)),
	grammar_rule{.fn := rule_token_symbol2typename_wip;});

	// now a wip typename basically stays wip until it doesnt have any lookaheads we expect (in which case we finalise it)
	// but lets do the lookahead first to keep things intuitive.
	// if we see something we like we shift1 to get it into the node array and then process it in some way

	// first are all the typequal tokens.
	// tyqual.mut:
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qual_mut), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qual_mut),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2mut;});

	// tyqual.static:
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qual_static), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qual_static),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2static;});

	// tyqual.weak:
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qual_weak), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qual_weak),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2weak;});

	// ok now pointerness
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qmark), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qmark),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2ptr;});

	// todo: function typenames...
	// maybe todo: decltype

	// ok now that we've done the lookahead possibilities.
	// if we dont see any of those then we assume the lookahead is irrelevant and our typename is now complete.
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2finalised;});
};

grammar_decl ::= func(-> v0)
{
	grammar_hashtable_insert(state1(
		token(lex_token.symbol),
	token(lex_token.colon), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		token(lex_token.symbol),
		token(lex_token.colon),
	zero, zero),
	grammar_rule{.fn := rule_token_symbol_token_colon2decl_awaittype;});

	// a decl.await_type will be stashed until a typename is found
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.await_type),
	zero, zero),
	grammar_rule{.fn := rule_stash;});

	// unstash await_type if we have a finished typename ready to go.
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.finalised),
	zero, decl(ast_decl_tag.await_type)),
	grammar_rule{.fn := rule_unstash;});

	// ok if we have a await_type decl and a typename, then we combine them into a basic decl!
	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.await_type),
		typename(ast_typename_tag.finalised),
	zero, zero),
	grammar_rule{.fn := rule_decl_awaittype_typename_finalised2noinit;});

	// if noinit is followed by an initialiser then great we can turn it into an await_init_expr
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.noinit),
	token(lex_token.initialiser), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.noinit),
		token(lex_token.initialiser),
	zero, zero),
	grammar_rule{.fn := rule_decl_noinit_token_initialiser2await_init_expr;});

	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.await_init_expr),
	zero, zero),
	grammar_rule{.fn := rule_stash;});

	// note: code to handle init-exprs is below in grammar_decl_init_expr.
	// this is so the expr tags allowed can be parameterised

	// ok so lets move on. what if our noinit is *not* followed by an initialiser
	// well then we finalise it without one i.e this is 'foo : u64'
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.noinit),
	zero, zero),
	grammar_rule{.fn := rule_decl_noinit2finalised;});

	// note: what we do with a finalised decl depends on quite a few things so we dont handle it here.
	// examples could be:
	// - followed by a semicol -> stmtify
	// - function stashed -> add as param
};

grammar_decl_init_expr ::= func(exprtag : ast_expr_tag -> v0)
{
	grammar_hashtable_insert(state1(
		expr(exprtag),
	zero, decl(ast_decl_tag.await_init_expr)),
	grammar_rule{.fn := rule_unstash;});

	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.await_init_expr),
		expr(exprtag),
	zero, zero),
	grammar_rule{.fn := rule_decl_await_init_expr_init_expr2finalised;});
};
