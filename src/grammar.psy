ar : arena mut& mut;

hashnode ::= func(t : ast_type) -> u64
{
	v ::= (t@s64) * 1093;
	return hash(v);
};

hashtoken ::= func(t : lex_token) -> u64
{
	multiplier ::= (ast_type.unparsed_token)@s64 * 866820901;
	return multiplier ^ hash(t);
};

hashexpr ::= func(t : ast_expr_type) -> u64
{
	multiplier ::= (ast_type.expr)@s64 * 190299117;
	return multiplier ^ hash(t);
};

hashstmt ::= func(t : ast_stmt) -> u64
{
	multiplier ::= (ast_type.stmt)@s64 * 393505272299;
	return multiplier ^ hash(t);
};

hash_state ::= func(nodes : ast&, node_count : u64) -> u64
{
	i : u64 mut;
	hash : u64 mut := zero;
	for(i = 0, i < node_count, i = i + 1)
	{
		curnode ::= deref (nodes at i);
		istoken ::= (curnode.type) == (ast_type.unparsed_token);
		isexpr ::= (curnode.type) == (ast_type.expr);
		isstmt ::= (curnode.type) == (ast_type.stmt);
		if(istoken)
		{
			utok ::= curnode.utok;
			tokdata ::= utok.tok;
			hash = (hash ^ hashtoken(tokdata.tok));
		}
		if(isexpr)
		{
			expr ::= curnode.expr;
			hash = (hash ^ hashexpr(expr.type));
		}
		if(isstmt)
		{
			hash = (hash ^ hashstmt(curnode.stmt));
		}
		if(!istoken)
		{
			if(!isexpr)
			{
				if(!isstmt)
				{
					hash = (hash ^ hashnode(curnode.type));
				}
			}
		}
		hash = hash * 34875947865;
	}
	return hash;
};

parse_action ::= enum
{
	.invalid := 0;
	.reduce := 1;
	.recurse := 2;
	.shift := 3;
	.commit := 4;
	.error := 5;
};

parse_value ::= struct
{
	action : parse_action;
	offset : u64;
	len : u64;
	errmsg : u8&;
	nodes : ast mut#16;
	nodes_size : u64;

	push : bool;
	pop : bool;
};
grammar_rule ::= struct
{
	fn : func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value;
};

default_rule ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "default rule invoked";
		.push := false;
		.pop := false;
	};
};

[[private]]
parse_table : grammar_rule mut& mut;
[[private]]
parse_table_size : u64 mut;
[[private]]
parse_table_cap : u64 mut;

null_lookahead ::= zero@ast;

pty ::= enum
{
	.head := 1;
	.tail := 2;
	.both := 3;
};
grammar_install_impl ::= func(do_work : bool, my_nodes : ast mut&, my_nodes_size : u64, nodes_count : u64, lookahead_node : ast, allow_begin_state : bool, rule : grammar_rule) -> v0
{
	if(!do_work)
	{
		return;
	}
	[[__force_mutable]] hash : u64 mut := hash_state(my_nodes at 0, nodes_count);
	__memset(my_nodes at 0, 0, my_nodes_size);
	[[__force_mutable]] la ::= lookahead_node;
	[[__force_mutable]] la_hash : u64 mut := zero;
	if((la.type) != (ast_type.unknown))
	{
		la_hash = (!hash_state(ref la, 1));
		hash = (hash ^ la_hash);
	}
	if(allow_begin_state)
	{
		hash = !hash;
	}

	[[__force_mutable]] ptr ::= parse_table at (hash % parse_table_cap);
	if(ptr->fn != zero)
	{
		psyc_panic(srcloc_current(), "hash collision detected");
	}
	deref(ptr) = rule;
};

grammar_install ::= macro(nc : u64, la : ast, albs : pty, r : grammar_rule) -> v0
{
	grammar_install_impl((albs & (pty.head)) > 0, my_nodes at 0, __sizeof(my_nodes), nc, la, true, r);
	grammar_install_impl((albs & (pty.tail)) > 0, my_nodes at 0, __sizeof(my_nodes), nc, la, false, r);
};

token ::= macro(t : lex_token) -> ast static
{
	yield ast
	{
		.type := ast_type.unparsed_token;
		.utok := ast_unparsed_token
		{
			.tok := token_data
			{
				.tok := t;
			};
		};
	};
};

node ::= macro(t : ast_type) -> ast static
{
	yield ast
	{
		.type := t;
	};
};

expr ::= macro(t : ast_expr_type) -> ast static
{
	yield ast
	{
		.type := ast_type.expr;
		.expr := ast_expr{.type := t;};
	};
};

stmt ::= macro(t : ast_stmt) -> ast static
{
	yield ast
	{
		.type := ast_type.stmt;
		.stmt := t;
	};
};

rule ::= macro(f : auto) -> grammar_rule
{
	yield grammar_rule{.fn := f;};
};

grammar_get_rule ::= func(hash : u64) -> grammar_rule
{
	idx ::= hash % parse_table_cap;
	// todo: open addressing.
	return deref(parse_table at idx);
};

// REDUCTION SETUP

setup_decls ::= macro() -> v0
{
	firstptr ::= nodes at 0;
	first ::= deref firstptr;
	lastptr ::= nodes at (nodes_size - 1);
	last ::= deref lastptr;
};

setup_delete_all ::= macro(action : parse_action) -> v0
{
	ret : parse_value mut := parse_value
	{
		.action := action;
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;
};

setup_delete_all_but_first ::= macro(action : parse_action) -> v0
{
	ret : parse_value mut := parse_value
	{
		.action := action;
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;
};
/////////////////////////////////////////////////////////////////////
//////////////////////// REDUCTION FUNCTIONS ////////////////////////
/////////////////////////////////////////////////////////////////////

num2expr ::= func(src : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return zero;
};

grammar_numeric_literals ::= macro() -> v0
{
	grammar_install(
		__arrcpy(ast, my_nodes, token(lex_token.numeric_literal)),
		null_lookahead,
		pty.both,
		rule(default_rule));
};

grammar_setup ::= func(a : arena mut&) -> v0
{
	psyc_timed(psyc_stage.setup);
	ar = a;
	parse_table_cap = 65536;
	parse_table = arena_push(a, __sizeof(deref parse_table) * parse_table_cap);
	__memset(parse_table, 0, __sizeof(deref parse_table) * parse_table_cap);

	my_nodes : ast mut#16;

	grammar_numeric_literals();
};

== build ==
{
	add_source_file("stdlib/hash.psy");

	add_source_file("ast.psy");
	add_source_file("type.psy");
}
