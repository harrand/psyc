grammar_install ::= func(-> v0)
{
	grammar_exprify();

	grammar_deref();
	foreach_expr(grammar_deref_expr);

	grammar_unop(lex_token.dash, ast_unop.minus);
	grammar_unop_expr(lex_token.dash, ast_unop.minus, ast_expr_tag.literal);

	grammar_typename();
	grammar_typename_array_length_expr(ast_expr_tag.literal);
	grammar_decl_explicitly_typed();
	grammar_decl_deducibly_typed();

	foreach_expr(grammar_decl_init_expr);

	grammar_struct();

	foreach_expr(grammar_stmtify_expr);
	grammar_stmtify_nonexpr();

	foreach_stmt(grammar_commit_stmt);
};

grammar_exprify ::= func(-> v0)
{
	// symbol expression
	grammar_hashtable_insert(state1(
		token(lex_token.symbol),
	zero, zero),
	grammar_rule{.fn := rule_token_symbol2symbol_expr;});

	// literal expression (numeric)
	grammar_hashtable_insert(state1(
		token(lex_token.numeric_literal),
	zero, zero),
	grammar_rule{.fn := rule_token_numeric_literal2literal_expr;});

	// literal expression (char)
	grammar_hashtable_insert(state1(
		token(lex_token.char_literal),
	zero, zero),
	grammar_rule{.fn := rule_token_char_literal2literal_expr;});

	// literal expression (string)
	grammar_hashtable_insert(state1(
		token(lex_token.string_literal),
	zero, zero),
	grammar_rule{.fn := rule_token_string_literal2literal_expr;});

	// literal expression (bool): 'true' and 'false'
	grammar_hashtable_insert(state1(
		token(lex_token.keyword_true),
	zero, zero),
	grammar_rule{.fn := rule_token_keyword_true2literal_expr;});
	grammar_hashtable_insert(state1(
		token(lex_token.keyword_false),
	zero, zero),
	grammar_rule{.fn := rule_token_keyword_false2literal_expr;});

	/// zero expression
	grammar_hashtable_insert(state1(
		token(lex_token.keyword_zero),
	zero, zero),
	grammar_rule{.fn := rule_token_keyword_zero2literal_expr;});
};

grammar_deref ::= func(-> v0)
{
	grammar_hashtable_insert(state1(
		token(lex_token.obrack),
	zero, zero),
	grammar_rule{.fn := rule_stash;});
};

grammar_deref_expr ::= func(exprtag : ast_expr_tag -> v0)
{
	// try not to early munch exprs here. make sure the lookahead is cbrack
	// btw yes we do stash obrack and treat that as our equivalent of an ast_deref_tag
	// most of the time we cant do this because certain things require more than 1 token but deref is just [ expr ]
	// we have a limited number of possible ast states so this allows us to save one.
	// in short: do this sparingly, for anything of nontrivial complexity use a specific ast tag but for something like this its chill + simpler + faster
	grammar_hashtable_insert(state1(
		expr(exprtag),
	token(lex_token.cbrack), token(lex_token.obrack)),
	grammar_rule{.fn := rule_unstash;});
		
	grammar_hashtable_insert(state2(
		token(lex_token.obrack),
		expr(exprtag),
	token(lex_token.cbrack), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state3(
		token(lex_token.obrack),
		expr(exprtag),
		token(lex_token.cbrack),
	zero, zero),
	grammar_rule{.fn := rule_token_obrack_expr_token_cbrack2deref;});
};

grammar_unop ::= func(tok : lex_token, op : ast_unop -> v0)
{
	grammar_hashtable_insert(state1(
		token(tok),
	zero, zero),
	grammar_rule{.fn := rule_stash;});
};

grammar_unop_expr ::= func(tok : lex_token, op : ast_unop, exprtag : ast_expr_tag -> v0)
{
	// is there anyway to guarantee this doesnt early munch?
	// actually uh not really
	// e.g ref x + 5
	// it will be ref(x) + 5
	// but tbf in c &x + 5 is the same thing so maybe its okay
	
	// ok so we need to somehow tell the grammar rule which unop the token maps to
	// we could in theory just add it to the grammar_rule signature but that's extremely ridiculous - everyone else would zero it
	// so instead we have a global array called 'lex_token_as_unop'
	// we set the element at our token type to be the unop we were given.
	// if it was already set to something else then we have to panic.
	unop_value ::= lex_token_as_unop # (tok@s64);
	if(deref(unop_value) != zero)
	{
		psyc_panic_begin(zero);
		putzstr("compiler bug a grammar rule invocation is trying to map unop.");
		putzstr(__enumname(op));
		putzstr(" to lex_token.");
		putzstr(__enumname(tok));
		putzstr(" but seemingly someone else already mapped that token to unop.");
		putzstr(__enumname(deref unop_value));
		psyc_diag_end();
		psyc_exit_failure();
	}
	// for mysterious reasons this memory is invalid
	// maybe im too sleep deprived
	// todo: future harry debug this.
	deref(unop_value) = op;
	grammar_hashtable_insert(state1(
		expr(exprtag),
	zero, token(tok)),
	grammar_rule{.fn := rule_unstash;});

	grammar_hashtable_insert(state2(
		token(tok),
		expr(exprtag),
	zero, zero),
	grammar_rule{.fn := rule_token_x_expr2unop;});
};

grammar_typename ::= func(-> v0)
{
	// normally a symbol by itself (e.g 'foo' is a symbol expression)
	// in the case that we have an await_typename stashed however we can say its a typename
	grammar_hashtable_insert(state1(
		token(lex_token.symbol),
	zero, decl(ast_decl_tag.await_type)),
	grammar_rule{.fn := rule_token_symbol2typename_wip;});

	// now a wip typename basically stays wip until it doesnt have any lookaheads we expect (in which case we finalise it)
	// but lets do the lookahead first to keep things intuitive.
	// if we see something we like we shift1 to get it into the node array and then process it in some way

	// first are all the typequal tokens.
	// tyqual.mut:
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qual_mut), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qual_mut),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2mut;});

	// tyqual.static:
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qual_static), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qual_static),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2static;});

	// tyqual.weak:
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qual_weak), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qual_weak),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2weak;});

	// ok now pointerness
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.qmark), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.qmark),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2ptr;});

	// arrayness is somewhat more complicated
	// in theory it would be quite nice to not only allow numeric literals but any expression
	// so we need to put it into an array state and then stash until an expression comes around.
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	token(lex_token.obrack), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		typename(ast_typename_tag.wip),
		token(lex_token.obrack),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2array_await_length;});

	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.array_await_length),
	zero, zero),
	grammar_rule{.fn := rule_stash;});
	// the idea here is that when we see a valid array initialiser we unstash and combine it back into the typename_wip
	// however we want to be explicit in which expr types are valid initialisers
	// so the rest of this logic is in grammar_typename_array_length_expr

	// todo: function typenames...
	// maybe todo: decltype

	// ok now that we've done the lookahead possibilities.
	// if we dont see any of those then we assume the lookahead is irrelevant and our typename is now complete.
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.wip),
	zero, zero),
	grammar_rule{.fn := rule_typename_wip2finalised;});
};

grammar_typename_array_length_expr ::= func(exprtag : ast_expr_tag -> v0)
{
	// we need to be quite careful here
	// we dont want to munch before a biop for example
	// so when we see the expr we actually shift again
	// only when its array_await_length,  exprtag, ] do we know for sure
	grammar_hashtable_insert(state1(
		expr(exprtag),
	token(lex_token.cbrack), typename(ast_typename_tag.array_await_length)),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		expr(exprtag),
		token(lex_token.cbrack),
	zero, typename(ast_typename_tag.array_await_length)),
	grammar_rule{.fn := rule_unstash;});

	grammar_hashtable_insert(state3(
		typename(ast_typename_tag.array_await_length),
		expr(exprtag),
		token(lex_token.cbrack),
	zero, zero),
	grammar_rule{.fn := rule_typename_array_await_length_expr_token_semicol2wip;});
	
};

grammar_decl_explicitly_typed ::= func(-> v0)
{
	grammar_hashtable_insert(state1(
		token(lex_token.symbol),
	token(lex_token.colon), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		token(lex_token.symbol),
		token(lex_token.colon),
	zero, zero),
	grammar_rule{.fn := rule_token_symbol_token_colon2decl_awaittype;});

	// a decl.await_type will be stashed until a typename is found
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.await_type),
	zero, zero),
	grammar_rule{.fn := rule_stash;});

	// unstash await_type if we have a finished typename ready to go.
	grammar_hashtable_insert(state1(
		typename(ast_typename_tag.finalised),
	zero, decl(ast_decl_tag.await_type)),
	grammar_rule{.fn := rule_unstash;});

	// ok if we have a await_type decl and a typename, then we combine them into a basic decl!
	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.await_type),
		typename(ast_typename_tag.finalised),
	zero, zero),
	grammar_rule{.fn := rule_decl_awaittype_typename_finalised2noinit;});

	// if noinit is followed by an initialiser then great we can turn it into an await_init_expr
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.noinit),
	token(lex_token.initialiser), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.noinit),
		token(lex_token.initialiser),
	zero, zero),
	grammar_rule{.fn := rule_decl_noinit_token_initialiser2await_init_expr;});

	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.await_init_expr),
	zero, zero),
	grammar_rule{.fn := rule_stash;});

	// note: code to handle init-exprs is below in grammar_decl_init_expr.
	// this is so the expr tags allowed can be parameterised

	// ok so lets move on. what if our noinit is *not* followed by an initialiser
	// well then we finalise it without one i.e this is 'foo : u64'
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.noinit),
	zero, zero),
	grammar_rule{.fn := rule_decl_noinit2finalised;});

	// note: what we do with a finalised decl depends on quite a few things so we dont handle it here.
	// examples could be:
	// - followed by a semicol -> stmtify
	// - function stashed -> add as param
};

grammar_decl_deducibly_typed ::= func(-> v0)
{
	// im not sure deducibly is a word...
	// i mean 'foo ::= 5' instead of 'foo : s64 := 5'
	grammar_hashtable_insert(state2(
		token(lex_token.symbol),
		token(lex_token.colon),
	token(lex_token.initialiser), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state3(
		token(lex_token.symbol),
		token(lex_token.colon),
		token(lex_token.initialiser),
	zero, zero),
	grammar_rule{.fn := rule_token_symbol_token_colon_token_initialiser2decl_await_init_expr;});
};

grammar_decl_init_expr ::= func(exprtag : ast_expr_tag -> v0)
{
	grammar_hashtable_insert(state1(
		expr(exprtag),
	zero, decl(ast_decl_tag.await_init_expr)),
	grammar_rule{.fn := rule_unstash;});

	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.await_init_expr),
		expr(exprtag),
	zero, zero),
	grammar_rule{.fn := rule_decl_await_init_expr_init_expr2finalised;});
};

grammar_struct ::= func(-> v0)
{
	grammar_hashtable_insert(state3(
		token(lex_token.symbol),
		token(lex_token.colon),
		token(lex_token.initialiser),
	token(lex_token.keyword_struct), zero),
	grammar_rule{.fn := rule_shift2;});

	grammar_hashtable_insert(state5(
		token(lex_token.symbol),
		token(lex_token.colon),
		token(lex_token.initialiser),
		token(lex_token.keyword_struct),
		token(lex_token.obrace),
	zero, zero),
	grammar_rule{.fn := rule_token_symbol_token_colon_token_initialiser_token_keyword_struct_token_obrace2structure_wip;});

	grammar_hashtable_insert(state1(
		structure(ast_structure_tag.wip),
	zero, zero),
	grammar_rule{.fn := rule_stash;});

	// remember, when decls are stmtified they get committed so if we're stashed we get it as a child automatically
	// so lets unstash and finalise ourselves when we see a cbrace

	grammar_hashtable_insert(state1(
		token(lex_token.cbrace),
	zero, structure(ast_structure_tag.wip)),
	grammar_rule{.fn := rule_unstash;});

	grammar_hashtable_insert(state2(
		structure(ast_structure_tag.wip),
		token(lex_token.cbrace),
	zero, zero),
	grammar_rule{.fn := rule_structure_wip_token_cbrace2finalised;});

};

grammar_stmtify_expr ::= func(exprtag : ast_expr_tag -> v0)
{
	// allow expr(T); to be stmtified
	// non-expr stmtifications belong in grammar_stmtify_nonexpr
	grammar_hashtable_insert(state1(
		expr(exprtag),
	token(lex_token.semicol), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		expr(exprtag),
		token(lex_token.semicol),
	zero, zero),
	grammar_rule{.fn := rule_expr_token_semicol2stmt;});
};

grammar_stmtify_nonexpr ::= func(-> v0)
{
	// any non-exprs that can get stmtified live here.
	// exprs are separate because all expr tags behave the same
	// but each of these are special and require their own rule.
	// decl stmts
	grammar_hashtable_insert(state1(
		decl(ast_decl_tag.finalised),
	token(lex_token.semicol), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		decl(ast_decl_tag.finalised),
		token(lex_token.semicol),
	zero, zero),
	grammar_rule{.fn := rule_decl_finalised_token_semicol2stmt;});

	// structure
	grammar_hashtable_insert(state1(
		structure(ast_structure_tag.finalised),
	token(lex_token.semicol), zero),
	grammar_rule{.fn := rule_shift1;});

	grammar_hashtable_insert(state2(
		structure(ast_structure_tag.finalised),
		token(lex_token.semicol),
	zero, zero),
	grammar_rule{.fn := rule_structure_finalised_token_semicol2stmt;});
};

grammar_commit_stmt ::= func(stmttag : ast_stmt_tag -> v0)
{
	grammar_hashtable_insert(state1(
		stmt(stmttag),
	zero, zero),
	grammar_rule{.fn := rule_commit;});
};
