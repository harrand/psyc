hashnode ::= func(t : ast_type -> u64)
{
	v ::= (t@s64) * 1093;
	return hash(v);
};

hashtoken ::= func(t : lex_token -> u64)
{
	multiplier ::= (ast_type.unparsed_token)@s64 * 866820901;
	return (multiplier ^ hash(t))@u64;
};

hashexpr ::= func(t : ast_expr_type -> u64)
{
	multiplier ::= (ast_type.expr)@s64 * 190299117;
	return (multiplier ^ hash(t))@u64;
};

hashstmt ::= func(t : ast_stmt -> u64)
{
	multiplier ::= (ast_type.stmt)@s64 * 393505272299;
	return (multiplier ^ hash(t))@u64;
};

hash_state ::= func(nodes : ast?, node_count : u64 -> u64)
{
	i : u64 mut;
	hash : u64 mut := zero;
	for(i = 0, i < node_count, i = i + 1)
	{
		curnode ::= deref (nodes # i);
		istoken ::= (curnode.type) == (ast_type.unparsed_token);
		isexpr ::= (curnode.type) == (ast_type.expr);
		isstmt ::= (curnode.type) == (ast_type.stmt);
		if(istoken)
		{
			utok ::= curnode.utok;
			tokdata ::= utok.tok;
			hash = (hash ^ hashtoken(tokdata.tok));
		}
		if(isexpr)
		{
			expr ::= curnode.expr;
			hash = (hash ^ hashexpr(expr.type));
		}
		if(isstmt)
		{
			hash = (hash ^ hashstmt(curnode.stmt));
		}
		if(!istoken)
		{
			if(!isexpr)
			{
				if(!isstmt)
				{
					hash = (hash ^ hashnode(curnode.type));
				}
			}
		}
		hash = hash * 34875947865;
	}
	return hash;
};

parse_action ::= enum
{
	.invalid := 0;
	.reduce := 1;
	.shift := 2;
	.commit := 3;
	.stash := 4;
	.unstash := 5;
	.error := 6;
};

parse_value ::= struct
{
	action : parse_action;
	offset : u64;
	len : u64;
	errmsg : u8?;
	nodes : ast mut[16];
	nodes_size : u64;
};
grammar_rule ::= struct
{
	fn : func(source : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value);
	hash : u64;
};

default_rule_errmsg ::= "default rule invoked\n";
default_rule ::= func(source : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := default_rule_errmsg;
	};
};


parse_table : grammar_rule mut? mut;
parse_table_size : u64 mut;
parse_table_cap : u64 mut;
grammar_install_count : u64 mut;

node_arena : ast mut[16] mut := zero;

grammar_install ::= func(nc : u64, lookahead : ast, stash : ast, r : grammar_rule -> v0)
{
	la ::= lookahead;
	st ::= stash;
	grammar_install_count = grammar_install_count + 1;
	hash : u64 mut := hash_state(node_arena # 0, nc);
	memfill(node_arena # 0, 0, __sizeof(node_arena));
	la_hash : u64 mut := zero;
	if((la.type) != (ast_type.unknown))
	{
		la_hash = (~(hash_state(ref la, 1) ^ (202020202 * hash)));
		hash = (hash ^ la_hash);
	}
	st_hash : u64 mut := zero;
	if((st.type) != (ast_type.unknown))
	{
		st_hash = (~(hash_state(ref st, 1) ^ (101010101 * hash)));
		hash = (hash ^ st_hash);
	}

	idx ::= hash % parse_table_cap;
	ptr : grammar_rule mut? mut := parse_table # idx;
	i : u64 mut := zero;
	while((ptr->fn) != zero)
	{
		i = i + 1;
		ptr = (parse_table # ((idx + i) % parse_table_cap));
		if(i >= parse_table_cap)
		{
			psyc_panic(__curloc(), "ran out of space in the grammar rule hashtable");
		}
	}
	deref(ptr) = r;
	(ptr->hash) = hash;
};

token ::= func(tokty : lex_token -> ast)
{
	return ast
	{
		.type := ast_type.unparsed_token;
		.utok := ast_unparsed_token
		{
			.tok := token_data
			{
				.tok := tokty;
			};
		};
	};
};

node ::= func(ty : ast_type -> ast)
{
	return ast
	{
		.type := ty;
	};
};

expr ::= func(ty : ast_expr_type -> ast)
{
	return ast
	{
		.type := ast_type.expr;
		.expr := ast_expr{.type := ty;};
	};
};

stmt ::= func(ty : ast_stmt -> ast)
{
	return ast
	{
		.type := ast_type.stmt;
		.stmt := ty;
	};
};

grammar_get_rule ::= func(hash : u64 -> grammar_rule)
{
	idx ::= hash % parse_table_cap;
	ptr : grammar_rule mut? mut := parse_table # idx;
	i : u64 mut := zero;
	while((ptr->hash) != hash)
	{
		if((ptr->fn) == zero)
		{
			return deref ptr;
		}
		i = i + 1;
		ptr = (parse_table # ((idx + i) % parse_table_cap));
		if(i >= parse_table_cap)
		{
			psyc_panic(__curloc(), "woopsey");
		}
	}
	return deref ptr;
};

// REDUCTION SETUP

setup_decls ::= macro() -> v0
{
	firstptr ::= nodes # 0;
	first ::= deref firstptr;
	lastptr ::= nodes # (nodes_size - 1);
	last ::= deref lastptr;
};

/////////////////////////////////////////////////////////////////////
//////////////////////// REDUCTION FUNCTIONS ////////////////////////
/////////////////////////////////////////////////////////////////////
commit_head ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.commit;
		.offset := 0;
		.len := 1;
	};
};

stash_head ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.stash;
		.offset := 0;
		.len := 0;
	};
};

stash_head_delete_all ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.stash;
		.offset := 0;
		.len := nodes_size - 1;
	};
};

stash_last ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.stash;
		.offset := nodes_size - 1;
		.len := 0;
	};
};

unstash_head ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.unstash;
		.offset := 0;
	};
};

unstash_last ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.unstash;
		.offset := nodes_size - 1;
	};
};

shift1 ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value{.action := parse_action.shift; .len := 1;};
};

shift2 ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value{.action := parse_action.shift; .len := 2;};
};

shift3 ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value{.action := parse_action.shift; .len := 3;};
};

swallow_all ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
};

num2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	utok ::= first.utok;
	tok ::= utok.tok;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(interpret_numeric_literal(src, tok.lexeme));
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

sym2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_symbol_expr(ast_symbol_expr
		{
			.symbol := src # (lex.off);
			.len := lex.len;
		});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

char2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.char_literal;
			.chars := src # (lex.off);
			.chars_len := lex.len;
		});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

str2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.string_literal;
			.chars := src # (lex.off);
			.chars_len := lex.len;
		});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

true2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.bool_literal;
			.boolean := true;
		});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

false2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.bool_literal;
			.boolean := false;
		});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

zero2expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.zero_literal;
		});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

parenthesise_expr ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	// this is a more unique reduction
	// 3 nodes: (, expr, )
	// literally just return expr
	// we dont sensibly have a way to delete 2 separate spans of nodes, only one
	// so we will just delete them all and recreate the middle node.
	deref((ret.nodes) # 0) = deref(nodes # 1);
	// however there is an edge case.
	// if the expr is a biop, then we want to increase the precedence of the biop hugely so its not stolen by other biops.
	newfront ::= (ret.nodes) # 0;
	if((newfront->type) == (ast_type.expr))
	{
		expr ::= ref(newfront->expr);
		if((expr->type) == (ast_expr_type.biop))
		{
			biop ::= ref(expr->biop);
			(biop->attack_precedence) = 0;
			(biop->defence_precedence) = 99999;
		}
 	}
	(ret.nodes_size) = 1;
};

keywordret2retvoid ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := ast_expr
		{
			.type := ast_expr_type.ret;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

keywordretexpr2ret ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := ast_expr
		{
			.type := ast_expr_type.ret;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	ast_add_child((ret.nodes) # 0, last, global_arena);
	(ret.nodes_size) = 1;
};

keywordyieldexpr2yield ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := ast_expr
		{
			.type := ast_expr_type.yld;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	ast_add_child((ret.nodes) # 0, last, global_arena);
	(ret.nodes_size) = 1;
};

expr2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.expr_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

decl2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.decl_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

fn2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.fn_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

asm2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.asm_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

mac2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.mac_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

struct2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.struct_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

enum2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.enum_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

init2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.init_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

if2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.if_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

while2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.while_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

for2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.for_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

region2stmt ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.region_stmt);
	(firstptr->cursor_end) = (last.cursor_end);
};

tokenexpr2unop ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	// which token type # front?
	utok ::= first.utok;
	tok ::= utok.tok;
	unop_ty ::= ast_unop_type_from_token(tok.tok);
	if(unop_ty == -1)
	{
		return parse_value{.action := parse_action.error; .errmsg := "unrecognised unary operator";};
	}

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_unop_expr(ast_unop_expr{.type := unop_ty;});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	ast_unop_set_operand((ret.nodes) # 0, last, global_arena);
	(ret.nodes_size) = 1;
};

deferstmt2unop ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt.expr_stmt;
		.expr := make_unop_expr(ast_unop_expr{.type := ast_unop_type.op_defer;});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	ast_unop_set_operand((ret.nodes) # 0, last, global_arena);
	(ret.nodes_size) = 1;
};

exprtok2halfbiop ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	// expr *
	// make a biop with only one child
	// so we can stash it.
	second ::= deref(nodes # 1);
	utok ::= second.utok;
	tok ::= utok.tok;
	biop_ty ::= ast_biop_type_from_token(tok.tok);
	if(biop_ty == -1)
	{
		return parse_value{.action := parse_action.error; .errmsg := "unrecognised binary operator";};
	}

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipbiop;
		.expr := make_biop_expr(ast_biop_expr{.type := biop_ty; .attack_precedence := ast_biop_precedence(biop_ty); .defence_precedence := ast_biop_precedence(biop_ty);});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	ast_biop_set_lhs((ret.nodes) # 0, first, global_arena);
	(ret.nodes_size) = 1;
};

wipbiop2biop ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.expr);
	ast_biop_set_rhs(firstptr, last, global_arena);

	expr ::= first.expr;
	wipbiop ::= expr.biop;
	biop_ty ::= wipbiop.type;

	// do operator precedence if lhs is also a biop
	did_operator_precedence_shift : bool mut;
	did_operator_precedence_shift = false;

	lhs ::= ast_biop_get_lhs(deref firstptr);
	rhs ::= ast_biop_get_rhs(deref firstptr);

	lhs_lhs : ast mut? mut;
	lhs_rhs : ast mut? mut;
	if((lhs->type) == (ast_type.expr))
	{
		lhs_expr ::= lhs->expr;
		if((lhs_expr.type) == (ast_expr_type.biop))
		{
			lhsbiop ::= lhs_expr.biop;
			lhs_biop_ty ::= lhsbiop.type;
			if(ast_biop_precedence(biop_ty) > (lhsbiop.defence_precedence))
			{
				// e.g multiplication has a higher precedence than addition
				// 5 + 3 * 5
				// without precedence:
				// (5 + 3) * 5
				// with precedence:
				// 5 + (3 * 5)
				// so as biop_ty > lhs_biop_ty,
				// lhs should be: lhs_lhs
				// rhs should be: biop(lhs_rhs, rhs)
				// the resultant biop should be lhs_rhs * rhs
				// the lhs of the result biop should be equal to the lhs of the lhs biop
				lhs_lhs = ast_biop_get_lhs(deref lhs);
				lhs_rhs = ast_biop_get_rhs(deref lhs);
				deref(lhs) = deref(lhs_lhs);
				rhscpy ::= deref rhs;
				deref(rhs) = ast
				{
					.type := ast_type.expr;
					.expr := make_biop_expr(ast_biop_expr{.type := biop_ty; .attack_precedence := ast_biop_precedence(biop_ty); .defence_precedence := ast_biop_precedence(biop_ty);});
					.loc := lhs_rhs->loc;
					.cursor_begin := lhs_rhs->cursor_begin;
					.cursor_end := rhs->cursor_end;
					.childcount := 0;
					.childcap := 0;
					.children := zero;
				};
				ast_biop_set_lhs(rhs, deref lhs_rhs, global_arena);
				ast_biop_set_rhs(rhs, rhscpy, global_arena);
				did_operator_precedence_shift = true;

				firstexpr ::= ref(firstptr->expr);
				firstbiop ::= ref(firstexpr->biop);
				(firstbiop->type) = lhs_biop_ty;
			}
		}
	}
	
};

symcolsym2decl ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	// var name
	first_utok ::= first.utok;
	first_tok ::= first_utok.tok;
	first_lex ::= first_tok.lexeme;

	// type name
	last_utok ::= last.utok;
	last_tok ::= last_utok.tok;
	last_lex ::= last_tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.decl;
		.decl := ast_decl
		{
			.name := src # (first_lex.off);
			.name_len := first_lex.len;
			.typename := src # (last_lex.off);
			.typename_len := last_lex.len;
			.extras := zero;
			.extras_size := 0;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

symcrap2deduceddecl ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	// var name
	first_utok ::= first.utok;
	first_tok ::= first_utok.tok;
	first_lex ::= first_tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.decl;
		.decl := ast_decl
		{
			.name := src # (first_lex.off);
			.name_len := first_lex.len;
			.typename := psyc_deduced_typename;
			.typename_len := zstrlen(psyc_deduced_typename);
			.extras := zero;
			.extras_size := 0;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

symcrap2functionptrdecl ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	// var name
	first_utok ::= first.utok;
	first_tok ::= first_utok.tok;
	first_lex ::= first_tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipdecl;
		.decl := ast_decl
		{
			.name := src # (first_lex.off);
			.name_len := first_lex.len;
			.typename := psyc_function_placeholder_typename;
			.typename_len := zstrlen(psyc_function_placeholder_typename);
			.extras := zero;
			.extras_size := 0;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipdeclwipfnred2fnptrdecl ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.fnptrdecl;
		.decl := first.decl;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	ast_add_child((ret.nodes) # 0, last, global_arena);
	(ret.nodes_size) = 1;
};

fnptrdecl_appendsymbol ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	utok ::= last.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	declptr ::= ref(firstptr->decl);
	if((declptr->extras) == zero)
	{
		off ::= src # (lex.off);
		// go back one because a proceeding symbol naturally skips a space, which we dont want to skip
		(declptr->extras) = (off # -1);
	}
	(declptr->extras_size) = ((declptr->extras_size) + (lex.len) + 1);
};

declinitfunc2wipfn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	decl ::= first.decl;
	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipfn_blue;
		.fn := ast_fn
		{
			.fn_name := decl.name;
			.fn_name_len := decl.name_len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

declinitfunc2wipasm ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	decl ::= first.decl;
	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipasm_blue;
		.asmdef := ast_asm
		{
			.asm_name := decl.name;
			.asm_name_len := decl.name_len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

keywordfuncoparen2wipfn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	decl ::= first.decl;
	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipfn_blue;
		.fn := ast_fn
		{
			.fn_name := psyc_function_placeholder_typename;
			.fn_name_len := zstrlen(psyc_function_placeholder_typename);
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipfn_givereturn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	secondlast ::= deref(nodes # (nodes_size - 2));
	utok ::= secondlast.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	(firstptr->type) = (ast_type.wipfn_red);
	fn ::= ref(firstptr->fn);
	(fn->ret_typename) = src # (lex.off);
	(fn->ret_typename_len) = (lex.len);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipasm_givereturn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	secondlast ::= deref(nodes # (nodes_size - 2));
	utok ::= secondlast.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	(firstptr->type) = (ast_type.wipasm_red);
	as ::= ref(firstptr->asmdef);
	(as->ret_typename) = src # (lex.off);
	(as->ret_typename_len) = (lex.len);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipfn2externfn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.fn);
	(firstptr->cursor_end) = (last.cursor_end);
	fn ::= ref(firstptr->fn);
	(fn->is_extern) = true;
};

wipasm2asm ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.asmdef);
	(firstptr->cursor_end) = (last.cursor_end);

	utok ::= last.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	ast_add_child(firstptr, ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.string_literal;
			.chars := src # (lex.off);
			.chars_len := lex.len;
		});
		.loc := first.loc;
		.cursor_begin := last.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	}, global_arena);
};

asmdef_append_child ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	utok ::= last.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	ast_add_child(firstptr, ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(ast_literal_expr
		{
			.type := ast_literal_type.string_literal;
			.chars := src # (lex.off);
			.chars_len := lex.len;
		});
		.loc := first.loc;
		.cursor_begin := last.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	}, global_arena);
};

wipfn_awaitimplblock ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.wipfn_green);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipmacro_givereturn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	utok ::= last.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	(firstptr->type) = (ast_type.wipmacro_red);
	mac ::= ref(firstptr->mac);
	(mac->yield_typename) = src # (lex.off);
	(mac->yield_typename_len) = (lex.len);
	(firstptr->cursor_end) = (last.cursor_end);
};


wipfn2fn ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.fn);
	(firstptr->cursor_end) = (last.cursor_end);
	fn ::= ref(firstptr->fn);
	(fn->is_extern) = false;
};

declinitmacro2wipmacro ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;

	decl ::= first.decl;
	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipmacro_blue;
		.mac := ast_macro
		{
			.mac_name := decl.name;
			.mac_name_len := decl.name_len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipmacro_awaitimplblock ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.wipmacro_green);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipmacro2macro ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.mac);
	(firstptr->cursor_end) = (last.cursor_end);
};

keywordifparen2wipif ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipif_blue);
	(firstptr->cursor_end) = (last.cursor_end);

	(firstptr->ifdef) = ast_if{.is_static := false;};
};

keywordstaticifparen2wipifstatic ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipif_blue);
	(firstptr->cursor_end) = (last.cursor_end);

	(firstptr->ifdef) = ast_if{.is_static := true;};
};

wipifcparen2wipifred ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipif_red);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipifredcbrace2if ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	
	(firstptr->type) = (ast_type.ifdef);
	(firstptr->cursor_end) = (last.cursor_end);
};

keywordwhileparen2wipwhile ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipwhile_blue);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipwhilecparen2wipwhilered ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipwhile_red);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipwhileredcbrace2while ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	
	(firstptr->type) = (ast_type.whiledef);
	(firstptr->cursor_end) = (last.cursor_end);
};

keywordforparen2wipfor ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipfor_blue);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipforbluecomma2wipforred ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipfor_red);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipforredcomma2wipforyellow ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipfor_yellow);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipforyellowcparen2wipforgreen ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.wipfor_green);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipforgreencbrace2for ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	
	(firstptr->type) = (ast_type.fordef);
	(firstptr->cursor_end) = (last.cursor_end);
};

err_else_no_preceding_if ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "Else statements must always directly proceed a previous if statement.";
	};
};

keywordelseobrace2wipelse ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	
	(firstptr->type) = (ast_type.wipelse);
	(firstptr->cursor_end) = (last.cursor_end);
};

wipelsecbrace2else ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	
	(firstptr->type) = (ast_type.elsedef);
	(firstptr->cursor_end) = (last.cursor_end);
};

ifelse2if ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	ast_add_child(firstptr, last, global_arena);
};

symoparen2wipcall ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipcall;
		.wipcall := ast_wipcall
		{
			.funcname := src # (lex.off);
			.funcname_len := lex.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipcallcparen2call ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	
	wipcall ::= first.wipcall;
	(firstptr->type) = (ast_type.expr);
	(firstptr->expr) = make_callfunc_expr(ast_callfunc_expr
	{
		.funcname := wipcall.funcname;
		.funcname_len := wipcall.funcname_len;
	});
	(firstptr->cursor_end) = (last.cursor_end);
};

declstruct2wipstruct ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	decl ::= first.decl;
	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipstruct;
		.structdef := ast_struct
		{
			.structname := decl.name;
			.structname_len := decl.name_len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

declenum2wipenum ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	decl ::= first.decl;
	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipenum;
		.enumdef := ast_enum
		{
			.enumname := decl.name;
			.enumname_len := decl.name_len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipstructcbrace2struct ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.structdef);
	(firstptr->cursor_end) = last.cursor_end;
};

wipenumcbrace2enum ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.enumdef);
	(firstptr->cursor_end) = last.cursor_end;
};

cmpsymcmp2wipregion ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	second ::= deref(nodes # 1);
	utok ::= second.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipregion;
		.region := ast_region_stmt
		{
			.name := src # (lex.off);
			.name_len := lex.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipregion2region ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.region);
	(firstptr->cursor_end) = (last.cursor_end);
};

dotsymbolinit2wipinit ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;


	second ::= deref(nodes # 1);
	utok ::= second.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	deref((ret.nodes) # 0) = ast
	{
		.type := ast_type.wipinit;
		.init := ast_init
		{
			.name := src # (lex.off);
			.name_len := lex.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := zero;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipinitexpr2init ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;

	(firstptr->type) = (ast_type.init);
	(firstptr->cursor_end) = (last.cursor_end);
	
	ast_add_child(firstptr, last, global_arena);
};

symbolobrace2wipstructinit ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;

	(firstptr->type) = (ast_type.wipstructinit);
	(firstptr->init) = ast_init
	{
		.name := src # (lex.off);
		.name_len := lex.len;
	};
	(firstptr->cursor_end) = (last.cursor_end);
};

wipstructinitcbrace2structinit ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	setup_decls();
	ret : parse_value mut := parse_value
	{
		.action := (parse_action.reduce);
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
	};
	defer return ret;


	(firstptr->type) = (ast_type.expr);
	(firstptr->expr) = ast_expr{.type := ast_expr_type.structinit;};
	(firstptr->cursor_end) = (last.cursor_end);
};

err_func_no_semicol ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "missing semicolon at the end of a function";
	};
};

err_mac_no_semicol ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "missing semicolon at the end of a macro";
	};
};

err_struct_no_semicol ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "missing semicolon at the end of a struct";
	};
};

err_enum_no_semicol ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "missing semicolon at the end of an enum";
	};
};

err_generic_no_semicol ::= func(src : u8?, nodes : ast mut?, nodes_size : u64 -> parse_value)
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "token(s) do not form a statement. did you forget a semicolon?";
	};
};

grammar_common_err_func_semicol ::= func(-> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fn)),
		zero,
		zero,
		grammar_rule{.fn := err_func_no_semicol;});
};

grammar_common_err_mac_semicol ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.mac)),
		zero,
		zero,
		grammar_rule{.fn := err_mac_no_semicol;});
};

grammar_stmtify ::= func(nod : ast, ru : grammar_rule -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, nod),
		token(lex_token.semicol),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, nod),
		zero,
		zero,
		grammar_rule{.fn := err_generic_no_semicol;});

	grammar_install(
		__arrcpy(node_arena#0, ast, nod, token(lex_token.semicol)),
		zero,
		zero,
		ru);
};

grammar_numeric_literal ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.numeric_literal)),
		zero,
		zero,
		grammar_rule{.fn := num2expr;});
};

grammar_symbol ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol)),
		zero,
		zero,
		grammar_rule{.fn := sym2expr;});
};

grammar_char_literal ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.char_literal)),
		zero,
		zero,
		grammar_rule{.fn := char2expr;});
};

grammar_string_literal ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.string_literal)),
		zero,
		zero,
		grammar_rule{.fn := str2expr;});
};

grammar_bool_literal ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_true)),
		zero,
		zero,
		grammar_rule{.fn := true2expr;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_false)),
		zero,
		zero,
		grammar_rule{.fn := false2expr;});
};

grammar_zero_literal ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_zero)),
		zero,
		zero,
		grammar_rule{.fn := zero2expr;});
};

grammar_retvoid ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_return)),
		token(lex_token.semicol),
		zero,
		grammar_rule{.fn := keywordret2retvoid;});
};

grammar_ret ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_return)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
};

grammar_ret_expr ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		token(lex_token.keyword_return),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_return), expr(exp)),
		zero,
		zero,
		grammar_rule{.fn := keywordretexpr2ret;});
};

grammar_yield ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_yield)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
};

grammar_yield_expr ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		token(lex_token.keyword_yield),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_yield), expr(exp)),
		zero,
		zero,
		grammar_rule{.fn := keywordyieldexpr2yield;});
};

grammar_parenthesised ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
};

grammar_parenthesised_expr ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		token(lex_token.oparen),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.oparen), expr(exp)),
		token(lex_token.cparen),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.oparen), expr(exp), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := parenthesise_expr;});
};

grammar_basic_decl ::= func( -> v0)
{
	// if a symbol is directly followed by a colon, its probably the start of a decl, so override before we exprify it.
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol)),
		token(lex_token.colon),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol), token(lex_token.colon)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol), token(lex_token.colon), token(lex_token.symbol)),
		zero,
		zero,
		grammar_rule{.fn := symcolsym2decl;});
};

grammar_deduced_decl ::= func( -> v0)
{
	// name ::=
	// instantly becomes a decl with deduced typename
	// that way, the grammar rules with this initialiser and the normal decl initialiser can be shared.
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol), token(lex_token.colon)),
		token(lex_token.initialiser),
		zero,
		grammar_rule{.fn := symcrap2deduceddecl;});
};

grammar_function_pointer_decl ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol), token(lex_token.colon)),
		token(lex_token.keyword_func),
		zero,
		grammar_rule{.fn := symcrap2functionptrdecl;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipdecl)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_func)),
		token(lex_token.oparen),
		node(ast_type.wipdecl),
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_func), token(lex_token.oparen)),
		zero,
		node(ast_type.wipdecl),
		grammar_rule{.fn := keywordfuncoparen2wipfn;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_red)),
		zero,
		node(ast_type.wipdecl),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipdecl), node(ast_type.wipfn_red)),
		zero,
		zero,
		grammar_rule{.fn := wipdeclwipfnred2fnptrdecl;});

	// append extras to the end
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl)),
		token(lex_token.symbol),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl), token(lex_token.symbol)),
		zero,
		zero,
		grammar_rule{.fn := fnptrdecl_appendsymbol;});
};

grammar_decl_init ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl)),
		token(lex_token.initialiser),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser)),
		zero,
		zero,
		grammar_rule{.fn := stash_head_delete_all;});

	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.decl),
		grammar_rule{.fn := commit_head;});

	// when should we unstash the decl?
	// when we see the following tokens:
	// ;
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.semicol)),
		zero,
		node(ast_type.decl),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl)),
		token(lex_token.initialiser),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl), token(lex_token.initialiser)),
		zero,
		zero,
		grammar_rule{.fn := stash_head_delete_all;});

	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.fnptrdecl),
		grammar_rule{.fn := commit_head;});

	// when should we unstash the fnptrdecl?
	// when we see the following tokens:
	// ;
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.semicol)),
		zero,
		node(ast_type.fnptrdecl),
		grammar_rule{.fn := unstash_head;});
};

grammar_unop ::= func(t : lex_token -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(t)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
};

grammar_unop_expr ::= func(tok : lex_token, exp : ast_expr_type -> v0)
{
	// note: we unstash *as soon as* we see a valid expr.
	// this means that:
	// -5 + 12 => (-5) + 12
	// and not => -(5 + 12):
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		token(tok),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(tok), expr(exp)),
		zero,
		zero,
		grammar_rule{.fn := tokenexpr2unop;});
};

grammar_biop ::= func(exp : ast_expr_type, tok : lex_token -> v0)
{
	// basic setup
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		zero,
		grammar_rule{.fn := shift1;});
	
	// make halk biop
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp), token(tok)),
		zero,
		zero,
		grammar_rule{.fn := exprtok2halfbiop;});

	// stash half biops
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipbiop)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	// unstash a half biop if an expression is ready
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipbiop),
		grammar_rule{.fn := unstash_head;});
	
	// half biop + expr => full biop
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipbiop), expr(exp)),
		zero,
		zero,
		grammar_rule{.fn := wipbiop2biop;});

	// prevent decl initialisers from eating unfinished biops
	// shift instead of committing.
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.decl),
		grammar_rule{.fn := shift1;});

	// prevent return statements from eating unfinished biops
	// shift instead of unstashing
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		token(lex_token.keyword_return),
		grammar_rule{.fn := shift1;});

	// prevent if statement conditions from eating unfinished biops
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipif_blue),
		grammar_rule{.fn := shift1;});

	// prevent while statement conditions from eating unfinished biops
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipwhile_blue),
		grammar_rule{.fn := shift1;});

	// prevent for statement parts from eating unfinished biops
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipfor_blue),
		grammar_rule{.fn := shift1;});
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipfor_red),
		grammar_rule{.fn := shift1;});
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipfor_yellow),
		grammar_rule{.fn := shift1;});

	// prevent parenthesised exprs from eating unfinished biops
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		token(lex_token.oparen),
		grammar_rule{.fn := shift1;});

	// prevent initialisers from eating unfinished biops
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipinit),
		grammar_rule{.fn := shift1;});

	// prevent wipcalls from eating unfinished biops
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		token(tok),
		node(ast_type.wipcall),
		grammar_rule{.fn := shift1;});
};

grammar_wipfn ::= func( -> v0)
{
	// decl initialiser is func(...)
	// dont let it be stashed
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(lex_token.keyword_func),
		zero,
		grammar_rule{.fn := shift2;});
	
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser), token(lex_token.keyword_func), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := declinitfunc2wipfn;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_blue)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	// push decl as new function param
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl)),
		zero,
		node(ast_type.wipfn_blue),
		grammar_rule{.fn := commit_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl)),
		token(lex_token.symbol),
		node(ast_type.wipfn_blue),
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl), token(lex_token.symbol)),
		zero,
		node(ast_type.wipfn_blue),
		grammar_rule{.fn := fnptrdecl_appendsymbol;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fnptrdecl)),
		zero,
		node(ast_type.wipfn_blue),
		grammar_rule{.fn := commit_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipfn_blue),
		grammar_rule{.fn := swallow_all;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.arrow)),
		zero,
		node(ast_type.wipfn_blue),
		grammar_rule{.fn := unstash_head;});


	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_blue), token(lex_token.arrow)),
		zero,
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_blue), token(lex_token.arrow), token(lex_token.symbol), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := wipfn_givereturn;});
};

grammar_wipasm ::= func( -> v0)
{
	// decl initialiser is asm(...)
	// dont let it be stashed
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(lex_token.keyword_asm),
		zero,
		grammar_rule{.fn := shift2;});
	
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser), token(lex_token.keyword_asm), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := declinitfunc2wipasm;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipasm_blue)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	// push decl as new function param
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl)),
		zero,
		node(ast_type.wipasm_blue),
		grammar_rule{.fn := commit_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipasm_blue),
		grammar_rule{.fn := swallow_all;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.arrow)),
		zero,
		node(ast_type.wipasm_blue),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipasm_blue), token(lex_token.arrow)),
		zero,
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipasm_blue), token(lex_token.arrow), token(lex_token.symbol), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := wipasm_givereturn;});
};

grammar_asm ::= func( -> v0)
{
	// wipfn_asm has the whole signature now, and is followed by either:
	// (1) := extern (in which we will just set the function as extern and declare it complete)

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipasm_red)),
		token(lex_token.initialiser),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipasm_red), token(lex_token.initialiser), token(lex_token.char_literal)),
		zero,
		zero,
		grammar_rule{.fn := wipasm2asm;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.asmdef)),
		token(lex_token.colon),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.asmdef), token(lex_token.colon), token(lex_token.char_literal)),
		zero,
		zero,
		grammar_rule{.fn := asmdef_append_child;});
};

grammar_fn_extern ::= func( -> v0)
{
	// wipfn_red has the whole signature now, and is followed by either:
	// (1) := extern (in which we will just set the function as extern and declare it complete)

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_red)),
		token(lex_token.initialiser),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_red), token(lex_token.initialiser), token(lex_token.keyword_extern)),
		zero,
		zero,
		grammar_rule{.fn := wipfn2externfn;});
};

grammar_fn ::= func( -> v0)
{
	// (2) a obrace (in which case we have an implemention block incoming)
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_red)),
		token(lex_token.obrace),
		zero,
		grammar_rule{.fn := shift1;});
	
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_red), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := wipfn_awaitimplblock;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_green)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipfn_green),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfn_green), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipfn2fn;});
};

grammar_wipmacro ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(lex_token.keyword_macro),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser), token(lex_token.keyword_macro), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := declinitmacro2wipmacro;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_blue)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	// push decl as new macro param
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl)),
		zero,
		node(ast_type.wipmacro_blue),
		grammar_rule{.fn := commit_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipmacro_blue),
		grammar_rule{.fn := swallow_all;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cparen)),
		token(lex_token.arrow),
		node(ast_type.wipmacro_blue),
		grammar_rule{.fn := unstash_head;});


	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_blue), token(lex_token.cparen)),
		token(lex_token.arrow),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_blue), token(lex_token.cparen), token(lex_token.arrow), token(lex_token.symbol)),
		zero,
		zero,
		grammar_rule{.fn := wipmacro_givereturn;});
};

grammar_macro ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_red)),
		token(lex_token.obrace),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_red), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := wipmacro_awaitimplblock;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_green)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipmacro_green),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipmacro_green), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipmacro2macro;});
};

grammar_if ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_static_if)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_static_if), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := keywordstaticifparen2wipifstatic;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_if)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_if), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := keywordifparen2wipif;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipif_blue)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
	
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cparen)),
		zero,
		node(ast_type.wipif_blue),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipif_blue), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipif_blue), token(lex_token.cparen), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := wipifcparen2wipifred;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipif_red)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipif_red),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipif_red), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipifredcbrace2if;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.ifdef)),
		zero,
		zero,
		grammar_rule{.fn := if2stmt;});
};

grammar_if_cond ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipif_blue),
		grammar_rule{.fn := commit_head;});
};

grammar_if_else ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.ifdef)),
		token(lex_token.keyword_else),
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_else)),
		zero,
		zero,
		grammar_rule{.fn := err_else_no_preceding_if;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_else)),
		zero,
		node(ast_type.ifdef),
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_else), token(lex_token.obrace)),
		zero,
		node(ast_type.ifdef),
		grammar_rule{.fn := keywordelseobrace2wipelse;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipelse)),
		zero,
		node(ast_type.ifdef),
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipelse),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipelse), token(lex_token.cbrace)),
		zero,
		node(ast_type.ifdef),
		grammar_rule{.fn := wipelsecbrace2else;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.elsedef)),
		zero,
		node(ast_type.ifdef),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.ifdef), node(ast_type.elsedef)),
		zero,
		zero,
		grammar_rule{.fn := ifelse2if;});
};

grammar_while ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_while)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_while), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := keywordwhileparen2wipwhile;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipwhile_blue)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
	
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cparen)),
		zero,
		node(ast_type.wipwhile_blue),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipwhile_blue), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipwhile_blue), token(lex_token.cparen), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := wipwhilecparen2wipwhilered;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipwhile_red)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipwhile_red),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipwhile_red), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipwhileredcbrace2while;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.whiledef)),
		zero,
		zero,
		grammar_rule{.fn := while2stmt;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.fordef)),
		zero,
		zero,
		grammar_rule{.fn := for2stmt;});
};

grammar_while_cond ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipwhile_blue),
		grammar_rule{.fn := commit_head;});
};

grammar_for ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_for)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_for), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := keywordforparen2wipfor;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_blue)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipfor_blue),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_blue), token(lex_token.comma)),
		zero,
		zero,
		grammar_rule{.fn := wipforbluecomma2wipforred;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_red)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipfor_red),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_red), token(lex_token.comma)),
		zero,
		zero,
		grammar_rule{.fn := wipforredcomma2wipforyellow;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_yellow)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipfor_yellow),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cparen)),
		zero,
		node(ast_type.wipfor_yellow),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_yellow), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_yellow), token(lex_token.cparen), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := wipforyellowcparen2wipforgreen;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_green)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipfor_green),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipfor_green), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipforgreencbrace2for;});
};

grammar_for_cond ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipfor_blue),
		grammar_rule{.fn := commit_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipfor_red),
		grammar_rule{.fn := commit_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipfor_yellow),
		grammar_rule{.fn := commit_head;});
};

grammar_call ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol)),
		token(lex_token.oparen),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol), token(lex_token.oparen)),
		zero,
		zero,
		grammar_rule{.fn := symoparen2wipcall;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipcall)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	// take exprs as params in grammar_call_param

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.comma)),
		zero,
		node(ast_type.wipcall),
		grammar_rule{.fn := swallow_all;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cparen)),
		zero,
		node(ast_type.wipcall),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipcall), token(lex_token.cparen)),
		zero,
		zero,
		grammar_rule{.fn := wipcallcparen2call;});
};

grammar_call_param ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipcall),
		grammar_rule{.fn := commit_head;});
};

grammar_struct ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(lex_token.keyword_struct),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser), token(lex_token.keyword_struct), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := declstruct2wipstruct;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipstruct)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		token(lex_token.semicol),
		node(ast_type.wipstruct),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipstruct),
		grammar_rule{.fn := err_struct_no_semicol;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipstruct), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipstructcbrace2struct;});
};

grammar_enum ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(lex_token.keyword_enum),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.decl), token(lex_token.initialiser), token(lex_token.keyword_enum), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := declenum2wipenum;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipenum)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		token(lex_token.semicol),
		node(ast_type.wipenum),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipenum),
		grammar_rule{.fn := err_enum_no_semicol;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipenum), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipenumcbrace2enum;});
};

grammar_build_region ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.compare)),
		zero,
		zero,
		grammar_rule{.fn := shift3;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.compare), token(lex_token.symbol), token(lex_token.compare), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := cmpsymcmp2wipregion;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipregion)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipregion),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipregion), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipregion2region;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.region)),
		zero,
		zero,
		grammar_rule{.fn := region2stmt;});

	grammar_install(
		__arrcpy(node_arena#0, ast, stmt(ast_stmt.region_stmt)),
		zero,
		zero,
		grammar_rule{.fn := commit_head;});
};

grammar_defer ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_defer)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
};

grammar_defer_stmt ::= func(s : ast_stmt -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, stmt(s)),
		zero,
		token(lex_token.keyword_defer),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.keyword_defer), stmt(s)),
		zero,
		zero,
		grammar_rule{.fn := deferstmt2unop;});
};

grammar_initialiser ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.dot)),
		token(lex_token.symbol),
		zero,
		grammar_rule{.fn := shift2;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.dot), token(lex_token.symbol), token(lex_token.initialiser)),
		zero,
		zero,
		grammar_rule{.fn := dotsymbolinit2wipinit;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipinit)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});
};

grammar_initialiser_expr ::= func(exp : ast_expr_type -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, expr(exp)),
		zero,
		node(ast_type.wipinit),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipinit), expr(exp)),
		zero,
		zero,
		grammar_rule{.fn := wipinitexpr2init;});
};

grammar_structinit ::= func( -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol)),
		token(lex_token.obrace),
		zero,
		grammar_rule{.fn := shift1;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.symbol), token(lex_token.obrace)),
		zero,
		zero,
		grammar_rule{.fn := symbolobrace2wipstructinit;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipstructinit)),
		zero,
		zero,
		grammar_rule{.fn := stash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, token(lex_token.cbrace)),
		zero,
		node(ast_type.wipstructinit),
		grammar_rule{.fn := unstash_head;});

	grammar_install(
		__arrcpy(node_arena#0, ast, node(ast_type.wipstructinit), token(lex_token.cbrace)),
		zero,
		zero,
		grammar_rule{.fn := wipstructinitcbrace2structinit;});
};

grammar_commit_stmt ::= func(s : ast_stmt -> v0)
{
	grammar_install(
		__arrcpy(node_arena#0, ast, stmt(s)),
		zero,
		zero,
		grammar_rule{.fn := commit_head;});
};

grammar_setup ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.setup);
	defer psyc_timed_end();
	parse_table_cap = 2500;
	parse_table = arena_alloc(global_arena, __sizeof(deref parse_table) * parse_table_cap);
	memfill(parse_table, 0, __sizeof(deref parse_table) * parse_table_cap);

	grammar_numeric_literal();
	grammar_symbol();
	grammar_char_literal();
	grammar_string_literal();
	grammar_bool_literal();

	grammar_zero_literal();

	grammar_retvoid();
	grammar_ret();
	grammar_ret_expr(ast_expr_type.symbol);
	grammar_ret_expr(ast_expr_type.literal);
	grammar_ret_expr(ast_expr_type.biop);
	grammar_ret_expr(ast_expr_type.unop);
	grammar_ret_expr(ast_expr_type.callfunc);
	grammar_ret_expr(ast_expr_type.structinit);

	grammar_yield();
	grammar_yield_expr(ast_expr_type.symbol);
	grammar_yield_expr(ast_expr_type.literal);
	grammar_yield_expr(ast_expr_type.biop);
	grammar_yield_expr(ast_expr_type.unop);
	grammar_yield_expr(ast_expr_type.callfunc);
	grammar_yield_expr(ast_expr_type.structinit);

	grammar_parenthesised();
	grammar_parenthesised_expr(ast_expr_type.symbol);
	grammar_parenthesised_expr(ast_expr_type.literal);
	grammar_parenthesised_expr(ast_expr_type.biop);
	grammar_parenthesised_expr(ast_expr_type.unop);
	grammar_parenthesised_expr(ast_expr_type.callfunc);
	grammar_parenthesised_expr(ast_expr_type.ret);
	grammar_parenthesised_expr(ast_expr_type.structinit);

	grammar_basic_decl();
	grammar_deduced_decl();
	grammar_function_pointer_decl();
	// note: you are going to want to add more reductions to decl_init
	// this is because they are going to break apart biops (and probably callfuncs)
	grammar_decl_init(ast_expr_type.symbol);
	grammar_decl_init(ast_expr_type.literal);
	grammar_decl_init(ast_expr_type.biop);
	grammar_decl_init(ast_expr_type.unop);
	grammar_decl_init(ast_expr_type.callfunc);
	grammar_decl_init(ast_expr_type.structinit);

	// unary operators
	grammar_unop(lex_token.dash);
	grammar_unop_expr(lex_token.dash, ast_expr_type.symbol);
	grammar_unop_expr(lex_token.dash, ast_expr_type.literal);
	grammar_unop_expr(lex_token.dash, ast_expr_type.biop);
	grammar_unop_expr(lex_token.dash, ast_expr_type.unop);
	grammar_unop_expr(lex_token.dash, ast_expr_type.callfunc);
	grammar_unop_expr(lex_token.dash, ast_expr_type.structinit);

	grammar_unop(lex_token.bitwise_invert);
	grammar_unop_expr(lex_token.bitwise_invert, ast_expr_type.symbol);
	grammar_unop_expr(lex_token.bitwise_invert, ast_expr_type.literal);
	grammar_unop_expr(lex_token.bitwise_invert, ast_expr_type.biop);
	grammar_unop_expr(lex_token.bitwise_invert, ast_expr_type.unop);
	grammar_unop_expr(lex_token.bitwise_invert, ast_expr_type.callfunc);
	grammar_unop_expr(lex_token.bitwise_invert, ast_expr_type.structinit);

	grammar_unop(lex_token.logical_invert);
	grammar_unop_expr(lex_token.logical_invert, ast_expr_type.symbol);
	grammar_unop_expr(lex_token.logical_invert, ast_expr_type.literal);
	grammar_unop_expr(lex_token.logical_invert, ast_expr_type.biop);
	grammar_unop_expr(lex_token.logical_invert, ast_expr_type.unop);
	grammar_unop_expr(lex_token.logical_invert, ast_expr_type.callfunc);
	grammar_unop_expr(lex_token.logical_invert, ast_expr_type.structinit);

	grammar_unop(lex_token.keyword_ref);
	grammar_unop_expr(lex_token.keyword_ref, ast_expr_type.symbol);
	grammar_unop_expr(lex_token.keyword_ref, ast_expr_type.literal);
	grammar_unop_expr(lex_token.keyword_ref, ast_expr_type.biop);
	grammar_unop_expr(lex_token.keyword_ref, ast_expr_type.unop);
	grammar_unop_expr(lex_token.keyword_ref, ast_expr_type.callfunc);
	grammar_unop_expr(lex_token.keyword_ref, ast_expr_type.structinit);

	grammar_unop(lex_token.keyword_deref);
	grammar_unop_expr(lex_token.keyword_deref, ast_expr_type.symbol);
	grammar_unop_expr(lex_token.keyword_deref, ast_expr_type.literal);
	grammar_unop_expr(lex_token.keyword_deref, ast_expr_type.biop);
	grammar_unop_expr(lex_token.keyword_deref, ast_expr_type.unop);
	grammar_unop_expr(lex_token.keyword_deref, ast_expr_type.callfunc);
	grammar_unop_expr(lex_token.keyword_deref, ast_expr_type.structinit);

	// binary operators
	grammar_biop(ast_expr_type.symbol, lex_token.assign);
	grammar_biop(ast_expr_type.literal, lex_token.assign);
	grammar_biop(ast_expr_type.biop, lex_token.assign);
	grammar_biop(ast_expr_type.unop, lex_token.assign);
	grammar_biop(ast_expr_type.callfunc, lex_token.assign);
	grammar_biop(ast_expr_type.structinit, lex_token.assign);

	grammar_biop(ast_expr_type.symbol, lex_token.compare);
	grammar_biop(ast_expr_type.literal, lex_token.compare);
	grammar_biop(ast_expr_type.biop, lex_token.compare);
	grammar_biop(ast_expr_type.unop, lex_token.compare);
	grammar_biop(ast_expr_type.callfunc, lex_token.compare);
	grammar_biop(ast_expr_type.structinit, lex_token.compare);

	grammar_biop(ast_expr_type.symbol, lex_token.comparen);
	grammar_biop(ast_expr_type.literal, lex_token.comparen);
	grammar_biop(ast_expr_type.biop, lex_token.comparen);
	grammar_biop(ast_expr_type.unop, lex_token.comparen);
	grammar_biop(ast_expr_type.callfunc, lex_token.comparen);
	grammar_biop(ast_expr_type.structinit, lex_token.comparen);

	grammar_biop(ast_expr_type.symbol, lex_token.oanglebrack);
	grammar_biop(ast_expr_type.literal, lex_token.oanglebrack);
	grammar_biop(ast_expr_type.biop, lex_token.oanglebrack);
	grammar_biop(ast_expr_type.unop, lex_token.oanglebrack);
	grammar_biop(ast_expr_type.callfunc, lex_token.oanglebrack);
	grammar_biop(ast_expr_type.structinit, lex_token.oanglebrack);

	grammar_biop(ast_expr_type.symbol, lex_token.loreq);
	grammar_biop(ast_expr_type.literal, lex_token.loreq);
	grammar_biop(ast_expr_type.biop, lex_token.loreq);
	grammar_biop(ast_expr_type.unop, lex_token.loreq);
	grammar_biop(ast_expr_type.callfunc, lex_token.loreq);
	grammar_biop(ast_expr_type.structinit, lex_token.loreq);

	grammar_biop(ast_expr_type.symbol, lex_token.canglebrack);
	grammar_biop(ast_expr_type.literal, lex_token.canglebrack);
	grammar_biop(ast_expr_type.biop, lex_token.canglebrack);
	grammar_biop(ast_expr_type.unop, lex_token.canglebrack);
	grammar_biop(ast_expr_type.callfunc, lex_token.canglebrack);
	grammar_biop(ast_expr_type.structinit, lex_token.canglebrack);

	grammar_biop(ast_expr_type.symbol, lex_token.goreq);
	grammar_biop(ast_expr_type.literal, lex_token.goreq);
	grammar_biop(ast_expr_type.biop, lex_token.goreq);
	grammar_biop(ast_expr_type.unop, lex_token.goreq);
	grammar_biop(ast_expr_type.callfunc, lex_token.goreq);
	grammar_biop(ast_expr_type.structinit, lex_token.goreq);

	grammar_biop(ast_expr_type.symbol, lex_token.plus);
	grammar_biop(ast_expr_type.literal, lex_token.plus);
	grammar_biop(ast_expr_type.biop, lex_token.plus);
	grammar_biop(ast_expr_type.unop, lex_token.plus);
	grammar_biop(ast_expr_type.callfunc, lex_token.plus);
	grammar_biop(ast_expr_type.structinit, lex_token.plus);

	grammar_biop(ast_expr_type.symbol, lex_token.dash);
	grammar_biop(ast_expr_type.literal, lex_token.dash);
	grammar_biop(ast_expr_type.biop, lex_token.dash);
	grammar_biop(ast_expr_type.unop, lex_token.dash);
	grammar_biop(ast_expr_type.callfunc, lex_token.dash);
	grammar_biop(ast_expr_type.structinit, lex_token.dash);

	grammar_biop(ast_expr_type.symbol, lex_token.asterisk);
	grammar_biop(ast_expr_type.literal, lex_token.asterisk);
	grammar_biop(ast_expr_type.biop, lex_token.asterisk);
	grammar_biop(ast_expr_type.unop, lex_token.asterisk);
	grammar_biop(ast_expr_type.callfunc, lex_token.asterisk);
	grammar_biop(ast_expr_type.structinit, lex_token.asterisk);

	grammar_biop(ast_expr_type.symbol, lex_token.fslash);
	grammar_biop(ast_expr_type.literal, lex_token.fslash);
	grammar_biop(ast_expr_type.biop, lex_token.fslash);
	grammar_biop(ast_expr_type.unop, lex_token.fslash);
	grammar_biop(ast_expr_type.callfunc, lex_token.fslash);
	grammar_biop(ast_expr_type.structinit, lex_token.fslash);

	grammar_biop(ast_expr_type.symbol, lex_token.bitwise_or);
	grammar_biop(ast_expr_type.literal, lex_token.bitwise_or);
	grammar_biop(ast_expr_type.biop, lex_token.bitwise_or);
	grammar_biop(ast_expr_type.unop, lex_token.bitwise_or);
	grammar_biop(ast_expr_type.callfunc, lex_token.bitwise_or);
	grammar_biop(ast_expr_type.structinit, lex_token.bitwise_or);

	grammar_biop(ast_expr_type.symbol, lex_token.logical_or);
	grammar_biop(ast_expr_type.literal, lex_token.logical_or);
	grammar_biop(ast_expr_type.biop, lex_token.logical_or);
	grammar_biop(ast_expr_type.unop, lex_token.logical_or);
	grammar_biop(ast_expr_type.callfunc, lex_token.logical_or);
	grammar_biop(ast_expr_type.structinit, lex_token.logical_or);

	grammar_biop(ast_expr_type.symbol, lex_token.bitwise_and);
	grammar_biop(ast_expr_type.literal, lex_token.bitwise_and);
	grammar_biop(ast_expr_type.biop, lex_token.bitwise_and);
	grammar_biop(ast_expr_type.unop, lex_token.bitwise_and);
	grammar_biop(ast_expr_type.callfunc, lex_token.bitwise_and);
	grammar_biop(ast_expr_type.structinit, lex_token.bitwise_and);

	grammar_biop(ast_expr_type.symbol, lex_token.logical_and);
	grammar_biop(ast_expr_type.literal, lex_token.logical_and);
	grammar_biop(ast_expr_type.biop, lex_token.logical_and);
	grammar_biop(ast_expr_type.unop, lex_token.logical_and);
	grammar_biop(ast_expr_type.callfunc, lex_token.logical_and);
	grammar_biop(ast_expr_type.structinit, lex_token.logical_and);

	grammar_biop(ast_expr_type.symbol, lex_token.bitwise_exor);
	grammar_biop(ast_expr_type.literal, lex_token.bitwise_exor);
	grammar_biop(ast_expr_type.biop, lex_token.bitwise_exor);
	grammar_biop(ast_expr_type.unop, lex_token.bitwise_exor);
	grammar_biop(ast_expr_type.callfunc, lex_token.bitwise_exor);
	grammar_biop(ast_expr_type.structinit, lex_token.bitwise_exor);

	grammar_biop(ast_expr_type.symbol, lex_token.oanglebrack2);
	grammar_biop(ast_expr_type.literal, lex_token.oanglebrack2);
	grammar_biop(ast_expr_type.biop, lex_token.oanglebrack2);
	grammar_biop(ast_expr_type.unop, lex_token.oanglebrack2);
	grammar_biop(ast_expr_type.callfunc, lex_token.oanglebrack2);
	grammar_biop(ast_expr_type.structinit, lex_token.oanglebrack2);

	grammar_biop(ast_expr_type.symbol, lex_token.canglebrack2);
	grammar_biop(ast_expr_type.literal, lex_token.canglebrack2);
	grammar_biop(ast_expr_type.biop, lex_token.canglebrack2);
	grammar_biop(ast_expr_type.unop, lex_token.canglebrack2);
	grammar_biop(ast_expr_type.callfunc, lex_token.canglebrack2);
	grammar_biop(ast_expr_type.structinit, lex_token.canglebrack2);

	grammar_biop(ast_expr_type.symbol, lex_token.modulo);
	grammar_biop(ast_expr_type.literal, lex_token.modulo);
	grammar_biop(ast_expr_type.biop, lex_token.modulo);
	grammar_biop(ast_expr_type.unop, lex_token.modulo);
	grammar_biop(ast_expr_type.callfunc, lex_token.modulo);
	grammar_biop(ast_expr_type.structinit, lex_token.modulo);

	grammar_biop(ast_expr_type.symbol, lex_token.keyword_at);
	grammar_biop(ast_expr_type.literal, lex_token.keyword_at);
	grammar_biop(ast_expr_type.biop, lex_token.keyword_at);
	grammar_biop(ast_expr_type.unop, lex_token.keyword_at);
	grammar_biop(ast_expr_type.callfunc, lex_token.keyword_at);
	grammar_biop(ast_expr_type.structinit, lex_token.keyword_at);

	grammar_biop(ast_expr_type.symbol, lex_token.cast);
	grammar_biop(ast_expr_type.literal, lex_token.cast);
	grammar_biop(ast_expr_type.biop, lex_token.cast);
	grammar_biop(ast_expr_type.unop, lex_token.cast);
	grammar_biop(ast_expr_type.callfunc, lex_token.cast);
	grammar_biop(ast_expr_type.structinit, lex_token.cast);

	grammar_biop(ast_expr_type.symbol, lex_token.dot);
	grammar_biop(ast_expr_type.literal, lex_token.dot);
	grammar_biop(ast_expr_type.biop, lex_token.dot);
	grammar_biop(ast_expr_type.unop, lex_token.dot);
	grammar_biop(ast_expr_type.callfunc, lex_token.dot);
	grammar_biop(ast_expr_type.structinit, lex_token.dot);

	grammar_biop(ast_expr_type.symbol, lex_token.arrow);
	grammar_biop(ast_expr_type.literal, lex_token.arrow);
	grammar_biop(ast_expr_type.biop, lex_token.arrow);
	grammar_biop(ast_expr_type.unop, lex_token.arrow);
	grammar_biop(ast_expr_type.callfunc, lex_token.arrow);
	grammar_biop(ast_expr_type.structinit, lex_token.arrow);

	// functions
	grammar_wipfn();
	grammar_fn_extern();
	grammar_fn();

	// macros
	grammar_wipmacro();
	grammar_macro();

	// asm
	grammar_wipasm();
	grammar_asm();

	grammar_if();
	grammar_if_cond(ast_expr_type.symbol);
	grammar_if_cond(ast_expr_type.literal);
	grammar_if_cond(ast_expr_type.biop);
	grammar_if_cond(ast_expr_type.unop);
	grammar_if_cond(ast_expr_type.callfunc);
	grammar_if_cond(ast_expr_type.structinit);

	grammar_if_else();

	grammar_while();
	grammar_while_cond(ast_expr_type.symbol);
	grammar_while_cond(ast_expr_type.literal);
	grammar_while_cond(ast_expr_type.biop);
	grammar_while_cond(ast_expr_type.unop);
	grammar_while_cond(ast_expr_type.callfunc);
	grammar_while_cond(ast_expr_type.structinit);

	grammar_for();
	grammar_for_cond(ast_expr_type.symbol);
	grammar_for_cond(ast_expr_type.literal);
	grammar_for_cond(ast_expr_type.biop);
	grammar_for_cond(ast_expr_type.unop);
	grammar_for_cond(ast_expr_type.callfunc);
	grammar_for_cond(ast_expr_type.structinit);

	// callfuncs
	grammar_call();
	grammar_call_param(ast_expr_type.symbol);
	grammar_call_param(ast_expr_type.literal);
	grammar_call_param(ast_expr_type.biop);
	grammar_call_param(ast_expr_type.unop);
	grammar_call_param(ast_expr_type.callfunc);
	grammar_call_param(ast_expr_type.structinit);

	// structs
	grammar_struct();
	grammar_enum();

	// make stmts (largest building blocks in program)
	grammar_stmtify(expr(ast_expr_type.symbol), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(expr(ast_expr_type.literal), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(expr(ast_expr_type.biop), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(expr(ast_expr_type.unop), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(expr(ast_expr_type.callfunc), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(expr(ast_expr_type.ret), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(expr(ast_expr_type.yld), grammar_rule{.fn := expr2stmt;});
	grammar_stmtify(node(ast_type.decl), grammar_rule{.fn := decl2stmt;});
	grammar_stmtify(node(ast_type.fnptrdecl), grammar_rule{.fn := decl2stmt;});
	grammar_stmtify(node(ast_type.fn), grammar_rule{.fn := fn2stmt;});
	grammar_stmtify(node(ast_type.asmdef), grammar_rule{.fn := asm2stmt;});
	grammar_stmtify(node(ast_type.mac), grammar_rule{.fn := mac2stmt;});
	grammar_stmtify(node(ast_type.structdef), grammar_rule{.fn := struct2stmt;});
	grammar_stmtify(node(ast_type.enumdef), grammar_rule{.fn := enum2stmt;});
	grammar_stmtify(node(ast_type.init), grammar_rule{.fn := init2stmt;});

	// build regions
	grammar_build_region();

	// defer
	grammar_defer();
	grammar_defer_stmt(ast_stmt.expr_stmt);

	grammar_initialiser();
	grammar_initialiser_expr(ast_expr_type.symbol);
	grammar_initialiser_expr(ast_expr_type.literal);
	grammar_initialiser_expr(ast_expr_type.biop);
	grammar_initialiser_expr(ast_expr_type.unop);
	grammar_initialiser_expr(ast_expr_type.callfunc);
	grammar_initialiser_expr(ast_expr_type.ret);
	grammar_initialiser_expr(ast_expr_type.structinit);

	grammar_structinit();

	// commit all the statements to the final result (or a stashed node)
	grammar_commit_stmt(ast_stmt.expr_stmt);
	grammar_commit_stmt(ast_stmt.decl_stmt);
	grammar_commit_stmt(ast_stmt.region_stmt);
	grammar_commit_stmt(ast_stmt.struct_stmt);
	grammar_commit_stmt(ast_stmt.enum_stmt);
	grammar_commit_stmt(ast_stmt.fn_stmt);
	grammar_commit_stmt(ast_stmt.asm_stmt);
	grammar_commit_stmt(ast_stmt.mac_stmt);
	grammar_commit_stmt(ast_stmt.if_stmt);
	grammar_commit_stmt(ast_stmt.while_stmt);
	grammar_commit_stmt(ast_stmt.for_stmt);
	grammar_commit_stmt(ast_stmt.init_stmt);
	grammar_commit_stmt(ast_stmt.structinit_stmt);

	grammar_common_err_func_semicol();
	grammar_common_err_mac_semicol();
};

== build ==
{
	add_source_file("stdlib/hash.psy");

	add_source_file("ast.psy");
	add_source_file("type.psy");
}
