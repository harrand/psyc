ar : arena mut& mut;

hashnode ::= func(t : ast_type) -> u64
{
	return hash(t);
};

hashtoken ::= func(t : lex_token) -> u64
{
	multiplier ::= (ast_type.unparsed_token)@s64 * 54948375;
	return multiplier ^ hash(t);
};

hashexpr ::= func(t : ast_expr_type) -> u64
{
	multiplier ::= (ast_type.expr)@s64 * 54948375;
	return multiplier ^ hash(t);
};

hashstmt ::= func(t : ast_stmt_type) -> u64
{
	multiplier ::= (ast_type.stmt)@s64 * 54948375;
	return multiplier ^ hash(t);
};

hash_state ::= func(nodes : ast&, node_count : u64) -> u64
{
	i : u64 mut;
	hash : u64 mut := zero;
	for(i = 0, i < node_count, i = i + 1)
	{
		curnode ::= deref (nodes at i);
		istoken ::= (curnode.type) == (ast_type.unparsed_token);
		isexpr ::= (curnode.type) == (ast_type.expr);
		isstmt ::= (curnode.type) == (ast_type.stmt);
		if(istoken)
		{
			utok ::= curnode.utok;
			tokdata ::= utok.tok;
			hash = (hash ^ hashtoken(tokdata.tok));
		}
		if(isexpr)
		{
			expr ::= curnode.expr;
			hash = (hash ^ hashexpr(expr.type));
		}
		if(isstmt)
		{
			stmt ::= curnode.stmt;
			hash = (hash ^ hashstmt(stmt.type));
		}
		if(!istoken)
		{
			if(!isexpr)
			{
				if(!isstmt)
				{
					hash = (hash ^ hashnode(curnode.type));
				}
			}
		}
		hash = hash * 34875947865;
	}
	return hash;
};

parse_action ::= enum
{
	.invalid := 0;
	.reduce := 1;
	.recurse := 2;
	.shift := 3;
	.commit := 4;
	.error := 5;
};

parse_value ::= struct
{
	action : parse_action;
	offset : u64;
	len : u64;
	errmsg : u8&;
	nodes : ast mut#16;
	nodes_size : u64;
};
grammar_rule ::= struct
{
	fn : func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value;
};

default_rule ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "default rule invoked";
	};
};

[[private]]
parse_table : grammar_rule mut& mut;
[[private]]
parse_table_size : u64 mut;
[[private]]
parse_table_cap : u64 mut;

zero_lookahead ::= zero@ast;

grammar_install ::= macro(nodes : auto, lookahead_node : ast, allow_begin_state : bool, rule : grammar_rule) -> v0
{
	[[__force_mutable]] nodearr ::= nodes;
	[[__force_mutable]] hash : u64 mut := hash_state(nodearr at 0, __arrlen(nodes));
	[[__force_mutable]] la ::= lookahead_node;
	[[__force_mutable]] la_hash : u64 mut := zero;
	if((la.type) != (ast_type.unknown))
	{
		la_hash = (!hash_state(ref la, 1));
		hash = (hash ^ la_hash);
	}
	if(allow_begin_state)
	{
		hash = !hash;
	}
	puts("(size = ");
	putuint(__arrlen(nodes));
	puts(", ptr = ");
	putuint((nodearr at 0)@u64);
	puts(") ");
	puts("in hash = ");
	putuint(hash);
	if((la.type) != (ast_type.unknown))
	{
		puts(" (incl. lookahead)");
	}
	if(allow_begin_state)
	{
		puts(" (allow_begin_state)");
	}
	putchar(10);
	[[__force_mutable]] ptr ::= parse_table at (hash % parse_table_cap);
	if(ptr->fn == default_rule)
	{
		psyc_panic(srcloc_current(), "hash collision detected");
	}
	deref(ptr) = rule;
};

token ::= macro(t : lex_token) -> ast static
{
	yield ast
	{
		.type := ast_type.unparsed_token;
		.utok := ast_unparsed_token
		{
			.tok := token_data
			{
				.tok := t;
			};
		};
	};
};

node ::= macro(t : ast_type) -> ast static
{
	yield ast
	{
		.type := t;
	};
};

expr ::= macro(t : ast_expr_type) -> ast static
{
	yield ast
	{
		.type := ast_type.expr;
		.expr := ast_expr{.type := t;};
	};
};

stmt ::= macro(t : ast_stmt_type) -> ast static
{
	yield ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt{.type := t;};
	};
};

rule ::= macro(f : auto) -> grammar_rule
{
	yield grammar_rule{.fn := f;};
};

grammar_get_rule ::= func(hash : u64) -> grammar_rule
{
	idx ::= hash % parse_table_cap;
	// todo: open addressing.
	return deref(parse_table at idx);
};

s1 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.shift;};
};

c1 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.commit;
		.offset := 0;
		.len := 1;
	};
};

r1 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	puts("RECURSE 1");
	putchar(10);
	return parse_value{.action := parse_action.recurse; .offset := 1;};
};

r2 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	puts("RECURSE 2");
	putchar(10);
	return parse_value{.action := parse_action.recurse; .offset := 2;};
};

reduce_setup ::= macro(action : parse_action) -> v0
{
	first ::= deref(nodes at 0);
	last ::= deref(nodes at (nodes_size - 1));

	ret : parse_value mut := parse_value
	{
		.action := action;
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
	};
	defer return ret;
};

numlit2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// numeric_literal ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	literal ::= interpret_numeric_literal(source, tok.lexeme);
	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(literal);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

symbol2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// symbol ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;
	symbol ::= ast_symbol_expr
	{
		.symbol := source at (lex.off);
		.len := lex.len;
	};

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_symbol_expr(symbol);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

charlit2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// char_literal ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;
	literal ::= ast_literal_expr
	{
		.type := ast_literal_type.char_literal;
		.chars := source at (lex.off);
		.chars_len := lex.len;
	};

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(literal);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

strlit2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// string_literal ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;
	literal ::= ast_literal_expr
	{
		.type := ast_literal_type.string_literal;
		.chars := source at (lex.off);
		.chars_len := lex.len;
	};

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(literal);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

exprsemicol2stmt ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "fooey");
	}

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt
		{
			.type := ast_stmt_type.expr_stmt;
			.expr := first.expr;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

declsemicol2stmt ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.decl))
	{
		psyc_panic(srcloc_current(), "fooey");
	}

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt
		{
			.type := ast_stmt_type.decl_stmt;
			.decl := first.decl;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

basic_decl ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	first_expr ::= first.expr;
	first_symbol ::= first_expr.symbol;

	last_expr ::= last.expr;
	last_symbol ::= last_expr.symbol;

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.decl;
		.decl := ast_decl
		{
			.name := first_symbol.symbol;
			.name_len := first_symbol.len;
			.typename := last_symbol.symbol;
			.typename_len := last_symbol.len;
			.init := zero;
			.has_init := false;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

give_decl_an_initialiser ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);
	if((first.type) != (ast_type.decl))
	{
		psyc_panic(srcloc_current(), "first parameter of give_decl_an_initialiser expects a decl");
	}
	if((last.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "last parameter of give_decl_an_initialiser expects an expr");
	}

	firstdecl : ast_decl mut := first.decl;
	if(firstdecl.has_init)
	{
		return parse_value
		{
			.action := parse_action.error;
			.errmsg := "decl already had an initialiser";
		};
	}
	(firstdecl.has_init) = true;
	(firstdecl.init) = (last.expr);

	deref((ret.nodes) at 0) = ast
	{
		.type := first.type;
		.decl := firstdecl;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
	};
	(ret.nodes_size) = 1;
};

[[private]]
grammar_exprification ::= func() -> v0
{
	grammar_install(
		__array(ast, token(lex_token.numeric_literal)),
		zero_lookahead,
		false,
	rule(numlit2expr));
	grammar_install(
		__array(ast, token(lex_token.numeric_literal)),
		zero_lookahead,
		true,
	rule(numlit2expr));

	grammar_install(
		__array(ast, token(lex_token.symbol)),
		zero_lookahead,
		false,
	rule(symbol2expr));
	grammar_install(
		__array(ast, token(lex_token.symbol)),
		zero_lookahead,
		true,
	rule(symbol2expr));

	grammar_install(
		__array(ast, token(lex_token.char_literal)),
		zero_lookahead,
		false,
	rule(charlit2expr));
	grammar_install(
		__array(ast, token(lex_token.char_literal)),
		zero_lookahead,
		true,
	rule(charlit2expr));

	grammar_install(
		__array(ast, token(lex_token.string_literal)),
		zero_lookahead,
		false,
	rule(strlit2expr));
	grammar_install(
		__array(ast, token(lex_token.string_literal)),
		zero_lookahead,
		true,
	rule(strlit2expr));
};

[[private]]
grammar_stmtification ::= func() -> v0
{
	// note: this should support *all expr types*
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.semicol),
		true,
	rule(s1));

	// expr stmtification
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	// decl stmtification
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(declsemicol2stmt));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(declsemicol2stmt));
};

[[private]]
grammar_commits ::= func() -> v0
{
	// note: this should support *all stmt types*
	grammar_install(
		__array(ast, stmt(ast_stmt_type.expr_stmt)),
		zero_lookahead,
		true,
	rule(c1));

	grammar_install(
		__array(ast, stmt(ast_stmt_type.decl_stmt)),
		zero_lookahead,
		true,
	rule(c1));
};

[[private]]
grammar_decls ::= func() -> v0
{
	// expr(symbol) lookahead colon
	// shift to expr(symbol) colon
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.colon),
		false,
		rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.colon),
		true,
		rule(s1));

	// expr(symbol) colon
	// recurse twice (so offsetted nodes are now zero which causes an implicit shift)
	// this means the offsetted node state is *just* whatever was our lookahead before
	// long-story-short: recurse twice and start parsing whatever's next.
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon)),
		zero_lookahead,
		true,
		rule(r2));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon)),
		zero_lookahead,
		false,
		rule(r2));

	// expr(symbol) colon expr(symbol)
	// this is the most basic form of decl the language supports. e.g myvar : u64
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(basic_decl));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(basic_decl));

	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.initialiser),
		true,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.initialiser),
		false,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser)),
		zero_lookahead,
		true,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser)),
		zero_lookahead,
		false,
		rule(r2));

	// do this for *all expr types*
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(give_decl_an_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(give_decl_an_initialiser));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(give_decl_an_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(give_decl_an_initialiser));
};

grammar_setup ::= func(a : arena mut&) -> v0
{
	ar = a;
	parse_table_cap = 16384;
	parse_table = arena_push(a, __sizeof(deref parse_table) * parse_table_cap);
	__memset(parse_table, 0, __sizeof(deref parse_table) * parse_table_cap);

	grammar_exprification();
	grammar_stmtification();
	grammar_commits();
	grammar_decls();
};

== build ==
{
	add_source_file("ast.psy");
	add_source_file("hash.psy");
}
