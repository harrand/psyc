ar : arena mut& mut;

hashnode ::= func(t : ast_type) -> u64
{
	v ::= (t@s64) * 1093;
	return hash(v);
};

hashtoken ::= func(t : lex_token) -> u64
{
	multiplier ::= (ast_type.unparsed_token)@s64 * 866820901;
	return multiplier ^ hash(t);
};

hashexpr ::= func(t : ast_expr_type) -> u64
{
	multiplier ::= (ast_type.expr)@s64 * 190299117;
	return multiplier ^ hash(t);
};

hashstmt ::= func(t : ast_stmt) -> u64
{
	multiplier ::= (ast_type.stmt)@s64 * 393505272299;
	return multiplier ^ hash(t);
};

hash_state ::= func(nodes : ast&, node_count : u64) -> u64
{
	i : u64 mut;
	hash : u64 mut := zero;
	for(i = 0, i < node_count, i = i + 1)
	{
		curnode ::= deref (nodes at i);
		istoken ::= (curnode.type) == (ast_type.unparsed_token);
		isexpr ::= (curnode.type) == (ast_type.expr);
		isstmt ::= (curnode.type) == (ast_type.stmt);
		if(istoken)
		{
			utok ::= curnode.utok;
			tokdata ::= utok.tok;
			hash = (hash ^ hashtoken(tokdata.tok));
		}
		if(isexpr)
		{
			expr ::= curnode.expr;
			hash = (hash ^ hashexpr(expr.type));
		}
		if(isstmt)
		{
			hash = (hash ^ hashstmt(curnode.stmt));
		}
		if(!istoken)
		{
			if(!isexpr)
			{
				if(!isstmt)
				{
					hash = (hash ^ hashnode(curnode.type));
				}
			}
		}
		hash = hash * 34875947865;
	}
	return hash;
};

parse_action ::= enum
{
	.invalid := 0;
	.reduce := 1;
	.recurse := 2;
	.shift := 3;
	.commit := 4;
	.error := 5;
};

parse_value ::= struct
{
	action : parse_action;
	offset : u64;
	len : u64;
	errmsg : u8&;
	nodes : ast mut#16;
	nodes_size : u64;

	push : bool;
	pop : bool;
};
grammar_rule ::= struct
{
	fn : func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value;
};

default_rule ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "default rule invoked";
		.push := false;
		.pop := false;
	};
};

[[private]]
parse_table : grammar_rule mut& mut;
[[private]]
parse_table_size : u64 mut;
[[private]]
parse_table_cap : u64 mut;

zero_lookahead ::= zero@ast;

grammar_install ::= macro(nodes : auto, lookahead_node : ast, allow_begin_state : bool, rule : grammar_rule) -> v0
{
	[[__force_mutable]] nodearr ::= nodes;
	[[__force_mutable]] hash : u64 mut := hash_state(nodearr at 0, __arrlen(nodes));
	[[__force_mutable]] la ::= lookahead_node;
	[[__force_mutable]] la_hash : u64 mut := zero;
	if((la.type) != (ast_type.unknown))
	{
		la_hash = (!hash_state(ref la, 1));
		hash = (hash ^ la_hash);
	}
	if(allow_begin_state)
	{
		hash = !hash;
	}
	/*
	puts("(size = ");
	putuint(__arrlen(nodes));
	puts(", ptr = ");
	putuint((nodearr at 0)@u64);
	puts(") ");
	puts("in hash = ");
	putuint(hash);
	if((la.type) != (ast_type.unknown))
	{
		puts(" (incl. lookahead)");
	}
	if(allow_begin_state)
	{
		puts(" (allow_begin_state)");
	}
	putchar(10);
	*/
	[[__force_mutable]] ptr ::= parse_table at (hash % parse_table_cap);
	if(ptr->fn != zero)
	{
		psyc_panic(srcloc_current(), "hash collision detected");
	}
	deref(ptr) = rule;
};

token ::= macro(t : lex_token) -> ast static
{
	yield ast
	{
		.type := ast_type.unparsed_token;
		.utok := ast_unparsed_token
		{
			.tok := token_data
			{
				.tok := t;
			};
		};
	};
};

node ::= macro(t : ast_type) -> ast static
{
	yield ast
	{
		.type := t;
	};
};

expr ::= macro(t : ast_expr_type) -> ast static
{
	yield ast
	{
		.type := ast_type.expr;
		.expr := ast_expr{.type := t;};
	};
};

stmt ::= macro(t : ast_stmt) -> ast static
{
	yield ast
	{
		.type := ast_type.stmt;
		.stmt := t;
	};
};

rule ::= macro(f : auto) -> grammar_rule
{
	yield grammar_rule{.fn := f;};
};

grammar_get_rule ::= func(hash : u64) -> grammar_rule
{
	idx ::= hash % parse_table_cap;
	// todo: open addressing.
	return deref(parse_table at idx);
};

s1 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.shift; .len := 1; .push := false; .pop := false;};
};

s2 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.shift; .len := 2; .push := false; .pop := false;};
};

s3 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.shift; .len := 3; .push := false; .pop := false;};
};

c1 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.commit;
		.offset := 0;
		.len := 1;
		.push := false;
		.pop := false;
	};
};

r1 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.recurse; .offset := 1; .push := false; .pop := false;};
};

r2 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.recurse; .offset := 2; .push := false; .pop := false;};
};

r3 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.recurse; .offset := 3; .push := false; .pop := false;};
};

r4 ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.recurse; .offset := 4; .push := false; .pop := false;};
};

err_too_much_nested_callfuncs ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value{.action := parse_action.error; .errmsg := "Detected nested callfuncs of more than 2 - this is illegal. Factor out into a temporary please."; .push := false; .pop := false;};
};

reduce_setup ::= macro(action : parse_action) -> v0
{
	first ::= deref(nodes at 0);
	last ::= deref(nodes at (nodes_size - 1));

	ret : parse_value mut := parse_value
	{
		.action := action;
		.offset := 0;
		.len := nodes_size;
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
	defer return ret;
};

parenthesised_expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// ( expr(any) )
	// just want the parens gone
	reduce_setup(parse_action.reduce);
	second ::= deref(nodes at 1);
	deref((ret.nodes) at 0) = second;
	(ret.nodes_size) = 1;
};

numlit2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// numeric_literal ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	literal ::= interpret_numeric_literal(source, tok.lexeme);
	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(literal);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

symbol2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// symbol ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;
	symbol ::= ast_symbol_expr
	{
		.symbol := source at (lex.off);
		.len := lex.len;
	};

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_symbol_expr(symbol);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

charlit2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// char_literal ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;
	literal ::= ast_literal_expr
	{
		.type := ast_literal_type.char_literal;
		.chars := source at (lex.off);
		.chars_len := lex.len;
	};

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(literal);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

strlit2expr ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// string_literal ; => literal expression statement.
	reduce_setup(parse_action.reduce);

	utok ::= first.utok;
	tok ::= utok.tok;
	lex ::= tok.lexeme;
	literal ::= ast_literal_expr
	{
		.type := ast_literal_type.string_literal;
		.chars := source at (lex.off);
		.chars_len := lex.len;
	};

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_literal_expr(literal);
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

exprsemicol2stmt ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "fooey");
	}

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt.expr_stmt;
		.expr := first.expr;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := first.children;
		.childcap := first.childcap;
		.childcount := first.childcount;
	};
	(ret.nodes_size) = 1;
};

declsemicol2stmt ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.decl))
	{
		psyc_panic(srcloc_current(), "fooey");
	}

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt.decl_stmt;
		.decl := first.decl;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := first.children;
		.childcap := first.childcap;
		.childcount := first.childcount;
	};
	(ret.nodes_size) = 1;
};

fnsemicol2stmt ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.fn))
	{
		psyc_panic(srcloc_current(), "fooey");
	}

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt.fn_stmt;
		.fn := first.fn;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := first.children;
		.childcap := first.childcap;
		.childcount := first.childcount;
	};
	(ret.nodes_size) = 1;
};

structdefsemicol2stmt ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.structdef))
	{
		psyc_panic(srcloc_current(), "shooey");
	}

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.stmt;
		.stmt := ast_stmt.struct_stmt;
		.structdef := first.structdef;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := first.children;
		.childcap := first.childcap;
		.childcount := first.childcount;
	};
	(ret.nodes_size) = 1;
};

basic_decl ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	first_expr ::= first.expr;
	first_symbol ::= first_expr.symbol;

	last_expr ::= last.expr;
	last_symbol ::= last_expr.symbol;

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.decl;
		.decl := ast_decl
		{
			.name := first_symbol.symbol;
			.name_len := first_symbol.len;
			.typename := last_symbol.symbol;
			.typename_len := last_symbol.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

type_deduced_decl ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	first_expr ::= first.expr;
	first_symbol ::= first_expr.symbol;

	last_expr ::= last.expr;
	last_symbol ::= last_expr.symbol;

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.decl;
		.decl := ast_decl
		{
			.name := first_symbol.symbol;
			.name_len := first_symbol.len;
			.typename := psyc_deduced_typename;
			.typename_len := cstrlen(psyc_deduced_typename);
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := first.children;
		.childcap := first.childcap;
		.childcount := first.childcount;
	};
	ast_add_child((ret.nodes) at 0, last, ar);
	(ret.nodes_size) = 1;
};

give_decl_an_initialiser ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	declnode ::= nodes at 0;
	has_init ::= ((declnode->childcount) >= 1);
	if(has_init)
	{
		return parse_value
		{
			.action := parse_action.error;
			.errmsg := "decl already had an initialiser";
			.push := false;
			.pop := false;
		};
	}
	ast_add_child(declnode, deref(nodes at (nodes_size - 1)), ar);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

get_unop_type_from_token ::= func(t : lex_token) -> ast_unop_type
{
	if(t == (lex_token.dash))
	{
		return ast_unop_type.minus;
	}
	if(t == (lex_token.keyword_ref))
	{
		return ast_unop_type.op_ref;
	}
	if(t == (lex_token.keyword_deref))
	{
		return ast_unop_type.op_deref;
	}
	if(t == (lex_token.keyword_defer))
	{
		return ast_unop_type.op_defer;
	}
	return -1@ast_unop_type;
};

get_biop_type_from_token ::= func(t : lex_token) -> ast_biop_type
{
	if(t == (lex_token.assign))
	{
		return ast_biop_type.assign;
	}
	if(t == (lex_token.plus))
	{
		return ast_biop_type.plus;
	}
	if(t == (lex_token.dash))
	{
		return ast_biop_type.minus;
	}
	if(t == (lex_token.asterisk))
	{
		return ast_biop_type.multiply;
	}
	if(t == (lex_token.fslash))
	{
		return ast_biop_type.divide;
	}
	if(t == (lex_token.keyword_at))
	{
		return ast_biop_type.operator_at;
	}
	return -1@ast_biop_type;
};

create_biop ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);
	if((first.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "first parameter of create_biop expects an expr");
	}
	if((last.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "last parameter of create_biop expects an expr");
	}

	opnode ::= deref(nodes at 1);
	if((opnode.type) != (ast_type.unparsed_token))
	{
		psyc_panic(srcloc_current(), "2nd parameter of create_biop expects an unparsed token (representing the biop type)");
	}
	utok ::= opnode.utok;
	tok ::= utok.tok;

	biop_ty ::= get_biop_type_from_token(tok.tok);
	invalid_biop ::= -1@ast_biop_type;
	if(biop_ty == invalid_biop)
	{
		return parse_value
		{
			.action := parse_action.error;
			.errmsg := "unrecognised binary operator operand";
			.push := false;
			.pop := false;
		};
	}

	biop ::= make_biop_expr(ast_biop_expr
	{
		.type := biop_ty;
	});

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := biop;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	ast_biop_set_lhs((ret.nodes) at 0, first, ar);
	ast_biop_set_rhs((ret.nodes) at 0, last, ar);
	(ret.nodes_size) = 1;
};

create_unop ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);
	if((last.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "last parameter of create_unop expects an expr");
	}

	opnode ::= deref(nodes at 0);
	if((opnode.type) != (ast_type.unparsed_token))
	{
		psyc_panic(srcloc_current(), "1st parameter of create_unop expects an unparsed token (representing the unop type)");
	}
	utok ::= opnode.utok;
	tok ::= utok.tok;

	unop_ty ::= get_unop_type_from_token(tok.tok);
	invalid_unop ::= -1@ast_unop_type;
	if(unop_ty == invalid_unop)
	{
		return parse_value
		{
			.action := parse_action.error;
			.errmsg := "unrecognised unary operator operand";
			.push := false;
			.pop := false;
		};
	}

	unop ::= make_unop_expr(ast_unop_expr
	{
		.type := unop_ty;
	});

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := unop;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	ast_unop_set_operand((ret.nodes) at 0, last, ar);
	(ret.nodes_size) = 1;
};

create_empty_callfunc ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	first_expr ::= first.expr;
	first_symbol ::= first_expr.symbol;

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_callfunc_expr(ast_callfunc_expr{.funcname := first_symbol.symbol; .funcname_len := first_symbol.len;});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	// no params = no children
	(ret.nodes_size) = 1;
};

biopify_decl_initialiser ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	if((first.type) != (ast_type.decl))
	{
		psyc_panic(srcloc_current(), "first parameter of biopify_decl_initialiser expects a decl");
	}
	if((last.type) != (ast_type.expr))
	{
		psyc_panic(srcloc_current(), "last parameter of biopify_decl_initialiser expects an expr");
	}

	second_last ::= deref(nodes at (nodes_size - 2));

	utok ::= second_last.utok;
	tok ::= utok.tok;

	biop_ty ::= get_biop_type_from_token(tok.tok);
	invalid_biop ::= -1@ast_biop_type;
	if(biop_ty == invalid_biop)
	{
		return parse_value
		{
			.action := parse_action.error;
			.errmsg := "unrecognised binary operator operand";
			.push := false;
			.pop := false;
		};
	}
	
	decl : ast_decl mut := first.decl;
	// first is our decl with an initialiser
	// 1. make a new ast node for that initialiser. that is our biop lhs
	if((first.childcount) == 0)
	{
		psyc_panic(srcloc_current(), "cannot biopify a decl initialiser because the decl seemingly didnt have an initialiser");
	}
	lhs_node ::= deref(ast_get_child(nodes at 0, 0));

	// 2. last is a new expr representing the biop rhs.
	rhs_expr ::= last.expr;
	rhs_node ::= ast
	{
		.type := ast_type.expr;
		.expr := rhs_expr;
		.loc := last.loc;
		.cursor_begin := last.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := last.children;
		.childcap := last.childcap;
		.childcount := last.childcount;
	};
	// make a new node representing the biop
	biop_node : ast mut := ast
	{
		.type := ast_type.expr;
		.expr := make_biop_expr(ast_biop_expr{.type := biop_ty;});
		.loc := lhs_node.loc;
		.cursor_begin := lhs_node.cursor_begin;
		.cursor_end := rhs_node.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	ast_biop_set_lhs(ref biop_node, lhs_node, ar);
	ast_biop_set_rhs(ref biop_node, rhs_node, ar);
	// make first.decl.init a biop where 1 is lhs and 2 is rhs

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.decl;
		.decl := decl;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	ast_add_child((ret.nodes) at 0, biop_node, ar);
	(ret.nodes_size) = 1;
};

create_empty_wipfn ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);

	// first node is an symbol expression
	fe ::= first.expr;
	sym ::= fe.symbol;

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.wipfn_blue;
		.loc := first.loc;
		.wipfn := ast_wipfn
		{
			.fn_name := sym.symbol;
			.fn_name_len := sym.len;
		};
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

make_wipcall ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// expect a symbol(
	// create a wipcall with no parameters.
	reduce_setup(parse_action.reduce);
	first_expr ::= first.expr;
	first_symbol ::= first_expr.symbol;

	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.wipcall_black;
		.wipcall := ast_wipcall
		{
			.funcname := first_symbol.symbol;
			.funcname_len := first_symbol.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

wipcall_add_another_arg_white ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// we already have a wipcall
	// last is some expression
	// literally just add it as a child and delete non-first nodes
	firstptr ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	ast_add_child(firstptr, last, ar);
	(firstptr->cursor_end) = (last.cursor_end);
	(firstptr->type) = (ast_type.wipcall_white);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
	};
};

wipcall_add_another_arg_black ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// we already have a wipcall
	// last is some expression
	// literally just add it as a child and delete non-first nodes
	firstptr ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	ast_add_child(firstptr, last, ar);
	(firstptr->cursor_end) = (last.cursor_end);
	(firstptr->type) = (ast_type.wipcall_black);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
	};
};

cap_off_wipcall ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);
	wipcall ::= first.wipcall;
	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.expr;
		.expr := make_callfunc_expr(ast_callfunc_expr{.funcname := wipcall.funcname; .funcname_len := wipcall.funcname_len;});
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := first.children;
		.childcap := first.childcap;
		.childcount := first.childcount;
	};
	(ret.nodes_size) = 1;
};

wipfn_cap_off_params ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// assume first is a wipfn
	wipfn ::= nodes at 0;
	if((wipfn->type) != (ast_type.wipfn_blue))
	{
		psyc_panic(srcloc_current(), "expected blue wipfn when capping off params");
	}
	(wipfn->type) = (ast_type.wipfn_red);
	last ::= deref(nodes at (nodes_size - 1));
	(wipfn->cursor_end) = (last.cursor_end);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
	};
};

wipfn_last_node_is_return_type ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	wipfn ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	if((last.type) != (ast_type.unparsed_token))
	{
		psyc_panic(srcloc_current(), "expected symbol when treating last node as return type");
	}
	utok ::= last.utok;
	tok ::= utok.tok;

	lex ::= tok.lexeme;

	(wipfn->wipfn) = ast_wipfn
	{
		.ret_typename := source at (lex.off);
		.ret_typename_len := lex.len;
	};
	(wipfn->type) = (ast_type.wipfn_green);
	(wipfn->cursor_end) = (last.cursor_end);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

wipfn_move_2nd_node_to_param_blue ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// get 2nd node and set it as a param.
	// kill all but first node
	wipfn ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	second ::= deref(nodes at 1);
	ast_add_child(wipfn, second, ar);
	if((wipfn->type) != (ast_type.wipfn_blue))
	{
		psyc_panic(srcloc_current(), "expected blue wipfn when appending param (-> red)");
	}
	(wipfn->type) = (ast_type.wipfn_blue);
	(wipfn->cursor_end) = (last.cursor_end);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

wipfn_move_last_node_to_param_blue ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// get last node and set it as a param.
	// reduce to erase the last node
	wipfn ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	ast_add_child(wipfn, last, ar);
	if((wipfn->type) != (ast_type.wipfn_blue))
	{
		psyc_panic(srcloc_current(), "expected blue wipfn when appending param (-> blue)");
	}
	(wipfn->type) = (ast_type.wipfn_blue);
	(wipfn->cursor_end) = last.cursor_end;
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := nodes_size - 1;
		.len := 1;
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

boil_wipfn_yellow ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	firstptr ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));

	(firstptr->type) = (ast_type.wipfn_yellow);
	(firstptr->cursor_end) = (last.cursor_end);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};


wipfn_complain_need_impl_blk_or_extern ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// this happens if impl-blk or := extern is missing
	// e.g "func() -> v0" should be followed by:
	// ":= extern"
	// { ...impl block details... }
	return parse_value
	{
		.action := parse_action.error;
		.errmsg := "function declaration expression should either be followed by ':= extern' (to indicate external impl) or '{' to start an implementation block.";
		.push := false;
		.pop := false;
	};
};

wipfn2externfn ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	first ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	wipfn ::= first->wipfn;

	(first->type) = (ast_type.fn);
	(first->fn) = ast_fn
	{
		.fn_name := wipfn.fn_name;
		.fn_name_len := wipfn.fn_name_len;
		.ret_typename := wipfn.ret_typename;
		.ret_typename_len := wipfn.ret_typename_len;
		.is_extern := true;
	};
	(first->cursor_end) = last.cursor_end;
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

wipfn2fn ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	first ::= nodes at 0;
	last ::= deref(nodes at (nodes_size - 1));
	wipfn ::= first->wipfn;

	(first->type) = (ast_type.fn);
	(first->fn) = ast_fn
	{
		.fn_name := wipfn.fn_name;
		.fn_name_len := wipfn.fn_name_len;
		.ret_typename := wipfn.ret_typename;
		.ret_typename_len := wipfn.ret_typename_len;
		.is_extern := false;
	};
	(first->cursor_end) = last.cursor_end;
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := nodes_size - 1;
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

create_empty_wipstruct ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);
	first_expr ::= first.expr;
	first_symbol ::= first_expr.symbol;
	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.wipstruct;
		.structdef := ast_struct
		{
			.structname := first_symbol.symbol;
			.structname_len := first_symbol.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};
	(ret.nodes_size) = 1;
};

cap_off_wipstruct ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	firstptr ::= nodes at 0;
	(firstptr->type) = (ast_type.stmt);
	(firstptr->stmt) = (ast_stmt.struct_stmt);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

wipstruct_add_decl ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	wipstruct_ptr ::= nodes at 0;
	decl ::= deref(nodes at (nodes_size - 2));

	ast_add_child(wipstruct_ptr, decl, ar);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

push_first_node ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.commit;
		.offset := 0;
		.len := 0;
		.push := true;
		.pop := false;
	};
};

pop_node_to_front ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	return parse_value
	{
		.action := parse_action.commit;
		.offset := 0;
		.len := 0;
		.push := false;
		.pop := true;
	};
};

create_empty_wipblk ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	reduce_setup(parse_action.reduce);
	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.wipblk;
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};

	(ret.nodes_size) = 1;
};

cap_off_wipblk ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	first ::= nodes at 0;
	(first->type) = (ast_type.stmt);
	(first->stmt) = (ast_stmt.blk_stmt);
	last ::= deref(nodes at (nodes_size - 1));
	(first->cursor_end) = (last.cursor_end);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

create_wipregion ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	// 2nd param is the symbol
	symbol ::= deref(nodes at 1);
	utok ::= symbol.utok;
	tok ::= utok.tok;

	lslice ::= tok.lexeme;
	reduce_setup(parse_action.reduce);
	deref((ret.nodes) at 0) = ast
	{
		.type := ast_type.wipregion;
		.region := ast_region_stmt
		{
			.name := source at (lslice.off);
			.name_len := lslice.len;
		};
		.loc := first.loc;
		.cursor_begin := first.cursor_begin;
		.cursor_end := last.cursor_end;
		.children := null;
		.childcap := 0;
		.childcount := 0;
	};

	(ret.nodes_size) = 1;
};

cap_off_region ::= func(source : u8&, nodes : ast mut&, nodes_size : u64) -> parse_value
{
	first ::= nodes at 0;
	(first->type) = (ast_type.stmt);
	(first->stmt) = (ast_stmt.region_stmt);
	last ::= deref(nodes at (nodes_size - 1));
	(first->cursor_end) = (last.cursor_end);
	// remove all but the first node
	return parse_value
	{
		.action := parse_action.reduce;
		.offset := 1;
		.len := (nodes_size - 1);
		.nodes_size := 0;
		.push := false;
		.pop := false;
	};
};

[[private]]
grammar_parenthesised_expr ::= func() -> v0
{
	grammar_install(
		__array(ast, token(lex_token.oparen)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, token(lex_token.oparen)),
		zero_lookahead,
		true,
		rule(r1));

	// foreach expr type
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.symbol)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.symbol)),
		token(lex_token.cparen),
		true,
		rule(s1));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.literal)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.literal)),
		token(lex_token.cparen),
		true,
		rule(s1));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.biop)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.biop)),
		token(lex_token.cparen),
		true,
		rule(s1));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.unop)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.unop)),
		token(lex_token.cparen),
		true,
		rule(s1));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.callfunc)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.callfunc)),
		token(lex_token.cparen),
		true,
		rule(s1));

	// foreach expr type
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.symbol), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(parenthesised_expr));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.symbol), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(parenthesised_expr));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.literal), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(parenthesised_expr));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.literal), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(parenthesised_expr));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.biop), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(parenthesised_expr));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.biop), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(parenthesised_expr));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.unop), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(parenthesised_expr));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.unop), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(parenthesised_expr));

	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.callfunc), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(parenthesised_expr));
	grammar_install(
		__array(ast, token(lex_token.oparen), expr(ast_expr_type.callfunc), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(parenthesised_expr));
};

[[private]]
grammar_exprification ::= func() -> v0
{
	grammar_install(
		__array(ast, token(lex_token.numeric_literal)),
		zero_lookahead,
		false,
	rule(numlit2expr));
	grammar_install(
		__array(ast, token(lex_token.numeric_literal)),
		zero_lookahead,
		true,
	rule(numlit2expr));

	grammar_install(
		__array(ast, token(lex_token.symbol)),
		zero_lookahead,
		false,
	rule(symbol2expr));
	grammar_install(
		__array(ast, token(lex_token.symbol)),
		zero_lookahead,
		true,
	rule(symbol2expr));

	grammar_install(
		__array(ast, token(lex_token.char_literal)),
		zero_lookahead,
		false,
	rule(charlit2expr));
	grammar_install(
		__array(ast, token(lex_token.char_literal)),
		zero_lookahead,
		true,
	rule(charlit2expr));

	grammar_install(
		__array(ast, token(lex_token.string_literal)),
		zero_lookahead,
		false,
	rule(strlit2expr));
	grammar_install(
		__array(ast, token(lex_token.string_literal)),
		zero_lookahead,
		true,
	rule(strlit2expr));
};

[[private]]
grammar_stmtification ::= func() -> v0
{
	// note: this should support *all expr types*
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.biop)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.semicol),
		true,
	rule(s1));

	grammar_install(
		__array(ast, node(ast_type.fn)),
		token(lex_token.semicol),
		false,
	rule(s1));
	grammar_install(
		__array(ast, node(ast_type.fn)),
		token(lex_token.semicol),
		true,
	rule(s1));

	// expr stmtification (do this foreach expr type aswell as other things)
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(exprsemicol2stmt));
	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(exprsemicol2stmt));

	// decl stmtification
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(declsemicol2stmt));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(declsemicol2stmt));

	// fn stmtification
	grammar_install(
		__array(ast, node(ast_type.fn), token(lex_token.semicol)),
		zero_lookahead,
		false,
	rule(fnsemicol2stmt));
	grammar_install(
		__array(ast, node(ast_type.fn), token(lex_token.semicol)),
		zero_lookahead,
		true,
	rule(fnsemicol2stmt));
};

[[private]]
grammar_commits ::= func() -> v0
{
	// note: this should support *all stmt types*
	grammar_install(
		__array(ast, stmt(ast_stmt.expr_stmt)),
		zero_lookahead,
		true,
	rule(c1));

	grammar_install(
		__array(ast, stmt(ast_stmt.decl_stmt)),
		zero_lookahead,
		true,
	rule(c1));

	grammar_install(
		__array(ast, stmt(ast_stmt.region_stmt)),
		zero_lookahead,
		true,
	rule(c1));

	grammar_install(
		__array(ast, stmt(ast_stmt.blk_stmt)),
		zero_lookahead,
		true,
	rule(c1));

	grammar_install(
		__array(ast, stmt(ast_stmt.struct_stmt)),
		zero_lookahead,
		true,
	rule(c1));

	grammar_install(
		__array(ast, stmt(ast_stmt.fn_stmt)),
		zero_lookahead,
		true,
	rule(c1));
};

[[private]]
grammar_decls_edge_case_callfunc ::= func() -> v0
{
	// decl ::= myfunc()
	// already got rules elsewhere to not grab the symbol too early if its followed by an oparen - thats not the problem here
	// the problem is that the decl will only bind the initialiser to an expr
	// which is good, but our wipcalls are not exprs until they're complete
	
	// non-type-deduced
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		true,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		false,
		rule(r2));

	// type deduced variant
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		true,
		rule(r3));

	// recurse to wipcalls as they need to be fully parsed before we will accept them as a decl initialiser.
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white)),
		zero_lookahead,
		true,
		rule(r3));

	// also for both preceding comma and non-preceding comma
	// all expr types again im afraid for both black and white
	// black
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_black), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(r3));

	// white
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(r3));

	// with commas
	// white
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(r3));
};

[[private]]
grammar_decls ::= func() -> v0
{
	// expr(symbol) lookahead colon
	// shift to expr(symbol) colon
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.colon),
		false,
		rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.colon),
		true,
		rule(s1));

	// expr(symbol) colon
	// recurse twice (so offsetted nodes are now zero which causes an implicit shift)
	// this means the offsetted node state is *just* whatever was our lookahead before
	// long-story-short: recurse twice and start parsing whatever's next.
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon)),
		zero_lookahead,
		true,
		rule(r2));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon)),
		zero_lookahead,
		false,
		rule(r2));

	// special case if the colon is directly followed by an initialiser
	// then we're probably parsing a variable decl with a deduced type.
	// shift in that specific case.
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon)),
		token(lex_token.initialiser),
		true,
		rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon)),
		token(lex_token.initialiser),
		false,
		rule(s1));

	// expr(symbol) colon expr(symbol)
	// this is the most basic form of decl the language supports. e.g myvar : u64
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(basic_decl));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(basic_decl));

	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.initialiser),
		true,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(lex_token.initialiser),
		false,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser)),
		zero_lookahead,
		true,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser)),
		zero_lookahead,
		false,
		rule(r2));

	// do this for *all expr types* that can be decl initialisers
	// which is all of them.
	// note: there is a catch here
	// catch: decl := mysymbol
	// ah this is obvious, but it *could* be a callfunc just the oparen is not shifted in yet
	// so will take very good care... handle this as a separate edge-case function so assume it's not a problem here
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(give_decl_an_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(give_decl_an_initialiser));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(give_decl_an_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(give_decl_an_initialiser));

	// biops are a bit different as they will initially parse as something else and then come later.
	// so assume biops are handled fine for now!
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(give_decl_an_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(give_decl_an_initialiser));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(give_decl_an_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(give_decl_an_initialiser));

	// expr(symbol) colon initialiser
	// variable declaration with an initialiser expression. e.g myvar ::= 5
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser)),
		zero_lookahead,
		true,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser)),
		zero_lookahead,
		false,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser)),
		token(lex_token.keyword_struct),
		false,
		rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser)),
		token(lex_token.keyword_struct),
		true,
		rule(s1));
	// do this for *all expr types* that can be decl initialisers
	// which is all of them.
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(type_deduced_decl));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(type_deduced_decl));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(type_deduced_decl));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(type_deduced_decl));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(type_deduced_decl));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(type_deduced_decl));

	// structs can be decl initialisers too!
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.structdef)),
		zero_lookahead,
		false,
		rule(type_deduced_decl));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.structdef)),
		zero_lookahead,
		true,
		rule(type_deduced_decl));

	// special case for partial funcdefs
	grammar_install(
		__array(ast, node(ast_type.wipfn_green)),
		zero_lookahead,
		true,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_green)),
		zero_lookahead,
		false,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.wipfn_green), token(lex_token.obrace)),
		zero_lookahead,
		true,
		rule(boil_wipfn_yellow));
	grammar_install(
		__array(ast, node(ast_type.wipfn_green), token(lex_token.obrace)),
		zero_lookahead,
		false,
		rule(boil_wipfn_yellow));

	grammar_install(
		__array(ast, node(ast_type.wipfn_yellow)),
		zero_lookahead,
		false,
		rule(push_first_node));
	grammar_install(
		__array(ast, node(ast_type.wipfn_yellow)),
		zero_lookahead,
		true,
		rule(push_first_node));

	grammar_install(
		__array(ast, node(ast_type.wipfn_yellow), token(lex_token.cbrace)),
		zero_lookahead,
		false,
		rule(wipfn2fn));
	grammar_install(
		__array(ast, node(ast_type.wipfn_yellow), token(lex_token.cbrace)),
		zero_lookahead,
		true,
		rule(wipfn2fn));
};

grammar_biop_op ::= macro(tok : lex_token) -> v0
{
	// all expr types
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(tok),
		false,
		rule(r2));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(tok),
		true,
		rule(r2));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal)),
		token(tok),
		false,
		rule(r2));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal)),
		token(tok),
		true,
		rule(r2));

	grammar_install(
		__array(ast, expr(ast_expr_type.biop)),
		token(tok),
		false,
		rule(r2));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop)),
		token(tok),
		true,
		rule(r2));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop)),
		token(tok),
		false,
		rule(r2));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop)),
		token(tok),
		true,
		rule(r2));

	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(tok),
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl)),
		token(tok),
		true,
		rule(r2));

	// do this foreach expr type. (both first and last)
	// last
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(biopify_decl_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(biopify_decl_initialiser));

	// 

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(biopify_decl_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(biopify_decl_initialiser));

	// 

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(biopify_decl_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(biopify_decl_initialiser));

	// 

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.literal), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.biop), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.unop), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(create_biop));
	grammar_install(
		__array(ast, expr(ast_expr_type.callfunc), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(create_biop));

	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(biopify_decl_initialiser));
	grammar_install(
		__array(ast, node(ast_type.decl), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(biopify_decl_initialiser));
};

grammar_unop_op ::= macro(tok : lex_token) -> v0
{
	grammar_install(
		__array(ast, token(tok)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, token(tok)),
		zero_lookahead,
		true,
		rule(r1));

	// foreach expr type
	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(create_unop));
	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(create_unop));

	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(create_unop));
	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(create_unop));

	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(create_unop));
	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(create_unop));

	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(create_unop));
	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(create_unop));

	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(create_unop));
	grammar_install(
		__array(ast, token(tok), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(create_unop));

	// decl edge case
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(tok),
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser)),
		token(tok),
		true,
		rule(r2));

	// foreach expr type
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r2));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(r2));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(r2));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.unop)),
		zero_lookahead,
		true,
		rule(r2));

	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.decl), token(lex_token.initialiser), token(tok), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(r2));
};

[[private]]
grammar_wipfn ::= func() -> v0
{
	grammar_install(
		__array(ast, token(lex_token.keyword_func)),
		token(lex_token.oparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, token(lex_token.keyword_func)),
		token(lex_token.oparen),
		true,
		rule(s1));

	// create wipfn here
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser)),
		token(lex_token.keyword_func),
		false,
		rule(s2));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser)),
		token(lex_token.keyword_func),
		true,
		rule(s2));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), token(lex_token.keyword_func), token(lex_token.oparen)),
		zero_lookahead,
		false,
		rule(create_empty_wipfn));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), token(lex_token.keyword_func), token(lex_token.oparen)),
		zero_lookahead,
		true,
		rule(create_empty_wipfn));

	// blue wipfn is waiting for either:
	// cparen (end of params)
	// anything else (assume will parse down to a decl which will then become red)
	//	note: for the aforementioned "anything else", lots of these rules will just recurse 1 to get the wipfn out of the way and re-use the decl parse rules
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue)),
		token(lex_token.cparen),
		true,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.wipfn_blue)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue)),
		zero_lookahead,
		true,
		rule(r1));

	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), expr(ast_expr_type.symbol), token(lex_token.colon)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), expr(ast_expr_type.symbol), token(lex_token.colon)),
		zero_lookahead,
		true,
		rule(r1));

	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r1));

	// blue -> red (accept a new param followed by a commar implying more params to come)
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), node(ast_type.decl)),
		token(lex_token.comma),
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), node(ast_type.decl)),
		token(lex_token.comma),
		true,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), node(ast_type.decl), token(lex_token.comma)),
		zero_lookahead,
		false,
		rule(wipfn_move_2nd_node_to_param_blue));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), node(ast_type.decl), token(lex_token.comma)),
		zero_lookahead,
		true,
		rule(wipfn_move_2nd_node_to_param_blue));


	// blue -> blue (accept a new param followed by a cparen implying this is the last param and we will cap off soon)
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), node(ast_type.decl)),
		token(lex_token.cparen),
		false,
		rule(wipfn_move_last_node_to_param_blue));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), node(ast_type.decl)),
		token(lex_token.cparen),
		true,
		rule(wipfn_move_last_node_to_param_blue));

	// blue -> red (close off params)
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(wipfn_cap_off_params));
	grammar_install(
		__array(ast, node(ast_type.wipfn_blue), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(wipfn_cap_off_params));

	// red wipfn has all the parameters finalised but nothing further - needs return type
	grammar_install(
		__array(ast, node(ast_type.wipfn_red)),
		token(lex_token.arrow),
		false,
		rule(s2));
	grammar_install(
		__array(ast, node(ast_type.wipfn_red)),
		token(lex_token.arrow),
		true,
		rule(s2));

	// red -> green (collect return type)
	grammar_install(
		__array(ast, node(ast_type.wipfn_red), token(lex_token.arrow), token(lex_token.symbol)),
		zero_lookahead,
		false,
		rule(wipfn_last_node_is_return_type));
	grammar_install(
		__array(ast, node(ast_type.wipfn_red), token(lex_token.arrow), token(lex_token.symbol)),
		zero_lookahead,
		true,
		rule(wipfn_last_node_is_return_type));

	// green has all the information about the function signature itself (params and return type)
	// but in psy, func(..) -> foo is followed by one of two things:
	// - a obrace, which means a block statement is expected next
	// - a fragment that reads: ":= extern" indicating that the function is implemented externally.

	// impl note: i am just checking for semicol lookahead here which is the most obvious erroneous syntax
	// however i havent bothered to implement the impl-blk or extern paths yet
	// what you should todo: handle impl-blk and extern paths
	// if neither of them are hit, then the rule should be wipfn_complain_... instead of just checking for semicol lookahead.
	grammar_install(
		__array(ast, node(ast_type.wipfn_green)),
		token(lex_token.semicol),
		false,
		rule(wipfn_complain_need_impl_blk_or_extern));
	grammar_install(
		__array(ast, node(ast_type.wipfn_green)),
		token(lex_token.semicol),
		true,
		rule(wipfn_complain_need_impl_blk_or_extern));
};

[[private]]
grammar_deffunc ::= func() -> v0
{
	grammar_install(
		__array(ast, node(ast_type.wipfn_green)),
		token(lex_token.initialiser),
		false,
		rule(s2));
	grammar_install(
		__array(ast, node(ast_type.wipfn_green)),
		token(lex_token.initialiser),
		true,
		rule(s2));

	grammar_install(
		__array(ast, node(ast_type.wipfn_green), token(lex_token.initialiser), token(lex_token.keyword_extern)),
		zero_lookahead,
		false,
		rule(wipfn2externfn));
	grammar_install(
		__array(ast, node(ast_type.wipfn_green), token(lex_token.initialiser), token(lex_token.keyword_extern)),
		zero_lookahead,
		true,
		rule(wipfn2externfn));
};

[[private]]
grammar_callfunc_edge_case_param_callfunc ::= func() -> v0
{
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		true,
		rule(r1));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		true,
		rule(r1));

	// wipcall_white, symbol lookahead (
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		true,
		rule(r2));

	// wipcall_black wipcall_black (i.e nested function call but the 2nd function call is not yet fully parsed)
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), node(ast_type.wipcall_black)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), node(ast_type.wipcall_black)),
		zero_lookahead,
		true,
		rule(r1));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), node(ast_type.wipcall_black)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), node(ast_type.wipcall_black)),
		zero_lookahead,
		true,
		rule(r2));
};

[[private]]
grammar_callfunc ::= func() -> v0
{
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol)),
		token(lex_token.oparen),
		true,
		rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.oparen)),
		zero_lookahead,
		false,
		rule(make_wipcall));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.oparen)),
		zero_lookahead,
		true,
		rule(make_wipcall));

	// wipcall_black can be followed by:
	// ) to cap it off to a callfunc_expr
	// any expression to add a param (and turn it into a wipcall white)

	// if wipcall loookahead is ), then we're going to shift once and cap it off next.
	grammar_install(
		__array(ast, node(ast_type.wipcall_black)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black)),
		token(lex_token.cparen),
		true,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white)),
		token(lex_token.cparen),
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white)),
		token(lex_token.cparen),
		true,
		rule(s1));

	// if not, then we recurse 1
	grammar_install(
		__array(ast, node(ast_type.wipcall_black)),
		zero_lookahead,
		false,
		rule(r1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black)),
		zero_lookahead,
		true,
		rule(r1));

	// wipcall_black expr(any) = add a param to white
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	// cap off wipcall)
	// supports both black (means no params) and white (at least one param)
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(cap_off_wipcall));
	grammar_install(
		__array(ast, node(ast_type.wipcall_black), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(cap_off_wipcall));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.cparen)),
		zero_lookahead,
		false,
		rule(cap_off_wipcall));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.cparen)),
		zero_lookahead,
		true,
		rule(cap_off_wipcall));

	// handle multi param
	grammar_install(
		__array(ast, node(ast_type.wipcall_white)),
		token(lex_token.comma),
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white)),
		token(lex_token.comma),
		true,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma)),
		zero_lookahead,
		false,
		rule(r2));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma)),
		zero_lookahead,
		true,
		rule(r2));

	// all expr types
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.literal)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.literal)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.biop)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.biop)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));

	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		false,
		rule(wipcall_add_another_arg_white));
	grammar_install(
		__array(ast, node(ast_type.wipcall_white), token(lex_token.comma), expr(ast_expr_type.callfunc)),
		zero_lookahead,
		true,
		rule(wipcall_add_another_arg_white));
};

[[private]]
grammar_edge_case_decl_structdef ::= func() -> v0
{
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), token(lex_token.cbrace)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), token(lex_token.cbrace)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r4));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r4));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		false,
		rule(r4));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), expr(ast_expr_type.symbol), token(lex_token.colon), expr(ast_expr_type.symbol)),
		zero_lookahead,
		true,
		rule(r4));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), node(ast_type.decl)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), node(ast_type.decl)),
		zero_lookahead,
		true,
		rule(r3));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), stmt(ast_stmt.decl_stmt)),
		zero_lookahead,
		false,
		rule(r3));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), node(ast_type.wipstruct), stmt(ast_stmt.decl_stmt)),
		zero_lookahead,
		true,
		rule(r3));
};

[[private]]
grammar_structdef ::= func() -> v0
{
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), token(lex_token.keyword_struct)),
		zero_lookahead,
		false,
		rule(s1));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), token(lex_token.keyword_struct)),
		zero_lookahead,
		true,
		rule(s1));

	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), token(lex_token.keyword_struct), token(lex_token.obrace)),
		zero_lookahead,
		false,
		rule(create_empty_wipstruct));
	grammar_install(
		__array(ast, expr(ast_expr_type.symbol), token(lex_token.colon), token(lex_token.initialiser), token(lex_token.keyword_struct), token(lex_token.obrace)),
		zero_lookahead,
		true,
		rule(create_empty_wipstruct));

	grammar_install(
		__array(ast, node(ast_type.wipstruct)),
		zero_lookahead,
		false,
		rule(push_first_node));
	grammar_install(
		__array(ast, node(ast_type.wipstruct)),
		zero_lookahead,
		true,
		rule(push_first_node));

	grammar_install(
		__array(ast, node(ast_type.wipstruct), token(lex_token.cbrace)),
		token(lex_token.semicol),
		false,
		rule(s1));
	grammar_install(
		__array(ast, node(ast_type.wipstruct), token(lex_token.cbrace)),
		token(lex_token.semicol),
		true,
		rule(s1));

	grammar_install(
		__array(ast, node(ast_type.wipstruct), token(lex_token.cbrace), token(lex_token.semicol)),
		zero_lookahead,
		false,
		rule(cap_off_wipstruct));
	grammar_install(
		__array(ast, node(ast_type.wipstruct), token(lex_token.cbrace), token(lex_token.semicol)),
		zero_lookahead,
		true,
		rule(cap_off_wipstruct));
};

[[private]]
grammar_region ::= func() -> v0
{
	grammar_install(
		__array(ast, token(lex_token.compare)),
		token(lex_token.symbol),
		false,
		rule(s3));
	grammar_install(
		__array(ast, token(lex_token.compare)),
		token(lex_token.symbol),
		true,
		rule(s3));

	// todo: create empty wipregion
	grammar_install(
		__array(ast, token(lex_token.compare), token(lex_token.symbol), token(lex_token.compare), token(lex_token.obrace)),
		zero_lookahead,
		false,
		rule(create_wipregion));
	grammar_install(
		__array(ast, token(lex_token.compare), token(lex_token.symbol), token(lex_token.compare), token(lex_token.obrace)),
		zero_lookahead,
		true,
		rule(create_wipregion));

	// todo: winch regions
	grammar_install(
		__array(ast, node(ast_type.wipregion)),
		zero_lookahead,
		false,
		rule(push_first_node));
	grammar_install(
		__array(ast, node(ast_type.wipregion)),
		zero_lookahead,
		true,
		rule(push_first_node));
	
	// cap off region
	grammar_install(
		__array(ast, node(ast_type.wipregion), token(lex_token.cbrace)),
		zero_lookahead,
		false,
		rule(cap_off_region));
	grammar_install(
		__array(ast, node(ast_type.wipregion), token(lex_token.cbrace)),
		zero_lookahead,
		true,
		rule(cap_off_region));
};

[[private]]
grammar_block_stmt ::= func() -> v0
{
	grammar_install(
		__array(ast, token(lex_token.obrace)),
		zero_lookahead,
		false,
		rule(create_empty_wipblk));
	grammar_install(
		__array(ast, token(lex_token.obrace)),
		zero_lookahead,
		true,
		rule(create_empty_wipblk));

	grammar_install(
		__array(ast, node(ast_type.wipblk)),
		zero_lookahead,
		false,
		rule(push_first_node));
	grammar_install(
		__array(ast, node(ast_type.wipblk)),
		zero_lookahead,
		true,
		rule(push_first_node));

	grammar_install(
		__array(ast, node(ast_type.wipblk), token(lex_token.cbrace)),
		zero_lookahead,
		false,
		rule(cap_off_wipblk));
	grammar_install(
		__array(ast, node(ast_type.wipblk), token(lex_token.cbrace)),
		zero_lookahead,
		true,
		rule(cap_off_wipblk));

};

grammar_setup ::= func(a : arena mut&) -> v0
{
	psyc_timed(psyc_stage.setup);
	ar = a;
	parse_table_cap = 65536;
	parse_table = arena_push(a, __sizeof(deref parse_table) * parse_table_cap);
	__memset(parse_table, 0, __sizeof(deref parse_table) * parse_table_cap);

	grammar_parenthesised_expr();
	grammar_exprification();
	grammar_stmtification();
	grammar_commits();
	grammar_decls_edge_case_callfunc();
	grammar_decls();
	grammar_biop_op(lex_token.assign);
	grammar_biop_op(lex_token.plus);
	grammar_biop_op(lex_token.dash);
	grammar_biop_op(lex_token.asterisk);
	grammar_biop_op(lex_token.fslash);
	grammar_biop_op(lex_token.keyword_at);
	grammar_unop_op(lex_token.dash);
	grammar_wipfn();
	grammar_deffunc();
	grammar_callfunc_edge_case_param_callfunc();
	grammar_callfunc();

	grammar_edge_case_decl_structdef();
	grammar_structdef();

	grammar_region();
	grammar_block_stmt();

	grammar_install(
		__array(ast, token(lex_token.cbrace)),
		zero_lookahead,
		false,
		rule(pop_node_to_front));
	grammar_install(
		__array(ast, token(lex_token.cbrace)),
		zero_lookahead,
		true,
		rule(pop_node_to_front));
};

== build ==
{
	add_source_file("stdlib/hash.psy");

	add_source_file("ast.psy");
	add_source_file("type.psy");
}
