source_file ::= struct
{
	src : u8?;
	path : u8?;
};

// if out_file_scope isnt zero, i will write out the new file scope i created for this file.
add_source_file_to_compilation ::= func(path : u8?, out_file_scope : lexical_scope mut? mut? -> ast)
{
	src ::= fully_read_file(path, global_arena);

	tokens ::= lex(src);
	nodes ::= parse(src, ref tokens);

	file_scope ::= progwalk_file(ref nodes);
	if(out_file_scope != zero)
	{
		deref(out_file_scope) = file_scope;
	}
	return nodes;
};

find_and_invoke_build_region ::= func(scope : lexical_scope?, region_name : u8?, region_name_len : u64 -> v0)
{
	the_region : region mut? mut := zero;

	i : u64 mut;
	for(i = 0, i < (scope->regions_count), i = i + 1)
	{
		cur_region ::= scope->regions # i;
		if(cur_region->name_len == region_name_len)
		{
			if(streql_n(cur_region->name, region_name, region_name_len))
			{
				the_region = cur_region;
			}
		}
	}

	if(the_region == zero)
	{
		// todo: maybe pass in a called_from ast so we can give a more specific error message in the case that the build region was invoked from another?
		psyc_error_begin(zero);
		putzstr("build file ");
		putchar('"');
		putbytes(scope->name, scope->name_len);
		putchar('"');
		putzstr(" had no region named ");
		putchar('"');
		putbytes(region_name, region_name_len);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	// todo: invoke build region.
	invoke_build_region(the_region->node);
};

add_build_file_to_compilation ::= func(path : u8?, config : u8?, config_len : u64 -> ast)
{
	file_scope : lexical_scope mut? mut := zero;
	node ::= add_source_file_to_compilation(path, ref file_scope);

	psyc_timed_begin(psyc_stage.build);
	find_and_invoke_build_region(file_scope, config, config_len);
	psyc_timed_end();

	return node;
};

add_entrypoint_to_compilation ::= func(-> v0)
{
	// todo: entrypoint
};

add_preload_to_compilation ::= func(-> v0)
{
	// todo: preload
};

compile_program ::= func(-> v0)
{
	putzstr("Parsing...          ");
	putchar(13);
	args ::= ref(prog.compile_args);

	default_config ::= "default";
	add_build_file_to_compilation(prog.compile_args.build_file, default_config, zstrlen(default_config));
	add_preload_to_compilation();
	if(prog.type == (program_type.executable))
	{
		add_entrypoint_to_compilation();
	}

	if(!directory_exists(args->output_dir))
	{
		directory_create(args->output_dir);
	}
	putzstr("Semantic Analysis...");
	putchar(13);
	//semal();

	putzstr("Code Generation...  ");
	putchar(13);
	//codegen();

	putzstr("Assembly...         ");
	putchar(13);
	//assemble();

	putzstr("Link...             ");
	putchar(13);
	//link();

	postbuild();
};

postbuild ::= func(-> v0)
{
};

// read a file path. allocates for the whole file data. returns zero if file didnt exist.
fully_read_file ::= func(path : u8?, a : arena mut? -> source_file)
{
	if(!file_exists(path))
	{
		psyc_error_begin(zero);
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" could not be located (cwd: ");
		cwd : u8? mut;
		cwdlen : u64 mut;
		directory_get_cwd(ref cwd, ref cwdlen, global_arena);
		putbytes(cwd, cwdlen);
		putzstr(")");
		psyc_diag_end();
		psyc_exit_failure();
	}
	len ::= file_size_bytes(path);
	if(len == 0)
	{
		psyc_warning_begin(zero);
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" exists but is empty");
		psyc_diag_end();
	}
	data : u8 mut? := arena_alloc(a, len + 1);
	file_read(path, data, len);
	deref(data # len) = 0;
	return source_file
	{
		.src := data;
		.path := path;
	};
};

