// if out_file_scope isnt zero, i will write out the new file scope i created for this file.
add_source_file_inner ::= func(src : source_file, out_file_scope : lexical_scope mut? mut? -> ast)
{
	tokens ::= lex(src);
	nodes ::= parse(src, ref tokens);

	file_scope ::= progwalk_file(ref nodes);
	if(out_file_scope != zero)
	{
		deref(out_file_scope) = file_scope;
	}
	return nodes;
};

add_source_file_to_compilation ::= func(path : u8? -> ast)
{
	src ::= fully_read_file(path);
	program_push_source_file(src);
	ret ::= add_source_file_inner(src, zero);
	return ret;
};

add_build_file_to_compilation ::= func(path : u8?, config : u8?, config_len : u64 -> ast)
{
	src ::= fully_read_file(path);
	program_push_source_file(src);

	file_scope : lexical_scope mut? mut := zero;
	node ::= add_source_file_inner(src, ref file_scope);

	psyc_timed_begin(psyc_stage.build);
	find_and_invoke_build_region(file_scope, config, config_len, zero);
	psyc_timed_end();

	return node;
};

add_entrypoint_to_compilation ::= func(-> v0)
{
	// todo: entrypoint
};

add_preload_to_compilation ::= func(-> v0)
{
	// todo: preload
};

compile_program ::= func(-> v0)
{
	putzstr("Parsing...          ");
	putchar(13);
	args ::= ref(prog.compile_args);

	default_config ::= "default";
	add_build_file_to_compilation(prog.compile_args.build_file, default_config, zstrlen(default_config));
	add_preload_to_compilation();
	if(prog.type == (program_type.executable))
	{
		add_entrypoint_to_compilation();
	}

	while(prog.queued_build_paths_count > 0)
	{
		cur_build_path ::= deref(prog.queued_build_paths # (prog.queued_build_paths_count - 1));
		cur_build_len ::= deref(prog.queued_build_path_lens # (prog.queued_build_paths_count - 1));
		cur_build_config ::= deref(prog.queued_build_path_configs # (prog.queued_build_paths_count - 1));
		build_path_zstr ::= sstr2zstr(cur_build_path, cur_build_len, string_arena);
		add_build_file_to_compilation(build_path_zstr, cur_build_config, zstrlen(cur_build_config));
		prog.queued_build_paths_count = (prog.queued_build_paths_count - 1);
	}

	while(prog.queued_source_paths_count > 0)
	{
		cur_source_path ::= deref(prog.queued_source_paths # (prog.queued_source_paths_count - 1));
		cur_source_len ::= deref(prog.queued_source_path_lens # (prog.queued_source_paths_count - 1));
		src_path_zstr ::= sstr2zstr(cur_source_path, cur_source_len, string_arena);
		add_source_file_to_compilation(src_path_zstr);
		prog.queued_source_paths_count = (prog.queued_source_paths_count - 1);
	}

	if(!directory_exists(args->output_dir))
	{
		directory_create(args->output_dir);
	}
	putzstr("Semantic Analysis...");
	putchar(13);
	semal();

	putzstr("Code Generation...  ");
	putchar(13);
	codegen();

	putzstr("Assembly...         ");
	putchar(13);
	//assemble();

	putzstr("Link...             ");
	putchar(13);
	//link();

	postbuild();
};

postbuild ::= func(-> v0)
{
};

// read a file path. allocates for the whole file data. returns zero if file didnt exist.
fully_read_file ::= func(path : u8? -> source_file)
{
	if(!file_exists(path))
	{
		psyc_error_begin(zero);
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" could not be located (cwd: ");
		cwd : u8? mut;
		cwdlen : u64 mut;
		directory_get_cwd(ref cwd, ref cwdlen, global_arena);
		putbytes(cwd, cwdlen);
		putzstr(")");
		psyc_diag_end();
		psyc_exit_failure();
	}
	len ::= file_size_bytes(path);
	if(len == 0)
	{
		psyc_warning_begin(zero);
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" exists but is empty");
		psyc_diag_end();
	}
	data : u8 mut? := arena_alloc(string_arena, len + 1);
	file_read(path, data, len);
	deref(data # len) = 0;
	return source_file
	{
		.src := data;
		.path := path;
	};
};
