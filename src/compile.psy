// if out_file_scope isnt zero, i will write out the new file scope i created for this file.
add_source_file_inner : func(src : source_file, out_file_scope : lexical_scope mut? mut? -> ast)
{
	tokens ::= lex(src);
	nodes ::= parse(src, ref tokens);

	file_scope ::= progwalk_file(ref nodes);
	if(out_file_scope != zero)
	{
		[out_file_scope] = file_scope;
	}
	return nodes;
};

add_source_data_to_compilation : func(path : u8?, src : u8? -> ast)
{
	file ::= source_file
	{
		.src := src;
		.path := path;
	};
	program_push_source_file(file);
	ret ::= add_source_file_inner(file, zero);
	return ret;
};

add_source_file_to_compilation : func(path : u8? -> ast)
{
	src ::= fully_read_file(path);
	return add_source_data_to_compilation(path, src.src);
};

add_build_file_to_compilation : func(path : u8?, config : u8?, config_len : u64 -> ast)
{
	src ::= fully_read_file(path);
	program_push_source_file(src);

	file_scope : lexical_scope mut? mut := zero;
	node ::= add_source_file_inner(src, ref file_scope);

	psyc_timed_begin(psyc_stage.build);
	// for a build file specifically we set the cwd to its parent directory when doing its build region
	oldcwd : u8? mut;
	oldcwdlen : u64 mut;
	directory_get_cwd(ref oldcwd, ref oldcwdlen, string_arena);
	directory_set_cwd(path, path_get_parent_len(path, zstrlen(path)), string_arena);
	find_and_invoke_build_region(file_scope, config, config_len, zero);
	directory_set_cwd(oldcwd, oldcwdlen, string_arena);
	psyc_timed_end();

	return node;
};

add_entrypoint_to_compilation : func(-> v0)
{
	// todo: entrypoint
	static_if(_win32)
	{
		entrypoint_data ::= embed("./runtime/entrypoint_win32_2.psy");
	}
	else
	{
		entrypoint_data ::= embed("./runtime/entrypoint_linux_2.psy");
	}
	add_source_data_to_compilation("entrypoint.psy", sstr2zstr(entrypoint_data.data, entrypoint_data.len, global_arena));
};

win32_node : ast mut := zero;
linux_node : ast mut := zero;
add_platform_to_compilation : func(-> v0)
{
	win32_node = ast
	{
		.tag := ast_tag.stmt;
		.stmt := ast_stmt_tag.decl;
		.decl := ast_decl
		{
			.tag := ast_decl_tag.finalised;
			.name := "_win32";
			.name_len := 6;
		};
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	ast_add_child(ref win32_node, ast
	{
		.tag := ast_tag.typename;
		.typename := ast_typename
		{
			.tag := ast_typename_tag.finalised;
			.quals := tyqual.qual_static;
			.descriptor := ast_typename_descriptor.base;
			.basename := "bool";
			.basename_len := 4;
		};
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	}, global_arena);
	ast_add_child(ref win32_node, ast
	{
		.tag := ast_tag.expr;
		.expr := ast_expr_tag.literal;
		.literal := ast_literal
		{
			.tag := ast_literal_tag.boolean;
			.boolean := _win32;
		};
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	}, global_arena);

	linux_node = ast mut
	{
		.tag := ast_tag.stmt;
		.stmt := ast_stmt_tag.decl;
		.decl := ast_decl
		{
			.tag := ast_decl_tag.finalised;
			.name := "_linux";
			.name_len := 6;
		};
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	ast_add_child(ref linux_node, ast
	{
		.tag := ast_tag.typename;
		.typename := ast_typename
		{
			.tag := ast_typename_tag.finalised;
			.quals := tyqual.qual_static;
			.descriptor := ast_typename_descriptor.base;
			.basename := "bool";
			.basename_len := 4;
		};
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	}, global_arena);
	ast_add_child(ref linux_node, ast
	{
		.tag := ast_tag.expr;
		.expr := ast_expr_tag.literal;
		.literal := ast_literal
		{
			.tag := ast_literal_tag.boolean;
			.boolean := _linux;
		};
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	}, global_arena);

	win32_var ::= scope_add_variable(program_scope(), variable
	{
		.node := ref win32_node;
		.type := zero;
		.compile_time_storage := zero;
		.param_idx := -1;
		.cg := zero;
		.db := zero;
	});
	semal_variable(win32_var, program_scope());
	s_decl(win32_var, program_scope());

	linux_var ::= scope_add_variable(program_scope(), variable
	{
		.node := ref linux_node;
		.type := zero;
		.compile_time_storage := zero;
		.param_idx := -1;
		.cg := zero;
		.db := zero;
	});
	semal_variable(linux_var, program_scope());
	s_decl(linux_var, program_scope());
};

add_preload_to_compilation : func(-> v0)
{
	preload_data ::= embed("./runtime/preload2.psy");
	add_source_data_to_compilation("preload.psy", sstr2zstr(preload_data.data, preload_data.len, global_arena));
};

compile_program : func(-> v0)
{
	cwd : u8? mut;
	cwdlen : u64 mut;
	directory_get_cwd(ref cwd, ref cwdlen, global_arena);

	putzstr("Parsing...          ");
	putchar(13);
	args ::= ref(prog.compile_args);

	cg_setup();
	dbg_setup();
	add_platform_to_compilation();
	add_preload_to_compilation();
	builtin_setup();
	config ::= prog.compile_args.build_config;
	add_build_file_to_compilation(prog.compile_args.build_file, config, zstrlen(config));
	if(prog.type == (program_type.executable))
	{
		add_entrypoint_to_compilation();
	}

	while(prog.queued_build_paths_count > 0)
	{
		cur_build_path ::= [prog.queued_build_paths # (prog.queued_build_paths_count - 1)];
		cur_build_len ::= [prog.queued_build_path_lens # (prog.queued_build_paths_count - 1)];
		cur_build_config ::= [prog.queued_build_path_configs # (prog.queued_build_paths_count - 1)];
		build_path_zstr ::= sstr2zstr(cur_build_path, cur_build_len, string_arena);

		add_build_file_to_compilation(build_path_zstr, cur_build_config, zstrlen(cur_build_config));

		prog.queued_build_paths_count = (prog.queued_build_paths_count - 1);
	}

	while(prog.queued_source_paths_count > 0)
	{
		cur_source_path ::= [prog.queued_source_paths # (prog.queued_source_paths_count - 1)];
		cur_source_len ::= [prog.queued_source_path_lens # (prog.queued_source_paths_count - 1)];
		src_path_zstr ::= sstr2zstr(cur_source_path, cur_source_len, string_arena);
		add_source_file_to_compilation(src_path_zstr);
		prog.queued_source_paths_count = (prog.queued_source_paths_count - 1);
	}

	if(!directory_exists(args->output_dir))
	{
		directory_create(args->output_dir);
	}
	putzstr("Semantic Analysis...");
	putchar(13);
	semal();

	putzstr("Code Generation...  ");
	putchar(13);
	codegen();

	putzstr("Assembly...         ");
	putchar(13);
	assemble();

	putzstr("Link...             ");
	putchar(13);
	link();
	directory_set_cwd(cwd, cwdlen, string_arena);

	postbuild();
};

postbuild : func(-> v0)
{
	psyc_timed_begin(psyc_stage.build);
	i : u64 mut;
	for(i = 0; i < (prog.queued_postbuild_commands_count); i = i + 1)
	{
		cmd ::= [prog.queued_postbuild_commands # i];
		len ::= [prog.queued_postbuild_command_lens # i];
		sys_shell_command(cmd, len, envp, global_arena);
	}
	psyc_timed_end();

};

// read a file path. allocates for the whole file data. returns zero if file didnt exist.
fully_read_file : func(path : u8? -> source_file)
{
	if(!file_exists(path))
	{
		psyc_error_begin(zero);
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" could not be located (cwd: ");
		cwd : u8? mut;
		cwdlen : u64 mut;
		directory_get_cwd(ref cwd, ref cwdlen, global_arena);
		putbytes(cwd, cwdlen);
		putzstr(")");
		psyc_diag_end();
		psyc_exit_failure();
	}
	len ::= file_size_bytes(path);
	if(len == 0)
	{
		psyc_warning_begin(zero);
		putzstr("file ");
		putchar('"');
		putzstr(path);
		putchar('"');
		putzstr(" exists but is empty");
		psyc_diag_end();
	}
	data : u8 mut? := arena_alloc(string_arena, len + 1);
	file_read(path, data, len);
	[data # len] = 0;
	return source_file
	{
		.src := data;
		.path := path;
	};
};
