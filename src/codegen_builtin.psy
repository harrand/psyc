debugtrap_fn : u64 mut;

cg_builtin_debugbreak ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	
	fn_type ::= LLVMFunctionType(LLVMVoidType(), null, 0, false@s32);
	if(debugtrap_fn == 0)
	{
		debugtrap_fn = LLVMAddFunction(mod, "llvm.debugtrap", fn_type);
	}
	LLVMBuildCall2(ir, fn_type, debugtrap_fn, null, 0, "");
	return zero;
};

cg_builtin_memcpy ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	dstnode ::= ast_get_child(node@_, 0);
	dst : cgv mut := cg_expr(context
	{
		.node := dstnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref dst, prog);
	if(!ty_is(dst.type, tytag.ptr))
	{
		psyc_error_begin(dstnode->loc);
		puts("Invalid call to builtin - param 0 must be a pointer type, you provided ");
		putchar('"');
		putty(dst.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	srcnode ::= ast_get_child(node@_, 1);
	src : cgv mut := cg_expr(context
	{
		.node := srcnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref src, prog);
	if(!ty_is(src.type, tytag.ptr))
	{
		psyc_error_begin(srcnode->loc);
		puts("Invalid call to builtin - param 1 must be a pointer type, you provided ");
		putchar('"');
		putty(src.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	lennode ::= ast_get_child(node@_, 2);
	len : cgv mut := cg_expr(context
	{
		.node := lennode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref len, prog);
	len = cgv_convert(len, ty_getprim(primty.u64, tyqual.weak), prog, lennode->loc, ctx.typecheck_only, false);

	param_tys : u64 mut#4;
	deref(param_tys at 0) = (cg.type(dst.type, prog));
	deref(param_tys at 1) = (cg.type(src.type, prog));
	deref(param_tys at 2) = (cg.type(len.type, prog));
	deref(param_tys at 3) = (cg.type(ty_getprim(primty.bool, zero), prog));

	val_lls : u64 mut#4;
	deref(val_lls at 0) = (dst.ll);
	deref(val_lls at 1) = (src.ll);
	deref(val_lls at 2) = (len.ll);
	deref(val_lls at 3) = LLVMConstNull(deref(param_tys at 3));

	fn_type ::= LLVMFunctionType(LLVMVoidType(), param_tys at 0, 4, false@s32);
	fn ::= LLVMAddFunction(mod, "llvm.memcpy.p0.p0.i64", fn_type);
	LLVMBuildCall2(ir, fn_type, fn, val_lls at 0, 4, "");
	return zero;
};

cg_builtin_memset ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	dstnode ::= ast_get_child(node@_, 0);
	dst : cgv mut := cg_expr(context
	{
		.node := dstnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref dst, prog);
	if(!ty_is(dst.type, tytag.ptr))
	{
		psyc_error_begin(dstnode->loc);
		puts("Invalid call to builtin - param 0 must be a pointer type, you provided ");
		putchar('"');
		putty(dst.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	valnode ::= ast_get_child(node@_, 1);
	val : cgv mut := cg_expr(context
	{
		.node := valnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref val, prog);
	val = cgv_convert(val, ty_getprim(primty.u8, tyqual.weak), prog, valnode->loc, ctx.typecheck_only, false);

	lennode ::= ast_get_child(node@_, 2);
	len : cgv mut := cg_expr(context
	{
		.node := lennode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref len, prog);
	len = cgv_convert(len, ty_getprim(primty.u64, tyqual.weak), prog, lennode->loc, ctx.typecheck_only, false);

	param_tys : u64 mut#4;
	deref(param_tys at 0) = (cg.type(dst.type, prog));
	deref(param_tys at 1) = (cg.type(val.type, prog));
	deref(param_tys at 2) = (cg.type(len.type, prog));
	deref(param_tys at 3) = (cg.type(ty_getprim(primty.bool, zero), prog));

	val_lls : u64 mut#4;
	deref(val_lls at 0) = (dst.ll);
	deref(val_lls at 1) = (val.ll);
	deref(val_lls at 2) = (len.ll);
	deref(val_lls at 3) = LLVMConstNull(deref(param_tys at 3));

	fn_type ::= LLVMFunctionType(LLVMVoidType(), param_tys at 0, 4, false@s32);
	fn ::= LLVMAddFunction(mod, "llvm.memset.inline.p0.i64", fn_type);
	LLVMBuildCall2(ir, fn_type, fn, val_lls at 0, 4, "");
	return zero;
};

cg_builtin_sizeof ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	type : ty mut := zero;

	dstnode ::= ast_get_child((ctx.node)@_, 0);
	if(ast_is_expr(dstnode, ast_expr_type.symbol))
	{
		expr ::= dstnode->expr;
		sym ::= expr.symbol;
		type = scope_parse_typename(ctx.local, sym.symbol, sym.len);
	}
	if(ty_isbad(type))
	{
		val : cgv mut := cg_expr(context
		{
			.node := dstnode;
			.local := ctx.local;
		}, prog);
		type = (val.type);
	}

	dl ::= LLVMGetModuleDataLayout(mod);
	return cg_literal(make_literal_expr(ast_literal_expr
	{
		.type := ast_literal_type.integral;
		.integral := LLVMABISizeOfType(dl, cg.type(type, prog))@_;
	}), ctx, prog);
};

cg_builtin_alignof ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	type : ty mut := zero;

	dstnode ::= ast_get_child((ctx.node)@_, 0);
	if(ast_is_expr(dstnode, ast_expr_type.symbol))
	{
		expr ::= dstnode->expr;
		sym ::= expr.symbol;
		type = scope_parse_typename(ctx.local, sym.symbol, sym.len);
	}
	if(ty_isbad(type))
	{
		val : cgv mut := cg_expr(context
		{
			.node := dstnode;
			.local := ctx.local;
		}, prog);
		type = (val.type);
	}

	dl ::= LLVMGetModuleDataLayout(mod);
	return cg_literal(make_literal_expr(ast_literal_expr
	{
		.type := ast_literal_type.integral;
		.integral := LLVMABIAlignmentOfType(dl, cg.type(type, prog))@_;
	}), ctx, prog);
};

cg_builtin_arrcpy ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	if(ctx.typecheck_only)
	{
		return zero;
	}
	node ::= ctx.node;
	if((node->childcount) < 2)
	{
		psyc_error_begin(node->loc);
		puts("__arrcpy requires at least 2 parameters");
		psyc_diag_end();
		psyc_exit_failure();
	}
	arrlen ::= (node->childcount) - 2;
	// first param is a pointer to something mutable
	// second param is a typename representing a type of the array
	// rest are the array values to copy...
	firstnode ::= ast_get_child(node@_, 0);
	ptr : cgv mut := cg_expr(context
	{
		.node := firstnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref ptr, prog);
	if(!ty_is(ptr.type, tytag.ptr))
	{
		psyc_error_begin(firstnode->loc);
		puts("parameter 0 to __arrcpy must be a pointer type, you have passed a ");
		putchar('"');
		putty(ptr.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	secondnode ::= ast_get_child(node@_, 1);
	if(!ast_is_expr(secondnode, ast_expr_type.symbol))
	{
		psyc_error_begin(firstnode->loc);
		puts("parameter 1 to __arrcpy must be a valid typename represented as a symbol expression");
		psyc_diag_end();
		psyc_exit_failure();
	}
	expr ::= secondnode->expr;
	sym ::= expr.symbol;
	type : ty mut := scope_parse_typename(ctx.local, sym.symbol, sym.len);
	if(ty_isbad(type))
	{
		psyc_error_begin(firstnode->loc);
		puts("parameter 1 to __arrcpy must be a valid typename - ");
		putchar('"');
		putss(sym.symbol, sym.len);
		putchar('"');
		puts(" yielded badtype");
		psyc_diag_end();
		psyc_exit_failure();
	}
	(type.qual) = (type.qual) | (tyqual.mut);

	index_list : u64 mut#2;
	deref(index_list at 0) = LLVMConstInt(LLVMInt64Type(), 0, false@s32);
	i : u64 mut;
	offset_ll : u64 mut;
	curnode : ast mut& mut;
	curval : cgv mut;
	for(i = 0, i < arrlen, i = i + 1)
	{
		deref(index_list at 1) = LLVMConstInt(cg.type(ty_getprim(primty.s64, zero), prog), i, false@s32);
		offset_ll = LLVMBuildGEP2(ir, cg.type(type, prog), ptr.ll, index_list at 1, 1, "");

		curnode = ast_get_child(node@_, 2 + i);
		
		curval = cg_expr(context
		{
			.node := curnode;
			.local := ctx.local;
		}, prog);
		
		curval = cgv_convert(curval, type, prog, curnode->loc, false, false);
		LLVMBuildStore(ir, curval.ll, offset_ll);
	}
	return cg_literal(make_literal_expr(ast_literal_expr
	{
		.type := ast_literal_type.integral;
		.integral := arrlen;
	}), ctx, prog);
};

cg_builtin_error ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	msgnode ::= ast_get_child(node@_, 0);
	msg ::= sval_node(context
	{
		.node := msgnode;
		.local := ctx.local;
	}, prog);
	if((msg.tag) != (sval_tag.literal))
	{
		psyc_error_begin(node->loc);
		puts("Invalid call to builtin - param 0 must be a literal");
		psyc_diag_end();
		psyc_exit_failure();
	}
	lit ::= msg.literal;
	if((lit.type) != (ast_literal_type.string_literal))
	{
		psyc_error_begin(node->loc);
		puts("Invalid call to builtin - param 0 must be a string literal");
		psyc_diag_end();
		psyc_exit_failure();
	}
	psyc_colour_red();
	puts("custom");
	puts(" error ");
	print_srcloc(node->loc);
	puts(": ");
	putss(lit.chars, lit.chars_len);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

== build ==
{
	add_source_file("codegen_node.psy");
	add_source_file("diag.psy");
}
