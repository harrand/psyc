_fltused : s32;

het ::= func() -> s64 weak
{
	z : s32;
	z2 : s32 mut;

	return 69;
};
zee ::= func() -> v0
{
	myarr : f32 mut[3] mut := f32[3]{1.0; 2.0; 3.0;};
	deref(myarr at 1) = 5.0;
	myarr = f32[3]{3.0; 2.0; 1.0;};
	myarr = zero;
	mystr ::= "fee fi fo fum";
};
//__myfunc(myfoo2);
//myfoo5 ::= __myfunc(5);

mystruct ::= struct
{
	member : u64;
	mem2 : u32;
};
vv : u8& := zero;

/*
myinstance : mystruct mut := mystruct
{
	.member := 50;
};
myref ::= ref myinstance;
(myref->member) = null;
goo ::= zero@u64;
*/

mycoolenum ::= enum
{
	.cool := 0;
	.epic := 1;
	.poggers := 2;
};

== build ==
{
	//fooey_glooey();
	add_source_file("tmp2.psy");
	add_link_library("Kernel32.lib");
	set_optimization(0);
	set_executable("cool_program");
}

fooey ::= macro() -> v0
{
	x ::= 5;
	y ::= 6;
	yield x;
};

{
	x = false;
	if static(false)
	{
		e();
	}
}

fooey();

do_foo ::= func(x : u64, y : u32 mut& mut, z : mystruct mut weak static) -> v0 := extern;
do_foo2 ::= func(a : u32) -> v0
{
	//x ::= 5;
	//mynestedfunc ::= func(z : s8) -> v0 := extern;
};

_psymain ::= func() -> v0
{
};

