lar : arena mut& mut;

append_link_library_string ::= func(prog : program&, str : u8 mut& mut&) -> v0
{
	oldstr ::= deref str;
	if((prog->link_library_size) == 0)
	{
		return;
	}
	// figure out how much space we need
	space_needed : u64 mut := 0;
	i : u64 mut;
	for(i = 0, i < (prog->link_library_size), i = i + 1)
	{
		space_needed = (space_needed + (deref((prog->link_library_lens) at i)) + 1);
	}
	oldlen ::= cstrlen(oldstr);
	newstr : u8 mut& := arena_push(lar, space_needed + oldlen);
	__memcpy(newstr, oldstr, oldlen);
	// turn the null terminator in the old string to a space
	deref(newstr at oldlen) = ' ';
	offset : u64 mut := 0;
	for(i = 0, i < (prog->link_library_size), i = i + 1)
	{
		curstr ::= deref((prog->link_libraries) at i);
		curlen ::= deref((prog->link_library_lens) at i);
		__memcpy(newstr at (oldlen + offset), curstr, curlen);
		deref(newstr at (oldlen + offset + curlen)) = ' ';
		offset = (offset + curlen + 1);
	}
	deref(newstr at (space_needed + oldlen - 1)) = 0;
	deref(str) = newstr;
};

link_executable ::= func(prog : program mut&) -> v0
{
};

link_library ::= func(prog : program mut&) -> v0
{
};

link ::= func(prog : program mut&) -> v0
{
	psyc_timed(psyc_stage.link);	

	initialbuf : u8 mut#7 := zero;
	__memcpy(initialbuf at 0, "hello ", 6);
	command : u8 mut& mut := initialbuf at 0;

	puts("command before: ");
	putchar('"');
	puts(command);
	putchar('"');
	putchar(10);

	append_link_library_string(prog, ref command);

	puts("command after: ");
	putchar('"');
	puts(command);
	putchar('"');
	putchar(10);
	if((prog->type) == (program_type.executable))
	{
		link_executable(prog);
	}
	if((prog->type) == (program_type.library))
	{
		link_library(prog);
	}
};

link_setup ::= func(a : arena mut&) -> v0
{
	lar = a;
};

== build ==
{
	add_source_file("diag.psy");
	add_source_file("program.psy");
	add_link_library("Kernel32.lib");
}
