cgv_conv_undef ::= func(v : cgv, to : ty) -> cgv
{
	sv ::= v.sv;
	psyc_error_begin(zero);
	puts("conversion logic not setup properly for conversion from ");
	putchar('"');
	putty(sv.type);
	putchar('"');
	puts(" to ");
	putchar('"');
	putty(to);
	putchar('"');
	puts(" - please report this as a compiler bug.");
	return zero;
};

cgv_conv_i2i ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_i2f ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_i2p ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_i2e ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_i2b ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_e2i ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_p2i ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_p2fn ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_p2p ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_fn2p ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_f2i ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_b2i ::= func(v : cgv, to : ty) -> cgv
{
	psyc_panic(srcloc_current(), "this conversion is NYI");
	return zero;
};

cgv_conv_same ::= func(v : cgv, to : ty) -> cgv
{
	return v;
};

== build ==
{
	add_source_file("codegen_value.psy");
}
