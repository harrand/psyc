mod : u64 mut;
cgar : arena mut& mut;

// LLVM IR CODE GENERATION BEGIN

// start with the absolute top-level stuff, as they rely on tables only
// and then make our way down to the simplest bits.

// node
cg_node ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;

	cg_func ::= deref(cg_node_table at ((node->type)@s64));
	return cg_func.fn(ctx, prog);
};

// expressions
cg_expr_common ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	cg_func ::= deref(cg_expr_table at ((expr.type)@s64));
	return cg_func.fn(expr, ctx, prog);
};

cg_expr ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	return cg_expr_common(node->expr, ctx, prog);
};

// decls 
cg_decl ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	decl ::= node->decl;
	// bit complicated.
	// if we are a global variable, we do the whole thing now.
	// if we are a local variable - then we have likely been hoisted to be alloca'd earlier than when the programmer actually defined us
	// in which case, we only do the alloca, and store the initialiser (if there is one) when we naturally come across it via cg_decl_stmt
	// note: if the local is a type-deduced decl, then we have no choice but to compute the initialiser.

	init_node : ast& mut;
	init_node = null;
	if((node->childcount) > 0)
	{
		init_node = ast_get_child(node@_, 0);
	}

	var : variable mut& := scope_find_variable(ctx.local, decl.name, decl.name_len)@_;
	if(var == null)
	{
		psyc_panic(node->loc, "cg_decl could not verify that the decl actually existed. severe compiler bug.");
	}

	declty : ty mut := scope_parse_typename(ctx.local, decl.typename, decl.typename_len);

	init_val : cgv mut := zero;

	if(init_node != null)
	{
		// note: if we are a local explicitly-type decl, then this is actually unnecessary and shouldnt be needed until cg_decl_stmt properly
		// however, i cant think of a way to not do this work without significantly reducing the readability of this code.
		// todo: refactor
		init_val = cg_expr(context
		{
			.node := init_node;
			.local := ctx.local;
		}, prog);
	}

	if((decl.typename_len) == cstrlen(psyc_deduced_typename))
	{
		if(cstreql_n(decl.typename, psyc_deduced_typename, decl.typename_len))
		{
			// deduced typename
			if(init_node == null)
			{
				psyc_error_begin(node->loc);
				puts("deduced-decl ");
				putchar('"');
				putss(decl.name, decl.name_len);
				putchar('"');
				puts(" was missing an initialiser. decls with deduced-typenames must always have an initialiser");
				psyc_diag_end();
				psyc_exit_failure();
			}
			declty = (init_val.type);
		}
	}

	(var->type) = declty;
	cgty ::= cg.type(declty, prog);

	if(init_node != null)
	{
		cgv_load_if_variable(ref init_val, prog);
		init_val = cgv_convert(init_val, declty, prog, node->loc);
	}
	name_zstr : u8 mut& := arena_push(cgar, 1 + (decl.name_len));
	__memcpy(name_zstr, decl.name, decl.name_len);
	deref(name_zstr at (decl.name_len)) = 0;
	if(!(var->is_global))
	{
		// local variable. cg alloca.
		(var->codegen) = LLVMBuildAlloca(ir, cgty, name_zstr);
		// remember: dont do the store until its naturally come across via cg_decl_stmt
		//if(init_node != null)
		//{
		//	LLVMBuildStore(ir, init_val.ll, var->codegen);
		//}
	}
	if(var->is_global)
	{
		// global variable. cg global.
		(var->codegen) = LLVMAddGlobal(mod, cgty, name_zstr);
		LLVMSetLinkage(var->codegen, LLVMPrivateLinkage);
		LLVMSetExternallyInitialized(var->codegen, 0);
		LLVMSetGlobalConstant(var->codegen, ty_hasqual(declty, tyqual.mut)@s32);
		if(init_node == null)
		{
			LLVMSetInitializer(var->codegen, LLVMGetUndef(cgty));
		}
		if(init_node != null)
		{
			LLVMSetInitializer(var->codegen, init_val.ll);
		}
	}
	return zero;
};


// statements

cg_expr_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	// happens to be exactly the same code as ast_type.expr, so just re-use it.
	return cg_expr(ctx, prog);
};

cg_decl_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	// note: decl stmts are always either global/local variables and nothing else.
	// globals are handled in a special way (see top-level codegen gvars)
	// locals are also handled in a special way - all local vars in a function impl are hoisted to the very top and alloca'd all at once as required by an LLVM frontend
	// for that reason, when we naturally happen across a decl stmt in the wild, we always assume the work is already done
	// thus, we just do the store.
	node ::= ctx.node;
	decl ::= node->decl;
	var : variable mut& := scope_find_variable(ctx.local, decl.name, decl.name_len)@_;
	if(var->is_global)
	{
		return zero;
	}

	init_node : ast& mut;
	init_node = null;
	if((node->childcount) > 0)
	{
		init_node = ast_get_child(node@_, 0);
	}

	if(init_node == null)
	{
		return zero;
	}

	init_val : cgv mut := cg_expr(context
	{
		.node := init_node;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref init_val, prog);
	init_val = cgv_convert(init_val, var->type, prog, init_node->loc);
	LLVMBuildStore(ir, init_val.ll, var->codegen);
	return zero;
};

cg_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	stmt ::= node->stmt;

	cg_func ::= deref(cg_stmt_table at (stmt@s64));
	return cg_func.fn(ctx, prog);
};

// now onto the lower level bits.

// literal

cg_integer_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.s64, q);
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstInt(cg.type(type, prog), lit.integral, false@s32);
		.type := type;
	};
};

cg_floating_point_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.f64, q);
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstReal(cg.type(type, prog), lit.floating_point);
		.type := type;
	};
};

cg_char_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.s8, q);

	chars ::= lit.chars;
	len ::= lit.chars_len;
	// todo: escape chars and len
	if(len != 1)
	{
		psyc_error_begin(node->loc);
		puts("char literal ");
		puts("'");
		putss(chars, len);
		puts("'");
		puts(" was of length ");
		putuint(len);
		puts(", but a char literal must have length exactly 1.");
		psyc_diag_end();
		psyc_exit_failure();
	}
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstInt(cg.type(type, prog), deref(chars at 0), false@s32);
		.type := type;
	};
};

cg_string_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	chars ::= lit.chars;
	len ::= lit.chars_len;
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstString(chars, len@_, false@s32); // let string literals be null terminated
		.type := ty_ref(ty_getprim(primty.u8, tyqual.static), zero);
	};
};

cg_bool_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.bool, q);
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstInt(cg.type(type, prog), lit.boolean, false@s32);
		.type := type;
	};
};

cg_zero_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	return cgv
	{
		.tag := cgvtag.valzero;
		.ll := 0;
		.type := zero;
	};
};

cg_literal ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	lit ::= expr.literal;

	cg_func ::= deref(cg_literal_table at ((lit.type)@s64));
	return cg_func.fn(lit, ctx, prog);
};

// symbol
cg_symbol ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	sym ::= expr.symbol;
	node ::= ctx.node;
	// most obvious choice: a variable
	maybe_var ::= scope_find_variable(ctx.local, sym.symbol, sym.len);
	if(maybe_var != null)
	{
		if(ty_isbad(maybe_var->type))
		{
			psyc_error_begin(node->loc);
			puts("type of decl ");
			putchar('"');
			putss(sym.symbol, sym.len);
			putchar('"');
			puts(" yielded badtype");
			psyc_diag_end();
			psyc_exit_failure();
		}
		if((maybe_var->codegen) == 0)
		{
			psyc_error_begin(node->loc);
			puts("internal cgv of decl ");
			putchar('"');
			putss(sym.symbol, sym.len);
			putchar('"');
			puts(" yielded .ll == 0");
			psyc_diag_end();
			psyc_exit_failure();
		}
		return cgv
		{
			.tag := cgvtag.var;
			.ll := maybe_var->codegen;
			.type := maybe_var->type;
		};
	}
	psyc_error_begin(node->loc);
	puts("unknown symbol ");
	putchar('"');
	putss(sym.symbol, sym.len);
	putchar('"');
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

// ret
cg_ret ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	parentfn ::= scope_get_parent_function(ctx.local, prog);
	if(parentfn == null)
	{
		psyc_error_begin(node->loc);
		puts("return statements are only valid within a function implementation block");
		psyc_diag_end();
		psyc_exit_failure();
	}
	fnty ::= parentfn->type;
	fnpayload ::= fnty.fn;
	fn_retty ::= deref((fnpayload.return_type)@ty&);
	// todo: get parent fn and ensure the return is suitable.
	if((node->childcount) == 0)
	{
		LLVMBuildRetVoid(ir);
	}
	if((node->childcount) == 1)
	{
		retval : cgv mut := cg_node(context
		{
			.node := ast_get_child(node@_, 0);
			.local := ctx.local;
		}, prog);
		cgv_load_if_variable(ref retval, prog);
		retval = cgv_convert(retval, fn_retty, prog, node->loc);
		// do a convert
		LLVMBuildRet(ir, retval.ll);
	}
	if((node->childcount) > 1)
	{
		psyc_panic(node->loc, "ret-expr had more than 1 child, which is wrong. compiler bug.");
	}
	s ::= ctx.local;
	(s->terminator) = node;
	return zero;
};

// biop

cg_common_process_param ::= func(param : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	pval ::= cg_node(context
	{
		.node := param;
		.local := ctx.local;
	}, prog);
	if((pval.tag) == zero)
	{
		// invalid
		psyc_error_begin(param->loc);
		puts("failed to process operand - yielded invalid value");
		psyc_diag_end();
		psyc_exit_failure();
	}
	return pval;
};

cg_biop_compare_common ::= func(lhs_val : cgv mut&, rhs_val : cgv mut&, lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> v0
{
	deref(lhs_val) = cg_common_process_param(lhs, ctx, prog);
	cgv_load_if_variable(lhs_val, prog);
	deref(rhs_val) = cg_common_process_param(rhs, ctx, prog);
	cgv_load_if_variable(rhs_val, prog);

	// select the return type.
	lhsty ::= lhs_val->type;
	if(!ty_is_integral(lhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			if(!ty_is(lhsty, tytag.ptr))
			{
				if(!ty_is(lhsty, tytag.enm))
				{
					psyc_error_begin(lhs->loc);
					puts("operator invalid because the lhs must be either an integral, floating-point, pointer or enum type, but you have passed ");
					putchar('"');
					putty(lhsty);
					putchar('"');
					psyc_diag_end();
					psyc_exit_failure();
				}
			}
		}
	}

	rhsty ::= rhs_val->type;
	if(!ty_is_integral(rhsty))
	{
		if(!ty_is_floating_point(rhsty))
		{
			if(!ty_is(rhsty, tytag.ptr))
			{
				if(!ty_is(rhsty, tytag.enm))
				{
					psyc_error_begin(rhs->loc);
					puts("operator invalid because the rhs must be either an integral, floating-point, pointer or enum type, but you have passed ");
					putchar('"');
					putty(rhsty);
					putchar('"');
					psyc_diag_end();
					psyc_exit_failure();
				}
			}
		}
	}

	// true  => rhs converts to lhs
	// false => lhs converts to rhs
	conversion_direction : bool mut := true;

	rhs_fs ::= ty_floating_point_size(rhsty);
	lhs_fs ::= ty_floating_point_size(lhsty);
	rhs_is ::= ty_integral_size(rhsty);
	lhs_is ::= ty_integral_size(lhsty);
	if(ty_is_floating_point(rhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			conversion_direction = false;
		}
		if(ty_is_floating_point(lhsty))
		{
			if(rhs_fs > lhs_fs)
			{
				conversion_direction = false;
			}
		}
	}
	if(ty_is_integral(rhsty))
	{
		if(ty_is_integral(lhsty))
		{
			if(rhs_is > lhs_is)
			{
				conversion_direction = false;
			}
		}
	}
	if(ty_is(rhsty, tytag.ptr))
	{
		if(ty_is_integral(lhsty))
		{
			conversion_direction = false;
		}
	}

	if(conversion_direction)
	{
		deref(rhs_val) = cgv_convert(deref rhs_val, lhsty, prog, rhs->loc);
	}
	if(!conversion_direction)
	{
		deref(lhs_val) = cgv_convert(deref lhs_val, rhsty, prog, rhs->loc);
	}
};

cg_biop_arith_common ::= func(lhs_val : cgv mut&, rhs_val : cgv mut&, lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> v0
{
	deref(lhs_val) = cg_common_process_param(lhs, ctx, prog);
	cgv_load_if_variable(lhs_val, prog);
	deref(rhs_val) = cg_common_process_param(rhs, ctx, prog);
	cgv_load_if_variable(rhs_val, prog);

	// select the return type.
	lhsty ::= lhs_val->type;
	if(!ty_is_integral(lhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			psyc_error_begin(lhs->loc);
			puts("operator invalid because the lhs must be either an integral or floating-point type, but you have passed ");
			putchar('"');
			putty(lhsty);
			putchar('"');
			psyc_diag_end();
			psyc_exit_failure();
		}
	}

	rhsty ::= rhs_val->type;
	if(!ty_is_integral(rhsty))
	{
		if(!ty_is_floating_point(rhsty))
		{
			psyc_error_begin(rhs->loc);
			puts("operator invalid because the rhs must be either an integral or floating-point type, but you have passed ");
			putchar('"');
			putty(rhsty);
			putchar('"');
			psyc_diag_end();
			psyc_exit_failure();
		}
	}

	// true  => rhs converts to lhs
	// false => lhs converts to rhs
	conversion_direction : bool mut := true;

	rhs_fs ::= ty_floating_point_size(rhsty);
	lhs_fs ::= ty_floating_point_size(lhsty);
	rhs_is ::= ty_integral_size(rhsty);
	lhs_is ::= ty_integral_size(lhsty);
	if(ty_is_floating_point(rhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			conversion_direction = false;
		}
		if(ty_is_floating_point(lhsty))
		{
			if(rhs_fs > lhs_fs)
			{
				conversion_direction = false;
			}
		}
	}
	if(ty_is_integral(rhsty))
	{
		if(ty_is_integral(lhsty))
		{
			if(rhs_is > lhs_is)
			{
				conversion_direction = false;
			}
		}
	}

	if(conversion_direction)
	{
		deref(rhs_val) = cgv_convert(deref rhs_val, lhsty, prog, rhs->loc);
	}
	if(!conversion_direction)
	{
		deref(lhs_val) = cgv_convert(deref lhs_val, rhsty, prog, rhs->loc);
	}
};

cg_biop_bitwise_common ::= func(lhs_val : cgv mut&, rhs_val : cgv mut&, lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> v0
{
	deref(lhs_val) = cg_common_process_param(lhs, ctx, prog);
	cgv_load_if_variable(lhs_val, prog);
	deref(rhs_val) = cg_common_process_param(rhs, ctx, prog);
	cgv_load_if_variable(rhs_val, prog);

	// select the return type.
	lhsty ::= lhs_val->type;
	if(!ty_is_integral(lhsty))
	{
		psyc_error_begin(lhs->loc);
		puts("operator invalid because the lhs must be an integral type, but you have passed ");
		putchar('"');
		putty(lhsty);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	rhsty ::= rhs_val->type;
	if(!ty_is_integral(rhsty))
	{
		psyc_error_begin(rhs->loc);
		puts("operator invalid because the rhs must be an integral type, but you have passed ");
		putchar('"');
		putty(rhsty);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	// true  => rhs converts to lhs
	// false => lhs converts to rhs
	conversion_direction : bool mut := true;

	rhs_is ::= ty_integral_size(rhsty);
	lhs_is ::= ty_integral_size(lhsty);
	if(ty_is_integral(rhsty))
	{
		if(ty_is_integral(lhsty))
		{
			if(rhs_is > lhs_is)
			{
				conversion_direction = false;
			}
		}
	}

	if(conversion_direction)
	{
		deref(rhs_val) = cgv_convert(deref rhs_val, lhsty, prog, rhs->loc);
	}
	if(!conversion_direction)
	{
		deref(lhs_val) = cgv_convert(deref lhs_val, rhsty, prog, rhs->loc);
	}
};

cg_biop_assign ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val ::= cg_common_process_param(lhs, ctx, prog);
	if(!ty_hasqual(lhs_val.type, tyqual.mut))
	{
		psyc_error_begin(lhs->loc);
		puts("invalid assignment to non-mut operand of type ");
		putchar('"');
		putty(lhs_val.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	rhs_val : cgv mut := cg_common_process_param(rhs, ctx, prog);
	cgv_load_if_variable(ref rhs_val, prog);
	rhs_val = cgv_convert(rhs_val, lhs_val.type, prog, rhs->loc);

	LLVMBuildStore(ir, rhs_val.ll, lhs_val.ll);
	return lhs_val;
};

cg_biop_compare ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_compare_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 32, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is(lhs_val.type, tytag.ptr))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 32, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is(lhs_val.type, tytag.enm))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 32, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 9, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);

	return lhs_val;
};

cg_biop_comparen ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_compare_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 33, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is(lhs_val.type, tytag.ptr))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 33, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is(lhs_val.type, tytag.enm))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 33, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 14, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);

	return lhs_val;
};

cg_biop_less_than ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		if(ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 40, lhs_val.ll, rhs_val.ll, "");
		}
		if(!ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 36, lhs_val.ll, rhs_val.ll, "");
		}
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 12, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);
	return lhs_val;
};

cg_biop_less_than_equal ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		if(ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 41, lhs_val.ll, rhs_val.ll, "");
		}
		if(!ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 37, lhs_val.ll, rhs_val.ll, "");
		}
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 13, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);
	return lhs_val;
};

cg_biop_greater_than ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		if(ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 38, lhs_val.ll, rhs_val.ll, "");
		}
		if(!ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 34, lhs_val.ll, rhs_val.ll, "");
		}
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 10, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);
	return lhs_val;
};

cg_biop_greater_than_equal ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		if(ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 39, lhs_val.ll, rhs_val.ll, "");
		}
		if(!ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildICmp(ir, 35, lhs_val.ll, rhs_val.ll, "");
		}
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 11, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);
	return lhs_val;
};

cg_biop_plus ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildAdd(ir, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFAdd(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_minus ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildSub(ir, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFSub(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	return lhs_val;
};

cg_biop_multiply ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildMul(ir, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFMul(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_divide ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		if(ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildSDiv(ir, lhs_val.ll, rhs_val.ll, "");
		}
		if(!ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildUDiv(ir, lhs_val.ll, rhs_val.ll, "");
		}
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFDiv(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_bitwise_or ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_bitwise_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	(lhs_val.ll) = LLVMBuildOr(ir, lhs_val.ll, rhs_val.ll, "");
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_logical_or ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut := cg_common_process_param(lhs, ctx, prog);
	cgv_load_if_variable(ref lhs_val, prog);
	if(!ty_is_boolean(lhs_val.type))
	{
		psyc_error_begin(lhs->loc);
		puts("binary logical OR is invalid - lhs operand must be a bool. you have provided a ");
		putchar('"');
		putty(lhs_val.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	rhs_val : cgv mut := cg_common_process_param(rhs, ctx, prog);
	cgv_load_if_variable(ref rhs_val, prog);
	if(!ty_is_boolean(rhs_val.type))
	{
		psyc_error_begin(rhs->loc);
		puts("binary logical OR is invalid - rhs operand must be a bool. you have provided a ");
		putchar('"');
		putty(rhs_val.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.ll) = LLVMBuildOr(ir, lhs_val.ll, rhs_val.ll, "");
	return lhs_val;
};

cg_biop_bitwise_and ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_bitwise_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	(lhs_val.ll) = LLVMBuildAnd(ir, lhs_val.ll, rhs_val.ll, "");
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_logical_and ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut := cg_common_process_param(lhs, ctx, prog);
	cgv_load_if_variable(ref lhs_val, prog);
	if(!ty_is_boolean(lhs_val.type))
	{
		psyc_error_begin(lhs->loc);
		puts("binary logical AND is invalid - lhs operand must be a bool. you have provided a ");
		putchar('"');
		putty(lhs_val.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	rhs_val : cgv mut := cg_common_process_param(rhs, ctx, prog);
	cgv_load_if_variable(ref rhs_val, prog);
	if(!ty_is_boolean(rhs_val.type))
	{
		psyc_error_begin(rhs->loc);
		puts("binary logical AND is invalid - rhs operand must be a bool. you have provided a ");
		putchar('"');
		putty(rhs_val.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.ll) = LLVMBuildAnd(ir, lhs_val.ll, rhs_val.ll, "");
	return lhs_val;
};

cg_biop_at ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(lhs->loc, "todo: biop at");
	return zero;
};

cg_biop_field ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	// firstly
	// rhs should be a symbol expr
	rhs_sym : ast_symbol_expr mut;
	rhs_sym = zero;
	if((rhs->type) == (ast_type.expr))
	{
		rhs_expr ::= rhs->expr;
		if((rhs_expr.type) == (ast_expr_type.symbol))
		{
			rhs_sym = (rhs_expr.symbol);
		}
	}
	if((rhs_sym.symbol) == null)
	{
		psyc_error_begin(rhs->loc);
		puts("invalid field expression - rhs must be a symbol expression");
		psyc_diag_end();
		psyc_exit_failure();
	}

	i : u64 mut;

	// then: check if lhs is a symbol expr that matches an enum name.
	// if so then we can early out as its an enum value.
	if((lhs->type) == (ast_type.expr))
	{
		lhs_expr ::= lhs->expr;
		if((lhs_expr.type) == (ast_expr_type.symbol))
		{
			lhs_sym ::= lhs_expr.symbol; 
			maybe_enum ::= scope_find_enum(ctx.local, lhs_sym.symbol, lhs_sym.len);
			if(maybe_enum != null)
			{
				// ok it *is* an enum
				// find the entry
				enumty : ty mut := maybe_enum->type;
				(enumty.qual) = ((enumty.qual) | tyqual.static);
				enumpayload ::= enumty.enm;
				for(i = 0, i < (enumpayload.entry_count), i = i + 1)
				{
					curentryname ::= deref((enumpayload.entry_names) at i);
					curentryname_len ::= deref((enumpayload.entry_name_lens) at i);
					if(curentryname_len == (rhs_sym.len))
					{
						if(cstreql_n(curentryname, rhs_sym.symbol, rhs_sym.len))
						{
							// this is that exact enum!
							value ::= deref((enumpayload.entry_values) at i);
							// return this as a literal
							ret : cgv mut := cg_literal(make_literal_expr(ast_literal_expr
							{
								.type := ast_literal_type.integral;
								.integral := value@s64;
							}), ctx, prog);
							(ret.type) = enumty;
							return ret;
						}
					}
				}
				psyc_error_begin(rhs->loc);
				puts("enum ");
				putchar('"');
				putty(enumty);
				putchar('"');
				puts(" has no entry named ");
				putchar('"');
				putss(rhs_sym.symbol, rhs_sym.len);
				putchar('"');
				psyc_diag_end();
				psyc_exit_failure();
			}
		}
	}

	lhs_val ::= cg_common_process_param(lhs, ctx, prog);
	// firstly ensure the lhs of struct type.
	lhs_ty ::= lhs_val.type;
	if(!ty_is(lhs_ty, tytag.strct))
	{
		psyc_error_begin(lhs->loc);
		puts("lhs of field expression must be a struct type - you have provided a ");
		putchar('"');
		putty(lhs_ty);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	lhs_strct ::= lhs_ty.strct;

	// get the member id.
	// if its a variable, we do a GEP to yield another variable
	// otherwise, we do an extractvalue to yield a misc
	memtypes ::= (lhs_strct.member_types)@ty&;
	memnames ::= (lhs_strct.member_names);
	memname_lens ::= (lhs_strct.member_name_lens);
	selected_memidx : u64 mut := -1;
	selected_memty : ty mut := zero;
	selected_memname : u8& mut := null;
	selected_memname_len : u64 mut := 0;

	for(i = 0, i < (lhs_strct.member_count), i = i + 1)
	{
		memty ::= deref(memtypes at i);
		memname ::= deref(memnames at i);
		memname_len ::= deref(memname_lens at i);
		if((rhs_sym.len) == memname_len)
		{
			if(cstreql_n(rhs_sym.symbol, memname, memname_len))
			{
				// this is the member.
				selected_memidx = i;
				selected_memty = memty;
				selected_memname = memname;
				selected_memname_len = memname_len;
			}
		}
	}

	if(selected_memidx == -1)
	{
		psyc_error_begin(rhs->loc);
		puts("struct ");
		putchar('"');
		putty(lhs_ty);
		putchar('"');
		puts(" had no such member named ");
		putchar('"');
		putss(rhs_sym.symbol, rhs_sym.len);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	(selected_memty.qual) = (lhs_ty.qual);

	if((lhs_val.tag) == (cgvtag.var))
	{
		// variable! ll should be an alloca or GEP'd alloca
		// which means we should GEP that and return var
		return cgv
		{
			.tag := cgvtag.var;
			.ll := LLVMBuildStructGEP2(ir, cg.type(lhs_ty, prog), lhs_val.ll, selected_memidx@u32, "");
			.type := selected_memty;
		};
	}
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMBuildExtractValue(ir, lhs_val.ll, selected_memidx@u32, "");
		.type := selected_memty;
	};
};

cg_biop_ptr_field ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(lhs->loc, "todo: biop ptr_field");
	return zero;
};

cg_biop_cast ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut := cg_common_process_param(lhs, ctx, prog);
	cgv_load_if_variable(ref lhs_val, prog);
	rhs_sym : ast_symbol_expr mut;
	rhs_sym = zero;
	if((rhs->type) == (ast_type.expr))
	{
		rhs_expr ::= rhs->expr;
		if((rhs_expr.type) == (ast_expr_type.symbol))
		{
			rhs_sym = (rhs_expr.symbol);
		}
	}
	if((rhs_sym.symbol) == null)
	{
		psyc_error_begin(rhs->loc);
		puts("invalid cast - rhs must be a symbol expression");
		psyc_diag_end();
		psyc_exit_failure();
	}
	// make lhs weak
	lhs_ty : ty mut := lhs_val.type;
	(lhs_ty.qual) = (lhs_ty.qual) | (tyqual.weak);
	(lhs_val.type) = lhs_ty;
	if(!cgv_is_zero(lhs_val))
	{
		(lhs_val.tag) = (cgvtag.misc);
	}

	// is it the weakening idiom? then just return the weakened type
	weakening_idiom ::= "_";
	if((rhs_sym.len) == cstrlen(weakening_idiom))
	{
		if(cstreql_n(rhs_sym.symbol, weakening_idiom, rhs_sym.len))
		{
			// weakening idiom
			// just return lhs_val but make its type weak
			return lhs_val;
		}
	}

	// else, do the conversion.
	rhs_ty ::= scope_parse_typename(ctx.local, rhs_sym.symbol, rhs_sym.len);
	if(ty_isbad(rhs_ty))
	{
		psyc_error_begin(rhs->loc);
		puts("rhs of cast ");
		putchar('"');
		putss(rhs_sym.symbol, rhs_sym.len);
		putchar('"');
		puts(" yielded badtype");
		psyc_diag_end();
		psyc_exit_failure();
	}
	lhs_val = cgv_convert(lhs_val, rhs_ty, prog, lhs->loc);
	return lhs_val;
};

cg_biop ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	biop ::= expr.biop;
	biop_ty ::= biop.type;
	node ::= ctx.node;

	lhs ::= ast_biop_get_lhs(deref node);
	rhs ::= ast_biop_get_rhs(deref node);

	cg_func ::= deref(cg_biop_table at (biop_ty@s64));
	return cg_func.fn(lhs, rhs, ctx, prog);
};

cg_unop_minus ::= func(operand : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	opval : cgv mut := cg_common_process_param(operand, ctx, prog);
	cgv_load_if_variable(ref opval, prog);
	if(!ty_is_integral(opval.type))
	{
		if(!ty_is_floating_point(opval.type))
		{
			psyc_error_begin(operand->loc);
			puts("unary minus is invalid - operand must be either an integral or floating point type. you have provided a ");
			putchar('"');
			putty(opval.type);
			putchar('"');
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
	if(ty_is_integral(opval.type))
	{
		(opval.ll) = LLVMBuildNeg(ir, opval.ll, "");
	}
	if(ty_is_floating_point(opval.type))
	{
		(opval.ll) = LLVMBuildFNeg(ir, opval.ll, "");
	}
	(opval.tag) = (cgvtag.misc);
	return opval;
};

cg_unop_bitwise_invert ::= func(operand : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	opval : cgv mut := cg_common_process_param(operand, ctx, prog);
	cgv_load_if_variable(ref opval, prog);
	if(!ty_is_integral(opval.type))
	{
		psyc_error_begin(operand->loc);
		puts("unary bitwise invert is invalid - operand must be an integral type. you have provided a ");
		putchar('"');
		putty(opval.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	(opval.ll) = LLVMBuildNot(ir, opval.ll, "");
	(opval.tag) = (cgvtag.misc);
	return opval;
};

cg_unop_logical_invert ::= func(operand : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	opval : cgv mut := cg_common_process_param(operand, ctx, prog);
	cgv_load_if_variable(ref opval, prog);
	if(!ty_is_boolean(opval.type))
	{
		psyc_error_begin(operand->loc);
		puts("unary logical invert is invalid - operand must be a bool. you have provided a ");
		putchar('"');
		putty(opval.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	(opval.ll) = LLVMBuildNot(ir, opval.ll, "");
	(opval.tag) = (cgvtag.misc);
	return opval;
};

cg_unop_ref ::= func(operand : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	// this ones really easy. get the operand, do *not* load it, but pretend you already have.
	opval : cgv mut := cg_common_process_param(operand, ctx, prog);
	if((opval.tag) != (cgvtag.var))
	{
		psyc_error_begin(operand->loc);
		puts("unary ref is invalid - you can only retrieve the address of an lvalue");
		psyc_diag_end();
		psyc_exit_failure();
	}
	// sneakily move the tag to misc even though i didnt load it.
	(opval.tag) = (cgvtag.misc);
	(opval.type) = ty_ref(opval.type, zero);

	return opval;
};

cg_unop_deref ::= func(operand : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	opval : cgv mut := cg_common_process_param(operand, ctx, prog);
	cgv_load_if_variable(ref opval, prog);
	if(!ty_is(opval.type, tytag.ptr))
	{
		psyc_error_begin(operand->loc);
		puts("unary deref is invalid - you can only deref a pointer type, you have provided a ");
		putchar('"');
		putty(opval.type);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	(opval.tag) = (cgvtag.misc);
	(opval.type) = ty_deref(opval.type);
	(opval.ll) = LLVMBuildLoad2(ir, cg.type(opval.type, prog), opval.ll, "");
	return opval;
};

cg_unop_defer ::= func(operand : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(operand->loc, "unop defer NYI");
	return zero;
};

cg_unop ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	unop ::= expr.unop;
	unop_ty ::= unop.type;
	node ::= ctx.node;

	operand ::= ast_unop_get_operand(deref node);

	cg_func ::= deref(cg_unop_table at (unop_ty@s64));
	return cg_func.fn(operand, ctx, prog);
};

// callfunc
cg_callfunc ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	call ::= expr.callfunc;

	fn ::= scope_find_function(ctx.local, call.funcname, call.funcname_len);
	if(fn == null)
	{
		psyc_error_begin(node->loc);
		puts("invalid call to unknown function ");
		putchar('"');
		putss(call.funcname, call.funcname_len);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	call_param_count ::= node->childcount;

	fnty ::= fn->type;
	fnpayload ::= fnty.fn;
	fnparamtys ::= (fnpayload.param_types)@ty&;
	if(call_param_count != (fnpayload.param_count))
	{
		psyc_error_begin(node->loc);
		puts("invalid call to function ");
		putchar('"');
		putss(call.funcname, call.funcname_len);
		putchar('"');
		puts(" - you provided ");
		putuint(call_param_count);
		puts(" params, but it expected ");
		putuint(fnpayload.param_count);
		psyc_diag_end();
		psyc_exit_failure();
	}

	ll_args : u64 mut& := arena_push(cgar, __sizeof(u64) * call_param_count);

	i : u64 mut;
	paramnode : ast& mut;
	reqty : ty mut;
	param_val : cgv mut;
	for(i = 0, i < call_param_count, i = i + 1)
	{
		reqty = deref(fnparamtys at i);
		paramnode = ast_get_child(node@_, i);
		param_val = cg_expr(context
		{
			.node := paramnode;
			.local := ctx.local;
		}, prog);
		cgv_load_if_variable(ref param_val, prog);
		param_val = cgv_convert(param_val, reqty, prog, paramnode->loc);
		deref(ll_args at i) = (param_val.ll);
	}

	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMBuildCall2(ir, cg.type(fnty, prog), fn->codegen, ll_args, call_param_count@u32, "");
		.type := deref((fnpayload.return_type)@ty&);
	};
};

cg_if_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	ifdef ::= node->ifdef;
	if(ifdef.is_static)
	{
		return zero;
	}
	condnode ::= ast_get_child(node@_, 0);
	condval : cgv mut := cg_expr(context
	{
		.node := condnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref condval, prog);
	condval = cgv_convert(condval, ty_getprim(primty.bool, zero), prog, condnode->loc);

	else_node : ast& mut;
	else_node = null;
	if(node->childcount > 1)
	{
		lastchildidx ::= (node->childcount) - 1;
		last_child ::= ast_get_child(node@_, lastchildidx);
		if((last_child->type) == (ast_type.elsedef))
		{
			else_node = last_child;
		}
	}

	fn ::= scope_get_parent_function(ctx.local, prog);

	oldblk ::= LLVMGetInsertBlock(ir);

	if_scope_label ::= "if";
	ifscope ::= program_new_scope(prog, cgar, ctx.local, scope_type.code, node->loc, if_scope_label, cstrlen(if_scope_label));
	(ifscope->codegen) = LLVMAppendBasicBlock(fn->codegen, if_scope_label);

	// populate the else blk if there is one
	ifnt : u64 mut := 0;

	else_scope_label ::= "else";
	elsescope : scope mut& mut := null;
	if(else_node != null)
	{
		elsescope = program_new_scope(prog, cgar, ctx.local, scope_type.code, node->loc, else_scope_label, cstrlen(else_scope_label));
		ifnt = LLVMAppendBasicBlock(fn->codegen, else_scope_label);
	}

	ifcont ::= LLVMAppendBasicBlock(fn->codegen, "ifcont");
	if(else_node == null)
	{
		ifnt = ifcont;
	}

	// populate inside the if blk
	LLVMPositionBuilderAtEnd(ir, ifscope->codegen);
	ifscope_back_offset : u64 mut;
	ifscope_back_offset = 0;
	if(else_node != null)
	{
		ifscope_back_offset = 1;
	}
	cg.children(context
	{
		.node := node;
		.local := ifscope;
	}, prog, 1, ifscope_back_offset);
	// note: only branch to ifcont if the if blk didnt contain a terminator (e.g early return)
	if((ifscope->terminator) == null)
	{
		LLVMBuildBr(ir, ifcont);
	}

	if(else_node != null)
	{
		LLVMPositionBuilderAtEnd(ir, ifnt);
		cg.children(context
		{
			.node := else_node;
			.local := elsescope;
		}, prog, 0, 0);
		if((elsescope->terminator) == null)
		{
			LLVMBuildBr(ir, ifcont);
		}
	}

	// build the condbr
	LLVMPositionBuilderAtEnd(ir, oldblk);
	LLVMBuildCondBr(ir, condval.ll, ifscope->codegen, ifnt);

	// rest of code...
	LLVMPositionBuilderAtEnd(ir, ifcont);
	return zero;
};

cg_while_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;

	condnode ::= ast_get_child(node@_, 0);
	condval : cgv mut := cg_expr(context
	{
		.node := condnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref condval, prog);
	condval = cgv_convert(condval, ty_getprim(primty.bool, zero), prog, condnode->loc);

	fn ::= scope_get_parent_function(ctx.local, prog);

	oldblk ::= LLVMGetInsertBlock(ir);

	while_scope_label ::= "while";
	whilescope ::= program_new_scope(prog, cgar, ctx.local, scope_type.code, node->loc, while_scope_label, cstrlen(while_scope_label));
	(whilescope->codegen) = LLVMAppendBasicBlock(fn->codegen, while_scope_label);

	whilecont ::= LLVMAppendBasicBlock(fn->codegen, "whilecont");

	// populate inside the while blk
	LLVMPositionBuilderAtEnd(ir, whilescope->codegen);
	cg.children(context
	{
		.node := node;
		.local := whilescope;
	}, prog, 1, 0);
	// note: only branch to ifcont if the if blk didnt contain a terminator (e.g early return)
	if((whilescope->terminator) == null)
	{
		// conditional branch
		// condition still true? back to while
		// false? whilecont
		inner_condval : cgv mut := cg_expr(context
		{
			.node := condnode;
			.local := ctx.local;
		}, prog);
		cgv_load_if_variable(ref inner_condval, prog);
		inner_condval = cgv_convert(inner_condval, ty_getprim(primty.bool, zero), prog, condnode->loc);
		LLVMBuildCondBr(ir, inner_condval.ll, whilescope->codegen, whilecont);
	}

	// build the condbr
	LLVMPositionBuilderAtEnd(ir, oldblk);
	LLVMBuildCondBr(ir, condval.ll, whilescope->codegen, whilecont);

	// rest of code...
	LLVMPositionBuilderAtEnd(ir, whilecont);
	return zero;
};

cg_for_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;

	initnode ::= ast_get_child(node@_, 0);
	// do the init a single time now.
	cg_expr(context
	{
		.node := initnode;
		.local := ctx.local;
	}, prog);

	// get the cond intially now
	condnode ::= ast_get_child(node@_, 1);
	condval : cgv mut := cg_expr(context
	{
		.node := condnode;
		.local := ctx.local;
	}, prog);
	cgv_load_if_variable(ref condval, prog);
	condval = cgv_convert(condval, ty_getprim(primty.bool, zero), prog, condnode->loc);

	iternode ::= ast_get_child(node@_, 2);

	fn ::= scope_get_parent_function(ctx.local, prog);

	oldblk ::= LLVMGetInsertBlock(ir);

	for_scope_label ::= "for";
	forscope ::= program_new_scope(prog, cgar, ctx.local, scope_type.code, node->loc, for_scope_label, cstrlen(for_scope_label));
	(forscope->codegen) = LLVMAppendBasicBlock(fn->codegen, for_scope_label);

	forcont ::= LLVMAppendBasicBlock(fn->codegen, "forcont");

	// populate inside the for blk
	LLVMPositionBuilderAtEnd(ir, forscope->codegen);
	cg.children(context
	{
		.node := node;
		.local := forscope;
	}, prog, 3, 0);
	// note: only branch to ifcont if the if blk didnt contain a terminator (e.g early return)
	if((forscope->terminator) == null)
	{
		// remember - if the forscope contains a terminator return then there's no point doing the init anyway.
		// do the iter
		cg_expr(context
		{
			.node := iternode;
			.local := forscope;
		}, prog);
		// conditional branch
		// condition still true? back to for
		// false? forcont
		inner_condval : cgv mut := cg_expr(context
		{
			.node := condnode;
			.local := ctx.local;
		}, prog);
		cgv_load_if_variable(ref inner_condval, prog);
		inner_condval = cgv_convert(inner_condval, ty_getprim(primty.bool, zero), prog, condnode->loc);
		LLVMBuildCondBr(ir, inner_condval.ll, forscope->codegen, forcont);
	}

	// build the condbr
	LLVMPositionBuilderAtEnd(ir, oldblk);
	LLVMBuildCondBr(ir, condval.ll, forscope->codegen, forcont);

	// rest of code...
	LLVMPositionBuilderAtEnd(ir, forcont);
	return zero;
};

// LLVM IR CODE GENERATION END

codegen_node_setup ::= func(a : arena mut&, h : cg_helper_functions) -> v0
{
	cgar = a;
	cg = h;
	i : u64 mut;

	// populate tables
	cg_node_table_size ::= __sizeof(cg_node_table) / __sizeof(deref(cg_node_table at 0));
	for(i = 0, i < cg_node_table_size, i = i + 1)
	{
		deref(cg_node_table at i) = cg_node_fn{.fn := cg_nodefn_error;};
	}
	deref(cg_node_table at ((ast_type.stmt)@s64)) = cg_node_fn{.fn := cg_stmt;};
	deref(cg_node_table at ((ast_type.expr)@s64)) = cg_node_fn{.fn := cg_expr;};

	cg_stmt_table_size ::= __sizeof(cg_stmt_table) / __sizeof(deref(cg_stmt_table at 0));
	for(i = 0, i < cg_stmt_table_size, i = i + 1)
	{
		deref(cg_stmt_table at i) = cg_stmt_fn{.fn := cg_stmtfn_error;};
	}
	deref(cg_stmt_table at ((ast_stmt.expr_stmt)@s64)) = cg_stmt_fn{.fn := cg_expr_stmt;};
	deref(cg_stmt_table at ((ast_stmt.decl_stmt)@s64)) = cg_stmt_fn{.fn := cg_decl_stmt;};
	deref(cg_stmt_table at ((ast_stmt.if_stmt)@s64)) = cg_stmt_fn{.fn := cg_if_stmt;};
	deref(cg_stmt_table at ((ast_stmt.while_stmt)@s64)) = cg_stmt_fn{.fn := cg_while_stmt;};
	deref(cg_stmt_table at ((ast_stmt.for_stmt)@s64)) = cg_stmt_fn{.fn := cg_for_stmt;};

	cg_expr_table_size ::= __sizeof(cg_expr_table) / __sizeof(deref(cg_expr_table at 0));
	for(i = 0, i < cg_expr_table_size, i = i + 1)
	{
		deref(cg_expr_table at i) = cg_expr_fn{.fn := cg_exprfn_error;};
	}
	deref(cg_expr_table at ((ast_expr_type.symbol)@s64)) = cg_expr_fn{.fn := cg_symbol;};
	deref(cg_expr_table at ((ast_expr_type.biop)@s64)) = cg_expr_fn{.fn := cg_biop;};
	deref(cg_expr_table at ((ast_expr_type.unop)@s64)) = cg_expr_fn{.fn := cg_unop;};
	deref(cg_expr_table at ((ast_expr_type.literal)@s64)) = cg_expr_fn{.fn := cg_literal;};
	deref(cg_expr_table at ((ast_expr_type.ret)@s64)) = cg_expr_fn{.fn := cg_ret;};
	deref(cg_expr_table at ((ast_expr_type.callfunc)@s64)) = cg_expr_fn{.fn := cg_callfunc;};

	cg_biop_table_size ::= __sizeof(cg_biop_table) / __sizeof(deref(cg_biop_table at 0));
	for(i = 0, i < cg_biop_table_size, i = i + 1)
	{
		deref(cg_biop_table at i) = cg_biop_fn{.fn := cg_biopfn_error;};
	}
	deref(cg_biop_table at ((ast_biop_type.assign)@s64)) = cg_biop_fn{.fn := cg_biop_assign;};
	deref(cg_biop_table at ((ast_biop_type.compare)@s64)) = cg_biop_fn{.fn := cg_biop_compare;};
	deref(cg_biop_table at ((ast_biop_type.comparen)@s64)) = cg_biop_fn{.fn := cg_biop_comparen;};
	deref(cg_biop_table at ((ast_biop_type.less_than)@s64)) = cg_biop_fn{.fn := cg_biop_less_than;};
	deref(cg_biop_table at ((ast_biop_type.less_than_equal)@s64)) = cg_biop_fn{.fn := cg_biop_less_than_equal;};
	deref(cg_biop_table at ((ast_biop_type.greater_than)@s64)) = cg_biop_fn{.fn := cg_biop_greater_than;};
	deref(cg_biop_table at ((ast_biop_type.greater_than_equal)@s64)) = cg_biop_fn{.fn := cg_biop_greater_than_equal;};
	deref(cg_biop_table at ((ast_biop_type.plus)@s64)) = cg_biop_fn{.fn := cg_biop_plus;};
	deref(cg_biop_table at ((ast_biop_type.minus)@s64)) = cg_biop_fn{.fn := cg_biop_minus;};
	deref(cg_biop_table at ((ast_biop_type.multiply)@s64)) = cg_biop_fn{.fn := cg_biop_multiply;};
	deref(cg_biop_table at ((ast_biop_type.divide)@s64)) = cg_biop_fn{.fn := cg_biop_divide;};
	deref(cg_biop_table at ((ast_biop_type.bitwise_or)@s64)) = cg_biop_fn{.fn := cg_biop_bitwise_or;};
	deref(cg_biop_table at ((ast_biop_type.logical_or)@s64)) = cg_biop_fn{.fn := cg_biop_logical_or;};
	deref(cg_biop_table at ((ast_biop_type.bitwise_and)@s64)) = cg_biop_fn{.fn := cg_biop_bitwise_and;};
	deref(cg_biop_table at ((ast_biop_type.logical_and)@s64)) = cg_biop_fn{.fn := cg_biop_logical_and;};
	deref(cg_biop_table at ((ast_biop_type.operator_at)@s64)) = cg_biop_fn{.fn := cg_biop_at;};
	deref(cg_biop_table at ((ast_biop_type.field)@s64)) = cg_biop_fn{.fn := cg_biop_field;};
	deref(cg_biop_table at ((ast_biop_type.ptr_field)@s64)) = cg_biop_fn{.fn := cg_biop_ptr_field;};
	deref(cg_biop_table at ((ast_biop_type.cast)@s64)) = cg_biop_fn{.fn := cg_biop_cast;};

	cg_unop_table_size ::= __sizeof(cg_unop_table) / __sizeof(deref(cg_unop_table at 0));
	for(i = 0, i < cg_unop_table_size, i = i + 1)
	{
		deref(cg_unop_table at i) = cg_unop_fn{.fn := cg_unopfn_error;};
	}
	deref(cg_unop_table at ((ast_unop_type.minus)@s64)) = cg_unop_fn{.fn := cg_unop_minus;};
	deref(cg_unop_table at ((ast_unop_type.bitwise_invert)@s64)) = cg_unop_fn{.fn := cg_unop_bitwise_invert;};
	deref(cg_unop_table at ((ast_unop_type.logical_invert)@s64)) = cg_unop_fn{.fn := cg_unop_logical_invert;};
	deref(cg_unop_table at ((ast_unop_type.op_ref)@s64)) = cg_unop_fn{.fn := cg_unop_ref;};
	deref(cg_unop_table at ((ast_unop_type.op_deref)@s64)) = cg_unop_fn{.fn := cg_unop_deref;};
	deref(cg_unop_table at ((ast_unop_type.op_defer)@s64)) = cg_unop_fn{.fn := cg_unop_defer;};

	cg_literal_table_size ::= __sizeof(cg_literal_table) / __sizeof(deref(cg_literal_table at 0));
	for(i = 0, i < cg_literal_table_size, i = i + 1)
	{
		deref(cg_literal_table at i) = cg_literal_fn{.fn := cg_literalfn_error;};
	}
	deref(cg_literal_table at ((ast_literal_type.integral)@s64)) = cg_literal_fn{.fn := cg_integer_literal;};
	deref(cg_literal_table at ((ast_literal_type.floating_point)@s64)) = cg_literal_fn{.fn := cg_floating_point_literal;};
	deref(cg_literal_table at ((ast_literal_type.char_literal)@s64)) = cg_literal_fn{.fn := cg_char_literal;};
	deref(cg_literal_table at ((ast_literal_type.string_literal)@s64)) = cg_literal_fn{.fn := cg_string_literal;};
	deref(cg_literal_table at ((ast_literal_type.bool_literal)@s64)) = cg_literal_fn{.fn := cg_bool_literal;};
	deref(cg_literal_table at ((ast_literal_type.zero_literal)@s64)) = cg_literal_fn{.fn := cg_zero_literal;};
};

== build ==
{
	add_source_file("codegen_tables.psy");
	add_source_file("llvm.psy");
	add_source_file("program.psy");
}
