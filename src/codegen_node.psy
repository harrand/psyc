mod : u64 mut;
cgar : arena mut& mut;

// LLVM IR CODE GENERATION BEGIN

// start with the absolute top-level stuff, as they rely on tables only
// and then make our way down to the simplest bits.

// node
cg_node ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;

	cg_func ::= deref(cg_node_table at ((node->type)@s64));
	return cg_func.fn(ctx, prog);
};

// expressions
cg_expr_common ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	cg_func ::= deref(cg_expr_table at ((expr.type)@s64));
	return cg_func.fn(expr, ctx, prog);
};

cg_expr ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	return cg_expr_common(node->expr, ctx, prog);
};

// decls 
cg_decl ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	decl ::= node->decl;

	init_node : ast& mut;
	init_node = null;
	if((node->childcount) > 0)
	{
		init_node = ast_get_child(node@_, 0);
	}

	var : variable mut& := scope_find_variable(ctx.local, decl.name, decl.name_len)@_;
	if(var == null)
	{
		psyc_panic(node->loc, "cg_decl could not verify that the decl actually existed. severe compiler bug.");
	}

	declty : ty mut := scope_parse_typename(ctx.local, decl.typename, decl.typename_len);

	init_val : cgv mut := zero;

	if(init_node != null)
	{
		init_val = cg_expr(context
		{
			.node := init_node;
			.local := ctx.local;
		}, prog);
	}

	if((decl.typename_len) == cstrlen(psyc_deduced_typename))
	{
		if(cstreql_n(decl.typename, psyc_deduced_typename, decl.typename_len))
		{
			// deduced typename
			if(init_node == null)
			{
				psyc_error_begin(node->loc);
				puts("deduced-decl ");
				putchar('"');
				putss(decl.name, decl.name_len);
				putchar('"');
				puts(" was missing an initialiser. decls with deduced-typenames must always have an initialiser");
				psyc_diag_end();
				psyc_exit_failure();
			}
			declty = (init_val.type);
		}
	}

	(var->type) = declty;
	cgty ::= cg.type(declty, prog);

	if(init_node != null)
	{
		cgv_load_if_variable(ref init_val, prog);
		init_val = cgv_convert(init_val, declty, prog, node->loc);
	}
	name_zstr : u8 mut& := arena_push(cgar, 1 + (decl.name_len));
	__memcpy(name_zstr, decl.name, decl.name_len);
	deref(name_zstr at (decl.name_len)) = 0;
	if(!(var->is_global))
	{
		// local variable. cg alloca.
		(var->codegen) = LLVMBuildAlloca(ir, cgty, name_zstr);
		if(init_node != null)
		{
			LLVMBuildStore(ir, init_val.ll, var->codegen);
		}
	}
	if(var->is_global)
	{
		// global variable. cg global.
		(var->codegen) = LLVMAddGlobal(mod, cgty, name_zstr);
		LLVMSetLinkage(var->codegen, LLVMPrivateLinkage);
		LLVMSetExternallyInitialized(var->codegen, 0);
		LLVMSetGlobalConstant(var->codegen, ty_hasqual(declty, tyqual.mut)@s32);
		if(init_node == null)
		{
			LLVMSetInitializer(var->codegen, LLVMGetUndef(cgty));
		}
		if(init_node != null)
		{
			LLVMSetInitializer(var->codegen, init_val.ll);
		}
	}
	return zero;
};


// statements

cg_expr_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	// happens to be exactly the same code as ast_type.expr, so just re-use it.
	return cg_expr(ctx, prog);
};

cg_decl_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	// note: decl stmts are always either global/local variables and nothing else.
	// globals are handled in a special way (see top-level codegen gvars)
	// locals are also handled in a special way - all local vars in a function impl are hoisted to the very top and alloca'd all at once as required by an LLVM frontend
	// for that reason, when we naturally happen across a decl stmt in the wild, we always assume the work is already done
	// thus, we just do the store.

	return zero;
};

cg_stmt ::= func(ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	stmt ::= node->stmt;

	cg_func ::= deref(cg_stmt_table at (stmt@s64));
	return cg_func.fn(ctx, prog);
};

// now onto the lower level bits.

// literal

cg_integer_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.s64, q);
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstInt(cg.type(type, prog), lit.integral, false@s32);
		.type := type;
	};
};

cg_floating_point_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.f64, q);
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstReal(cg.type(type, prog), lit.floating_point);
		.type := type;
	};
};

cg_char_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.s8, q);

	chars ::= lit.chars;
	len ::= lit.chars_len;
	// todo: escape chars and len
	if(len != 1)
	{
		psyc_error_begin(node->loc);
		puts("char literal ");
		puts("'");
		putss(chars, len);
		puts("'");
		puts(" was of length ");
		putuint(len);
		puts(", but a char literal must have length exactly 1.");
		psyc_diag_end();
		psyc_exit_failure();
	}
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstInt(cg.type(type, prog), deref(chars at 0), false@s32);
		.type := type;
	};
};

cg_string_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	chars ::= lit.chars;
	len ::= lit.chars_len;
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstString(chars, len@_, false@s32); // let string literals be null terminated
		.type := ty_ref(ty_getprim(primty.u8, tyqual.static), zero);
	};
};

cg_bool_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	q ::= (tyqual.static) | (tyqual.weak);
	type ::= ty_getprim(primty.bool, q);
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMConstInt(cg.type(type, prog), lit.boolean, false@s32);
		.type := type;
	};
};

cg_zero_literal ::= func(lit : ast_literal_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	return cgv
	{
		.tag := cgvtag.valzero;
		.ll := 0;
		.type := zero;
	};
};

cg_literal ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	lit ::= expr.literal;

	cg_func ::= deref(cg_literal_table at ((lit.type)@s64));
	return cg_func.fn(lit, ctx, prog);
};

// symbol
cg_symbol ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	sym ::= expr.symbol;
	node ::= ctx.node;
	// most obvious choice: a variable
	maybe_var ::= scope_find_variable(ctx.local, sym.symbol, sym.len);
	if(maybe_var != null)
	{
		if(ty_isbad(maybe_var->type))
		{
			psyc_error_begin(node->loc);
			puts("type of decl ");
			putchar('"');
			putss(sym.symbol, sym.len);
			putchar('"');
			puts(" yielded badtype");
			psyc_diag_end();
			psyc_exit_failure();
		}
		if((maybe_var->codegen) == 0)
		{
			psyc_error_begin(node->loc);
			puts("internal cgv of decl ");
			putchar('"');
			putss(sym.symbol, sym.len);
			putchar('"');
			puts(" yielded .ll == 0");
			psyc_diag_end();
			psyc_exit_failure();
		}
		return cgv
		{
			.tag := cgvtag.var;
			.ll := maybe_var->codegen;
			.type := maybe_var->type;
		};
	}
	psyc_error_begin(node->loc);
	puts("unknown symbol ");
	putchar('"');
	putss(sym.symbol, sym.len);
	putchar('"');
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

// ret
cg_ret ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	node ::= ctx.node;
	parentfn ::= scope_get_parent_function(ctx.local, prog);
	if(parentfn == null)
	{
		psyc_error_begin(node->loc);
		puts("return statements are only valid within a function implementation block");
		psyc_diag_end();
		psyc_exit_failure();
	}
	fnty ::= parentfn->type;
	fnpayload ::= fnty.fn;
	fn_retty ::= deref((fnpayload.return_type)@ty&);
	// todo: get parent fn and ensure the return is suitable.
	if((node->childcount) == 0)
	{
		LLVMBuildRetVoid(ir);
	}
	if((node->childcount) == 1)
	{
		retval : cgv mut := cg_node(context
		{
			.node := ast_get_child(node@_, 0);
			.local := ctx.local;
		}, prog);
		cgv_load_if_variable(ref retval, prog);
		retval = cgv_convert(retval, fn_retty, prog, node->loc);
		// do a convert
		LLVMBuildRet(ir, retval.ll);
	}
	if((node->childcount) > 1)
	{
		psyc_panic(node->loc, "ret-expr had more than 1 child, which is wrong. compiler bug.");
	}
	s ::= ctx.local;
	(s->terminator) = node;
	return zero;
};

// biop

cg_biop_process_param ::= func(param : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	pval ::= cg_node(context
	{
		.node := param;
		.local := ctx.local;
	}, prog);
	if((pval.tag) == zero)
	{
		// invalid
		psyc_error_begin(param->loc);
		puts("failed to process operand - yielded invalid value");
		psyc_diag_end();
		psyc_exit_failure();
	}
	return pval;
};

cg_biop_compare_common ::= func(lhs_val : cgv mut&, rhs_val : cgv mut&, lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> v0
{
	deref(lhs_val) = cg_biop_process_param(lhs, ctx, prog);
	cgv_load_if_variable(lhs_val, prog);
	deref(rhs_val) = cg_biop_process_param(rhs, ctx, prog);
	cgv_load_if_variable(rhs_val, prog);

	// select the return type.
	lhsty ::= lhs_val->type;
	if(!ty_is_integral(lhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			if(!ty_is(lhsty, tytag.ptr))
			{
				psyc_error_begin(lhs->loc);
				puts("operator invalid because the lhs must be either an integral, floating-point or pointer type, but you have passed ");
				putchar('"');
				putty(lhsty);
				putchar('"');
				psyc_diag_end();
				psyc_exit_failure();
			}
		}
	}

	rhsty ::= rhs_val->type;
	if(!ty_is_integral(rhsty))
	{
		if(!ty_is_floating_point(rhsty))
		{
			if(!ty_is(rhsty, tytag.ptr))
			{
				psyc_error_begin(rhs->loc);
				puts("operator invalid because the rhs must be either an integral, floating-point or pointer type, but you have passed ");
				putchar('"');
				putty(rhsty);
				putchar('"');
				psyc_diag_end();
				psyc_exit_failure();
			}
		}
	}

	// true  => rhs converts to lhs
	// false => lhs converts to rhs
	conversion_direction : bool mut := true;

	rhs_fs ::= ty_floating_point_size(rhsty);
	lhs_fs ::= ty_floating_point_size(lhsty);
	rhs_is ::= ty_integral_size(rhsty);
	lhs_is ::= ty_integral_size(lhsty);
	if(ty_is_floating_point(rhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			conversion_direction = false;
		}
		if(ty_is_floating_point(lhsty))
		{
			if(rhs_fs > lhs_fs)
			{
				conversion_direction = false;
			}
		}
	}
	if(ty_is_integral(rhsty))
	{
		if(ty_is_integral(lhsty))
		{
			if(rhs_is > lhs_is)
			{
				conversion_direction = false;
			}
		}
	}
	if(ty_is(rhsty, tytag.ptr))
	{
		if(ty_is_integral(lhsty))
		{
			conversion_direction = false;
		}
	}

	if(conversion_direction)
	{
		deref(rhs_val) = cgv_convert(deref rhs_val, lhsty, prog, rhs->loc);
	}
	if(!conversion_direction)
	{
		deref(lhs_val) = cgv_convert(deref lhs_val, rhsty, prog, rhs->loc);
	}
};

cg_biop_arith_common ::= func(lhs_val : cgv mut&, rhs_val : cgv mut&, lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> v0
{
	deref(lhs_val) = cg_biop_process_param(lhs, ctx, prog);
	cgv_load_if_variable(lhs_val, prog);
	deref(rhs_val) = cg_biop_process_param(rhs, ctx, prog);
	cgv_load_if_variable(rhs_val, prog);

	// select the return type.
	lhsty ::= lhs_val->type;
	if(!ty_is_integral(lhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			psyc_error_begin(lhs->loc);
			puts("operator invalid because the lhs must be either an integral or floating-point type, but you have passed ");
			putchar('"');
			putty(lhsty);
			putchar('"');
			psyc_diag_end();
			psyc_exit_failure();
		}
	}

	rhsty ::= rhs_val->type;
	if(!ty_is_integral(rhsty))
	{
		if(!ty_is_floating_point(rhsty))
		{
			psyc_error_begin(rhs->loc);
			puts("operator invalid because the rhs must be either an integral or floating-point type, but you have passed ");
			putchar('"');
			putty(rhsty);
			putchar('"');
			psyc_diag_end();
			psyc_exit_failure();
		}
	}

	// true  => rhs converts to lhs
	// false => lhs converts to rhs
	conversion_direction : bool mut := true;

	rhs_fs ::= ty_floating_point_size(rhsty);
	lhs_fs ::= ty_floating_point_size(lhsty);
	rhs_is ::= ty_integral_size(rhsty);
	lhs_is ::= ty_integral_size(lhsty);
	if(ty_is_floating_point(rhsty))
	{
		if(!ty_is_floating_point(lhsty))
		{
			conversion_direction = false;
		}
		if(ty_is_floating_point(lhsty))
		{
			if(rhs_fs > lhs_fs)
			{
				conversion_direction = false;
			}
		}
	}
	if(ty_is_integral(rhsty))
	{
		if(ty_is_integral(lhsty))
		{
			if(rhs_is > lhs_is)
			{
				conversion_direction = false;
			}
		}
	}

	if(conversion_direction)
	{
		deref(rhs_val) = cgv_convert(deref rhs_val, lhsty, prog, rhs->loc);
	}
	if(!conversion_direction)
	{
		deref(lhs_val) = cgv_convert(deref lhs_val, rhsty, prog, rhs->loc);
	}
};

cg_biop_bitwise_common ::= func(lhs_val : cgv mut&, rhs_val : cgv mut&, lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> v0
{
	deref(lhs_val) = cg_biop_process_param(lhs, ctx, prog);
	cgv_load_if_variable(lhs_val, prog);
	deref(rhs_val) = cg_biop_process_param(rhs, ctx, prog);
	cgv_load_if_variable(rhs_val, prog);

	// select the return type.
	lhsty ::= lhs_val->type;
	if(!ty_is_integral(lhsty))
	{
		psyc_error_begin(lhs->loc);
		puts("operator invalid because the lhs must be an integral type, but you have passed ");
		putchar('"');
		putty(lhsty);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	rhsty ::= rhs_val->type;
	if(!ty_is_integral(rhsty))
	{
		psyc_error_begin(rhs->loc);
		puts("operator invalid because the rhs must be an integral type, but you have passed ");
		putchar('"');
		putty(rhsty);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	// true  => rhs converts to lhs
	// false => lhs converts to rhs
	conversion_direction : bool mut := true;

	rhs_is ::= ty_integral_size(rhsty);
	lhs_is ::= ty_integral_size(lhsty);
	if(ty_is_integral(rhsty))
	{
		if(ty_is_integral(lhsty))
		{
			if(rhs_is > lhs_is)
			{
				conversion_direction = false;
			}
		}
	}

	if(conversion_direction)
	{
		deref(rhs_val) = cgv_convert(deref rhs_val, lhsty, prog, rhs->loc);
	}
	if(!conversion_direction)
	{
		deref(lhs_val) = cgv_convert(deref lhs_val, rhsty, prog, rhs->loc);
	}
};

cg_biop_assign ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val ::= cg_biop_process_param(lhs, ctx, prog);
	rhs_val : cgv mut := cg_biop_process_param(rhs, ctx, prog);
	cgv_load_if_variable(ref rhs_val, prog);
	rhs_val = cgv_convert(rhs_val, lhs_val.type, prog, rhs->loc);

	LLVMBuildStore(ir, rhs_val.ll, lhs_val.ll);
	return lhs_val;
};

cg_biop_compare ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_compare_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 32, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is(lhs_val.type, tytag.ptr))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 32, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 9, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);

	return lhs_val;
};

cg_biop_comparen ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_compare_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 33, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is(lhs_val.type, tytag.ptr))
	{
		(lhs_val.ll) = LLVMBuildICmp(ir, 33, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFCmp(ir, 14, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	(lhs_val.type) = ty_getprim(primty.bool, zero);

	return lhs_val;
};

cg_biop_plus ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildAdd(ir, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFAdd(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_minus ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildSub(ir, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFSub(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);
	return lhs_val;
};

cg_biop_multiply ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildMul(ir, lhs_val.ll, rhs_val.ll, "");
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFMul(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_divide ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_arith_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	if(ty_is_integral(lhs_val.type))
	{
		if(ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildSDiv(ir, lhs_val.ll, rhs_val.ll, "");
		}
		if(!ty_is_signed_integral(lhs_val.type))
		{
			(lhs_val.ll) = LLVMBuildUDiv(ir, lhs_val.ll, rhs_val.ll, "");
		}
	}
	if(ty_is_floating_point(lhs_val.type))
	{
		(lhs_val.ll) = LLVMBuildFDiv(ir, lhs_val.ll, rhs_val.ll, "");
	}
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_bitwise_or ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_bitwise_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	(lhs_val.ll) = LLVMBuildOr(ir, lhs_val.ll, rhs_val.ll, "");
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_logical_or ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(lhs->loc, "todo: biop logical_or");
	return zero;
};

cg_biop_bitwise_and ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut;
	rhs_val : cgv mut;
	cg_biop_bitwise_common(ref lhs_val, ref rhs_val, lhs, rhs, ctx, prog);
	(lhs_val.ll) = LLVMBuildAnd(ir, lhs_val.ll, rhs_val.ll, "");
	(lhs_val.tag) = (cgvtag.misc);

	return lhs_val;
};

cg_biop_logical_and ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(lhs->loc, "todo: biop logical_and");
	return zero;
};

cg_biop_at ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(lhs->loc, "todo: biop at");
	return zero;
};

cg_biop_field ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val ::= cg_biop_process_param(lhs, ctx, prog);
	// firstly ensure the lhs of struct type.
	lhs_ty ::= lhs_val.type;
	if(!ty_is(lhs_ty, tytag.strct))
	{
		psyc_error_begin(lhs->loc);
		puts("lhs of field expression must be a struct type - you have provided a ");
		putchar('"');
		putty(lhs_ty);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}
	lhs_strct ::= lhs_ty.strct;

	// rhs should be a symbol expr
	rhs_sym : ast_symbol_expr mut;
	rhs_sym = zero;
	if((rhs->type) == (ast_type.expr))
	{
		rhs_expr ::= rhs->expr;
		if((rhs_expr.type) == (ast_expr_type.symbol))
		{
			rhs_sym = (rhs_expr.symbol);
		}
	}
	if((rhs_sym.symbol) == null)
	{
		psyc_error_begin(rhs->loc);
		puts("invalid field expression - rhs must be a symbol expression");
		psyc_diag_end();
		psyc_exit_failure();
	}

	// get the member id.
	// if its a variable, we do a GEP to yield another variable
	// otherwise, we do an extractvalue to yield a misc
	memtypes ::= (lhs_strct.member_types)@ty&;
	memnames ::= (lhs_strct.member_names);
	memname_lens ::= (lhs_strct.member_name_lens);
	selected_memidx : u64 mut := -1;
	selected_memty : ty mut := zero;
	selected_memname : u8& mut := null;
	selected_memname_len : u64 mut := 0;
	i : u64 mut;
	for(i = 0, i < (lhs_strct.member_count), i = i + 1)
	{
		memty ::= deref(memtypes at i);
		memname ::= deref(memnames at i);
		memname_len ::= deref(memname_lens at i);
		if((rhs_sym.len) == memname_len)
		{
			if(cstreql_n(rhs_sym.symbol, memname, memname_len))
			{
				// this is the member.
				selected_memidx = i;
				selected_memty = memty;
				selected_memname = memname;
				selected_memname_len = memname_len;
			}
		}
	}

	if(selected_memidx == -1)
	{
		psyc_error_begin(rhs->loc);
		puts("struct ");
		putchar('"');
		putty(lhs_ty);
		putchar('"');
		puts(" had no such member named ");
		putchar('"');
		putss(rhs_sym.symbol, rhs_sym.len);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
	}

	if((lhs_val.tag) == (cgvtag.var))
	{
		// variable! ll should be an alloca or GEP'd alloca
		// which means we should GEP that and return var
		return cgv
		{
			.tag := cgvtag.var;
			.ll := LLVMBuildStructGEP2(ir, cg.type(lhs_ty, prog), lhs_val.ll, selected_memidx@u32, "");
			.type := selected_memty;
		};
	}
	return cgv
	{
		.tag := cgvtag.misc;
		.ll := LLVMBuildExtractValue(ir, lhs_val.ll, selected_memidx@u32, "");
		.type := selected_memty;
	};
};

cg_biop_ptr_field ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	psyc_panic(lhs->loc, "todo: biop ptr_field");
	return zero;
};

cg_biop_cast ::= func(lhs : ast&, rhs : ast&, ctx : context mut, prog : program mut&) -> cgv
{
	lhs_val : cgv mut := cg_biop_process_param(lhs, ctx, prog);
	cgv_load_if_variable(ref lhs_val, prog);
	rhs_sym : ast_symbol_expr mut;
	rhs_sym = zero;
	if((rhs->type) == (ast_type.expr))
	{
		rhs_expr ::= rhs->expr;
		if((rhs_expr.type) == (ast_expr_type.symbol))
		{
			rhs_sym = (rhs_expr.symbol);
		}
	}
	if((rhs_sym.symbol) == null)
	{
		psyc_error_begin(rhs->loc);
		puts("invalid cast - rhs must be a symbol expression");
		psyc_diag_end();
		psyc_exit_failure();
	}
	// make lhs weak
	lhs_ty : ty mut := lhs_val.type;
	(lhs_ty.qual) = (lhs_ty.qual) | (tyqual.weak);
	(lhs_val.type) = lhs_ty;
	(lhs_val.tag) = (cgvtag.misc);

	// is it the weakening idiom? then just return the weakened type
	weakening_idiom ::= "_";
	if((rhs_sym.len) == cstrlen(weakening_idiom))
	{
		if(cstreql_n(rhs_sym.symbol, weakening_idiom, rhs_sym.len))
		{
			// weakening idiom
			// just return lhs_val but make its type weak
			return lhs_val;
		}
	}

	// else, do the conversion.
	rhs_ty ::= scope_parse_typename(ctx.local, rhs_sym.symbol, rhs_sym.len);
	if(ty_isbad(rhs_ty))
	{
		psyc_error_begin(rhs->loc);
		puts("rhs of cast ");
		putchar('"');
		putss(rhs_sym.symbol, rhs_sym.len);
		putchar('"');
		puts(" yielded badtype");
		psyc_diag_end();
		psyc_exit_failure();
	}
	lhs_val = cgv_convert(lhs_val, rhs_ty, prog, lhs->loc);
	return lhs_val;
};

cg_biop ::= func(expr : ast_expr, ctx : context mut, prog : program mut&) -> cgv
{
	biop ::= expr.biop;
	biop_ty ::= biop.type;
	node ::= ctx.node;

	lhs ::= ast_biop_get_lhs(deref node);
	rhs ::= ast_biop_get_rhs(deref node);

	cg_func ::= deref(cg_biop_table at (biop_ty@s64));
	return cg_func.fn(lhs, rhs, ctx, prog);
};

// LLVM IR CODE GENERATION END

codegen_node_setup ::= func(a : arena mut&, h : cg_helper_functions) -> v0
{
	cgar = a;
	cg = h;
	i : u64 mut;

	// populate tables
	cg_node_table_size ::= __sizeof(cg_node_table) / __sizeof(deref(cg_node_table at 0));
	for(i = 0, i < cg_node_table_size, i = i + 1)
	{
		deref(cg_node_table at i) = cg_node_fn{.fn := cg_nodefn_error;};
	}
	deref(cg_node_table at ((ast_type.stmt)@s64)) = cg_node_fn{.fn := cg_stmt;};
	deref(cg_node_table at ((ast_type.expr)@s64)) = cg_node_fn{.fn := cg_expr;};

	cg_stmt_table_size ::= __sizeof(cg_stmt_table) / __sizeof(deref(cg_stmt_table at 0));
	for(i = 0, i < cg_stmt_table_size, i = i + 1)
	{
		deref(cg_stmt_table at i) = cg_stmt_fn{.fn := cg_stmtfn_error;};
	}
	deref(cg_stmt_table at ((ast_stmt.expr_stmt)@s64)) = cg_stmt_fn{.fn := cg_expr_stmt;};
	deref(cg_stmt_table at ((ast_stmt.decl_stmt)@s64)) = cg_stmt_fn{.fn := cg_decl_stmt;};

	cg_expr_table_size ::= __sizeof(cg_expr_table) / __sizeof(deref(cg_expr_table at 0));
	for(i = 0, i < cg_expr_table_size, i = i + 1)
	{
		deref(cg_expr_table at i) = cg_expr_fn{.fn := cg_exprfn_error;};
	}
	deref(cg_expr_table at ((ast_expr_type.symbol)@s64)) = cg_expr_fn{.fn := cg_symbol;};
	deref(cg_expr_table at ((ast_expr_type.biop)@s64)) = cg_expr_fn{.fn := cg_biop;};
	deref(cg_expr_table at ((ast_expr_type.literal)@s64)) = cg_expr_fn{.fn := cg_literal;};
	deref(cg_expr_table at ((ast_expr_type.ret)@s64)) = cg_expr_fn{.fn := cg_ret;};

	cg_biop_table_size ::= __sizeof(cg_biop_table) / __sizeof(deref(cg_biop_table at 0));
	for(i = 0, i < cg_biop_table_size, i = i + 1)
	{
		deref(cg_biop_table at i) = cg_biop_fn{.fn := cg_biopfn_error;};
	}
	deref(cg_biop_table at ((ast_biop_type.assign)@s64)) = cg_biop_fn{.fn := cg_biop_assign;};
	deref(cg_biop_table at ((ast_biop_type.compare)@s64)) = cg_biop_fn{.fn := cg_biop_compare;};
	deref(cg_biop_table at ((ast_biop_type.comparen)@s64)) = cg_biop_fn{.fn := cg_biop_comparen;};
	deref(cg_biop_table at ((ast_biop_type.plus)@s64)) = cg_biop_fn{.fn := cg_biop_plus;};
	deref(cg_biop_table at ((ast_biop_type.minus)@s64)) = cg_biop_fn{.fn := cg_biop_minus;};
	deref(cg_biop_table at ((ast_biop_type.multiply)@s64)) = cg_biop_fn{.fn := cg_biop_multiply;};
	deref(cg_biop_table at ((ast_biop_type.divide)@s64)) = cg_biop_fn{.fn := cg_biop_divide;};
	deref(cg_biop_table at ((ast_biop_type.bitwise_or)@s64)) = cg_biop_fn{.fn := cg_biop_bitwise_or;};
	deref(cg_biop_table at ((ast_biop_type.logical_or)@s64)) = cg_biop_fn{.fn := cg_biop_logical_or;};
	deref(cg_biop_table at ((ast_biop_type.bitwise_and)@s64)) = cg_biop_fn{.fn := cg_biop_bitwise_and;};
	deref(cg_biop_table at ((ast_biop_type.logical_and)@s64)) = cg_biop_fn{.fn := cg_biop_logical_and;};
	deref(cg_biop_table at ((ast_biop_type.operator_at)@s64)) = cg_biop_fn{.fn := cg_biop_at;};
	deref(cg_biop_table at ((ast_biop_type.field)@s64)) = cg_biop_fn{.fn := cg_biop_field;};
	deref(cg_biop_table at ((ast_biop_type.ptr_field)@s64)) = cg_biop_fn{.fn := cg_biop_ptr_field;};
	deref(cg_biop_table at ((ast_biop_type.cast)@s64)) = cg_biop_fn{.fn := cg_biop_cast;};

	cg_literal_table_size ::= __sizeof(cg_literal_table) / __sizeof(deref(cg_literal_table at 0));
	for(i = 0, i < cg_literal_table_size, i = i + 1)
	{
		deref(cg_literal_table at i) = cg_literal_fn{.fn := cg_literalfn_error;};
	}
	deref(cg_literal_table at ((ast_literal_type.integral)@s64)) = cg_literal_fn{.fn := cg_integer_literal;};
	deref(cg_literal_table at ((ast_literal_type.floating_point)@s64)) = cg_literal_fn{.fn := cg_floating_point_literal;};
	deref(cg_literal_table at ((ast_literal_type.char_literal)@s64)) = cg_literal_fn{.fn := cg_char_literal;};
	deref(cg_literal_table at ((ast_literal_type.string_literal)@s64)) = cg_literal_fn{.fn := cg_string_literal;};
	deref(cg_literal_table at ((ast_literal_type.bool_literal)@s64)) = cg_literal_fn{.fn := cg_bool_literal;};
	deref(cg_literal_table at ((ast_literal_type.zero_literal)@s64)) = cg_literal_fn{.fn := cg_zero_literal;};
};

== build ==
{
	add_source_file("codegen_tables.psy");
	add_source_file("llvm.psy");
	add_source_file("program.psy");
}
