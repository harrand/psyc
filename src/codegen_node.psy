cgar : arena mut& mut;

cg_helper_functions ::= struct
{
	children : func(ctx : context mut, prog : program mut&, offset : u64, back_offset : u64) -> v0;
	type : func(t : ty, prog : program mut&) -> u64;
};
cg : cg_helper_functions mut;

// LLVM IR CODE GENERATION

cg_stmt ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;
	stmt ::= node->stmt;

	cg_func ::= deref(cg_stmt_table at (stmt@s64));
	cg_func.fn(ctx, prog);
};

cg_node ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;

	cg_func ::= deref(cg_node_table at ((node->type)@s64));
	cg_func.fn(ctx, prog);
};

codegen_node_setup ::= func(a : arena mut&, h : cg_helper_functions) -> v0
{
	cgar = a;
	cg = h;
	i : u64 mut;


	// populate tables
	cg_node_table_size ::= __sizeof(cg_node_table) / __sizeof(deref(cg_node_table at 0));
	for(i = 0, i < cg_node_table_size, i = i + 1)
	{
		deref(cg_node_table at i) = cg_node_fn{.fn := cg_nodefn_error;};
	}
	deref(cg_node_table at ((ast_type.stmt)@s64)) = cg_node_fn{.fn := cg_stmt;};

	cg_stmt_table_size ::= __sizeof(cg_stmt_table) / __sizeof(deref(cg_stmt_table at 0));
	for(i = 0, i < cg_stmt_table_size, i = i + 1)
	{
		deref(cg_stmt_table at i) = cg_stmt_fn{.fn := cg_stmtfn_error;};
	}
	//deref(cg_stmt_table at ((ast_type.stmt)@s64)) = cg_stmt_fn{.fn := cg_stmt;};
};

== build ==
{
	add_source_file("codegen_tables.psy");
	add_source_file("llvm.psy");
	add_source_file("program.psy");
}
