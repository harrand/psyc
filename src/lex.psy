Sleep ::= func(millis : s32) -> v0 := extern;

lex_slice ::= struct
{
	off : u64;
	len : u64;
};

lex_token ::= enum
{
	.comment := 0;
	.multicomment := 1;
	.integer_literal := 2;
	.decimal_literal := 3;
	.char_literal := 4;
	.string_literal := 5;
	.semicol := 6;
	.initialiser := 7;
	.colon := 8;
	.comma := 9;
	.dot := 10;
	.compare := 11;
	.comparen := 12;
	.assign := 13;
	.arrow := 14;
	.oparen := 15;
	.cparen := 16;
	.obrace := 17;
	.cbrace := 18;
	.obrack := 19;
	.cbrack := 20;
	.plus := 21;
	.dash := 22;
	.asterisk := 23;
	.fslash := 24;
	.cast := 25;
	.arr := 26;
	.bitwise_and := 27;
	.bitwise_or := 28;
	.bitwise_exor := 29;
	.modulo := 30;
	.invert := 31;
	.loreq := 32;
	.goreq := 33;
	.oanglebrack := 34;
	.canglebrack := 35;
	.keyword_static_if := 36;
	.keyword_if := 37;
	.keyword_else := 38;
	.keyword_while := 39;
	.keyword_for := 40;
	.keyword_return := 41;
	.keyword_yield := 42;
	.keyword_func := 43;
	.keyword_macro := 44;
	.keyword_extern := 45;
	.keyword_struct := 46;
	.keyword_enum := 47;
	.keyword_ref := 48;
	.keyword_deref := 49;
	.keyword_atomic_deref := 50;
	.keyword_defer := 51;
	.keyword_alias := 52;
	.keyword_at := 53;
	.keyword_true := 54;
	.keyword_false := 55;
	.keyword_zero := 56;
	.keyword_null := 57;
	.symbol := 58;
	.end_of_file := 59;
};

tokenise_instruction ::= struct
{
	name : u8&;
	front_identifier : u8&;
	tokenise_fn : func(front : u8&) -> v0;
	trivial : bool;
	affects_code : bool;
	allow_run_on : bool;
};

[[private]]
lex_instructions : tokenise_instruction mut#59;

[[private]]
impl_setup_instruction ::= func(tok : lex_token, inst : tokenise_instruction mut) -> v0
{
	inst.name = __enumname(tok);
	deref(lex_instructions at (tok@s64)) = inst;
};

[[private]]
tokenise_comment ::= func(front : u8&) -> v0
{
};

lex_setup ::= func() -> v0
{
	impl_setup_instruction(lex_token.comment, tokenise_instruction
	{
		.front_identifier := "//";
		.tokenise_fn := tokenise_comment;
	});
};

token_data ::= struct
{
	tok : lex_token;
	lexeme : lex_slice;
	begin : srcloc;
	end : srcloc;
};

lex_state ::= struct
{
	src : u8&;
	cursor : u64;
	line : u64;
	col : u64;

	tokens : token_data mut&;
	tokens_size : u64;
	tokens_cap : u64;
};

impl_is_newline ::= func(char : u8) -> bool
{
	return char == 10;
};

ls_advance ::= func(s : lex_state mut&, count : u32) -> v0
{
	i : u32 mut;
	for(i = 0, i < count, i = i + 1)
	{
		is_newline ::= impl_is_newline(deref ((s->src) at i));
		if(is_newline)
		{
			(s->line) = (s->line) + 1;
			(s->col) = 0;
		}
		if(!is_newline)
		{
			(s->col) = (s->col) + 1;
		}
	}
};

ls_advance_str ::= func(s : lex_state mut&, str : u8&) -> v0
{
	ls_advance(s, cstrlen(str)@_);
};

ls_verbose_print ::= func(s : lex_state&) -> v0
{
	puts(s->src);
	// just print out all token datas.
	i : u64 mut;
	for(i = 0, i < (s->tokens_size), i = i + 1)
	{
		tok ::= deref ((s->tokens) at i);
		slice ::= tok.lexeme;
		puts(__enumname(tok.tok));
		putchar(' ');
		lexeme_data ::= (s->src) at (slice.off);
		j : u64 mut;
		for(j = 0, j < (slice.len), j = j + 1)
		{
			putchar(deref(lexeme_data at j));
		}
		putchar(10);
	}
};

lex ::= func(src : u8&) -> lex_state
{
	psyc_timed(psyc_stage.lex);
	ret : lex_state mut := zero;
	(ret.src) = src;
	ls_verbose_print(ref ret);
	return ret;
};

== build ==
{
	add_source_file("diag.psy");
}
