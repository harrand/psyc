progwalk_function ::= struct
{
	fn : func(ctx : context mut, prog : program mut&) -> sval;
};

semar : arena mut& mut;
node_jump_table : progwalk_function mut#4;
stmt_jump_table : progwalk_function mut#9;

literal_types : ty mut#5;

progwalk_node ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;

	pre_transform_idx ::= (node->type)@s64;
	subtraction ::= (ast_type.stmt)@s64;

	idx ::= pre_transform_idx - subtraction;
	jump ::= deref(node_jump_table at idx);
	jump.fn(ctx, prog);
};

progwalk_children ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;
	childrenptr ::= (node->children)@ast&;
	count ::= node->childcount;
	i : u64 mut;
	for(i = 0, i < count, i = i + 1)
	{
		progwalk_node(context
		{
			.node := childrenptr at i;
			.local := ctx.local;
		}, prog);
	}
};

progwalk_stmt ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	pre_transform_idx ::= (node->stmt)@s64;
	subtraction ::= (ast_stmt.expr_stmt)@s64;

	idx ::= pre_transform_idx - subtraction;
	jump ::= deref(stmt_jump_table at idx);
	return jump.fn(ctx, prog);
};

progwalk_structdef ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	def ::= node->structdef;

	already ::= scope_find_struct(ctx.local, def.structname, def.structname_len);
	if(already != null)
	{
		already_node ::= already->node;
		psyc_error_begin(node->loc);
		puts("a struct named ");
		putchar('"');
		putss(def.structname, def.structname_len);
		putchar('"');
		puts(" was already defined ");
		print_srcloc(already_node->loc);
		psyc_diag_end();
		psyc_exit_failure();
	}
	scope_declare_struct(ctx.local, semar, structdef
	{
		.node := node;
		.name := def.structname;
		.name_len := def.structname_len;
		.member_count := node->childcount;
	});

	puts("struct ");
	putss(def.structname, def.structname_len);
	puts(" ");
	print_srcloc(node->loc);
	putchar(10);
	return zero;
};

progwalk_fn ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	fn ::= node->fn;

	ret_ty : ty mut := scope_parse_typename(ctx.local, fn.ret_typename, fn.ret_typename_len);
	// so the param count is *not* just equal to the childcount if the function is not extern.
	// the statements within are also child nodes.
	// however, all ast_fn children will start off as decls (all the params) and then the contents of the implementation will follow
	i : u64 mut;
	childcount ::= node->childcount;
	beyond_param_idx : u64 mut := 0;
	param_count : u64 mut := 0;
	for(i = 0, i < childcount, i = i + 1)
	{
		cur_param_node ::= ast_get_child(node@_, i);
		if((cur_param_node->type) == (ast_type.decl))
		{
			param_count = param_count + 1;
			beyond_param_idx = beyond_param_idx + 1;
		}
		if((cur_param_node->type) != (ast_type.decl))
		{
			// early out
			i = childcount;
		}
	}

	// note: local scope is going to be (at the very most) file scope
	// this means that other files will not currently be able to see this definition
	// this can be fixed by simply using program_declare_function, but i don't feel comfortable just doing that willy-nilly
	scope_declare_function(ctx.local, semar,
		function{
			.node := ctx.node;
			.name := fn.fn_name;
			.name_len := fn.fn_name_len;
			.param_count := beyond_param_idx;
		});

	if(fn.is_extern)
	{
		if(beyond_param_idx != childcount)
		{
			psyc_panic(node->loc, "extern fn expected all children to be decls representing params, but that seems to not be the case.");
		}
	}

	puts("func ");
	putss(fn.fn_name, fn.fn_name_len);
	puts(" ");
	print_srcloc(node->loc);
	putchar(10);
	return zero;
};

progwalk_mac ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	mac ::= node->mac;

	yield_id : u64 mut := -1;

	// so the param count is *not* just equal to the childcount if the function is not extern.
	// the statements within are also child nodes.
	// however, all ast_fn children will start off as decls (all the params) and then the contents of the implementation will follow
	i : u64 mut;
	childcount ::= node->childcount;
	beyond_param_idx : u64 mut := 0;
	param_count : u64 mut := 0;
	for(i = 0, i < childcount, i = i + 1)
	{
		cur_param_node ::= ast_get_child(node@_, i);
		if((cur_param_node->type) == (ast_type.decl))
		{
			param_count = param_count + 1;
			beyond_param_idx = beyond_param_idx + 1;
		}
		if((cur_param_node->type) != (ast_type.decl))
		{
			// early out
			i = childcount;
		}
	}

	curstmt : ast_stmt mut;
	for(i = beyond_param_idx, i < childcount, i = i + 1)
	{
		curchild ::= ast_get_child(node@_, i);
		// todo: find yield_id and set it.
		if((curchild->type) == (ast_type.stmt))
		{
			curstmt = (curchild->stmt);
			if(curstmt == (ast_stmt.expr_stmt))
			{
				curexpr ::= curchild->expr;
				if((curexpr.type) == (ast_expr_type.yld))
				{
					if(yield_id != -1)
					{
						previous_yield ::= ast_get_child(node@_, yield_id);
						psyc_error_begin(curchild->loc);
						puts("multiple 'yield' statements detected within the same macro, previously defined ");
						print_srcloc(previous_yield->loc);
						psyc_diag_end();
						psyc_exit_failure();
					}
					yield_id = i;
				}
			}
		}
	}

	scope_declare_macro(ctx.local, semar, macrodef
	{
		.node := node;
		.name := mac.mac_name;
		.name_len := mac.mac_name_len;
		.yield_type := scope_parse_typename(ctx.local, mac.yield_typename, mac.yield_typename_len);
		.first_id := beyond_param_idx;
		.yield_id := yield_id;
	});
	puts("macro ");
	putss(mac.mac_name, mac.mac_name_len);
	puts(" ");
	print_srcloc(node->loc);
	putchar(10);
	return zero;
};

progwalk_noop ::= func(ctx : context mut, prog : program mut&) -> sval
{
	return zero;
};

progwalk_setup ::= func(a : arena mut&) -> v0
{
	psyc_timed(psyc_stage.setup);
	semar = a;

	deref(node_jump_table at 0) = progwalk_function{.fn := progwalk_stmt;};
	deref(node_jump_table at 1) = progwalk_function{.fn := progwalk_noop;};
	deref(node_jump_table at 2) = progwalk_function{.fn := progwalk_noop;};
	deref(node_jump_table at 3) = progwalk_function{.fn := progwalk_noop;};

	deref(stmt_jump_table at 0) = progwalk_function{.fn := progwalk_noop;};
	deref(stmt_jump_table at 1) = progwalk_function{.fn := progwalk_noop;};
	deref(stmt_jump_table at 2) = progwalk_function{.fn := progwalk_noop;};
	deref(stmt_jump_table at 3) = progwalk_function{.fn := progwalk_structdef;};
	deref(stmt_jump_table at 4) = progwalk_function{.fn := progwalk_fn;};
	deref(stmt_jump_table at 5) = progwalk_function{.fn := progwalk_mac;};
	deref(stmt_jump_table at 6) = progwalk_function{.fn := progwalk_noop;};
	deref(stmt_jump_table at 7) = progwalk_function{.fn := progwalk_noop;};
	deref(stmt_jump_table at 8) = progwalk_function{.fn := progwalk_noop;};
};

progwalk_file ::= func(prog : program mut&, source : ast&) -> v0
{
	psyc_timed(psyc_stage.semal);
	global ::= prog->global;

	// file scope is a child of the program scope
	file_scope ::= program_new_scope(prog, semar, ref global, scope_type.file, source->loc, null, zero);

	progwalk_children(context
	{
		.node := source;
		.local := file_scope;
	}, prog);
};

== build ==
{
	add_source_file("program.psy");
	add_source_file("diag.psy");

	add_source_file("sval.psy");
}
