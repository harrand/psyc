// given an ast, walk through it and populate program bits
// e.g global/locals, scopes, functions, structs, etc...

// in theory you'd think its as simple as progwalk_node + progwalk_children and then dispatch it all to the right node types
// however this would mean alot of unnecessary work
// so instead we just iterate over all the immediate children. globals/functions/structs etc are recorded.
progwalk_file ::= func(node : ast? -> lexical_scope mut?)
{
	psyc_timed_begin(psyc_stage.semantic);
	defer psyc_timed_end();
	file_scope ::= program_add_scope();
	deref(file_scope) = lexical_scope
	{
		.type := scope_type.file;
		.name := node->loc.file;
		.name_len := zstrlen(node->loc.file);
	};

	i : u64 mut;
	for(i = 0, i < (node->children_count), i = i + 1)
	{
		child ::= ast_get_child(node, i);
		if((child->tag == (ast_tag.stmt)) && (child->stmt == (ast_stmt_tag.structure)))
		{
			// its a structure
			progwalk_structure(child, file_scope);
		}
		if((child->tag == (ast_tag.stmt)) && (child->stmt == (ast_stmt_tag.function)))
		{
			// its a function
			progwalk_function(child, file_scope);
		}
		if((child->tag == (ast_tag.stmt)) && (child->stmt == (ast_stmt_tag.enumeration)))
		{
			// its a enumeration
			progwalk_enumeration(child, file_scope);
		}
		if((child->tag == (ast_tag.stmt)) && (child->stmt == (ast_stmt_tag.assembly)))
		{
			// its a assembly
			progwalk_assembly(child, file_scope);
		}
		if((child->tag == (ast_tag.stmt)) && (child->stmt == (ast_stmt_tag.region)))
		{
			// its a region
			progwalk_region(child, file_scope);
		}
	}
	return file_scope;
};

progwalk_structure ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	structdata ::= node->structure;
	// todo: do something with ast_struct
	memcount ::= node->children_count;
	unfinished_type ::= ty
	{
		.tag := tytag.strct;
		.name := structdata.name;
		.name_len := structdata.name_len;
		.strct := structty
		{
			.members := arena_alloc(global_arena, memcount * __sizeof(tyid));
			.member_names := arena_alloc(global_arena, memcount * __sizeof(u8?));
			.member_name_lens := arena_alloc(global_arena, memcount * __sizeof(u64));
			.members_count := memcount;
		};
	};
	already ::= scope_find_structure(scope, structdata.name, structdata.name_len);
	if(already != zero)
	{
		psyc_error_begin(node->loc);
		putzstr("duplicate struct ");
		putchar('"');
		putbytes(structdata.name, structdata.name_len);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_current_source_file().src, node, 1);
		putchar(10);
		putzstr("previous definition was ");
		putloc(already->node->loc);
		putchar(':');
		already_src ::= program_find_source_file(already->node->loc.file);
		putchar(10);
		ast_print_annotated_source(already_src->src, already->node, 1);
		psyc_diag_end();
		psyc_exit_failure();
	}
	scope_add_structure(scope, structure
	{
		.node := node;
		.type := ty_wrap(unfinished_type, zero);
		.cg := zero;
		.db := zero;
	});
};

progwalk_function ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_fn ::= node->function;

	func_scope ::= program_add_scope();
	func_scope->name = (ast_fn.name);
	func_scope->name_len = (ast_fn.name_len);
	func_scope->parent_id = (scope->id);

	scope_add_function(scope, function
	{
		.node := node;
		.scope := func_scope;
		.name := ast_fn.name;
		.name_len := ast_fn.name_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_enumeration ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_enum ::= node->enumeration;
	scope_add_enumeration(scope, enumeration
	{
		.node := node;
		.name := ast_enum.name;
		.name_len := ast_enum.name_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_assembly ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_asm ::= node->assembly;
	// child 0 is the typename
	// child 1 is the unparsed_token symbol
	symbol_node ::= ast_get_child(node, 1);
	//assert(symbol_node->tag == (ast_tag.unparsed_token));
	lexeme ::= symbol_node->utok.tok.lexeme;
	scope_add_assembly(scope, assembly
	{
		.node := node;
		.name := ast_asm.name;
		.name_len := ast_asm.name_len;
		.code := program_current_source_file().src # (lexeme.off);
		.code_len := lexeme.len;
		.constraints := ast_asm.constraints;
		.constraints_len := ast_asm.constraints_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_region ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_region ::= node->region;
	scope_add_region(scope, region
	{
		.node := node;
		.name := ast_region.name;
		.name_len := ast_region.name_len;
	});
};
