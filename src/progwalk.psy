// given an ast, walk through it and populate program bits
// e.g global/locals, scopes, functions, structs, etc...

// in theory you'd think its as simple as progwalk_node + progwalk_children and then dispatch it all to the right node types
// however this would mean alot of unnecessary work
// so instead we just iterate over all the immediate children. globals/functions/structs etc are recorded.
progwalk_file : func(node : ast? -> lexical_scope mut?)
{
	psyc_timed_begin(psyc_stage.semantic);
	file_scope ::= program_add_scope();
	[file_scope] = lexical_scope
	{
		.type := scope_type.file;
		.name := node->loc.file;
		.name_len := zstrlen(node->loc.file);
		.parent_id := program_scope()->id;
	};

	i : u64 mut;
	for(i = 0;  i < (node->children_count);  i = i + 1)
	{
		child ::= ast_get_child(node, i);
		progwalk_node(child, file_scope);
	}
	psyc_timed_end();
	return file_scope;
};

progwalk_node : func(node : ast?, scope : lexical_scope mut? -> v0)
{
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.structure)))
	{
		// its a structure
		progwalk_structure(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.function)))
	{
		// its a function
		progwalk_function(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.enumeration)))
	{
		// its a enumeration
		progwalk_enumeration(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.assembly)))
	{
		// its a assembly
		progwalk_assembly(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.region)))
	{
		// its a region
		progwalk_region(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.if_block)))
	{
		// its a region
		progwalk_if(node, scope);
	}
	if(ast_is_stmt(node, ast_stmt_tag.decl))
	{
		// functions handle their own local variables
		// we're just checking for globals here
		if(scope->type == (scope_type.file))
		{
			progwalk_global_variable_decl(node, scope);
		}
	}
};

progwalk_structure : func(node : ast?, scope : lexical_scope mut? -> v0)
{
	structdata ::= node->structure;
	// todo: do something with ast_struct
	memcount ::= node->children_count;
	unfinished_type ::= ty
	{
		.tag := tytag.strct;
		.name := structdata.name;
		.name_len := structdata.name_len;
		.strct := structty
		{
			.members := arena_alloc(global_arena, memcount * sizeof tyid);
			.member_names := arena_alloc(global_arena, memcount * sizeof u8?);
			.member_name_lens := arena_alloc(global_arena, memcount * sizeof u64);
			.members_count := memcount;
			.node := node;
		};
	};
	already ::= scope_find_structure(scope, structdata.name, structdata.name_len);
	if(already != zero)
	{
		psyc_error_begin(node->loc);
		putzstr("duplicate declaration of struct named ");
		putchar('"');
		putbytes(structdata.name, structdata.name_len);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_colour_blue();
		putchar(10);
		putzstr("struct ");
		putchar('"');
		putbytes(structdata.name, structdata.name_len);
		putchar('"');
		putzstr(" was previously defined at ");
		putloc(already->node->loc);
		putzstr(":");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(already->node->loc.file)->src, already->node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	scope_add_structure(scope, structure
	{
		.node := node;
		.type := ty_wrap(unfinished_type, zero);
	});
};

progwalk_search_function_descendents_for_locals : func(node : ast?, begin_offset : u64, end_offset : u64, func_scope : lexical_scope mut? -> v0)
{
	i : u64 mut;
	last ::= node->children_count - end_offset;
	for(i = begin_offset;  i < last;  i = i + 1)
	{
		child ::= ast_get_child(node, i);
		if(ast_is_stmt(child, ast_stmt_tag.decl))
		{
			// yes this decl needs to be hoisted
			decl ::= child->decl;
			already_exists ::= scope_find_variable(func_scope, decl.name, decl.name_len);
			if(already_exists != zero)
			{
				psyc_error_begin(child->loc);
				putzstr("duplicate declaration of variable named ");
				putchar('"');
				putbytes(decl.name, decl.name_len);
				putchar('"');
				putchar(10);
				ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
				psyc_colour_blue();
				putchar(10);
				putzstr("variable ");
				putchar('"');
				putbytes(decl.name, decl.name_len);
				putchar('"');
				putzstr(" was previously defined at ");
				putloc(already_exists->node->loc);
				putzstr(":");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(already_exists->node->loc.file)->src, already_exists->node, 1, underline_colour.blue);
				psyc_diag_end();
				psyc_exit_failure();
			}
			scope_add_variable(func_scope, variable
			{
				.node := child;
				// need to defer typing this till after progwalk because it could e.g be a struct that isnt declared yet.
				.type := zero;
				.compile_time_storage := zero;
				.param_idx := -1;
				.cg := zero;
				.db := zero;			
			});
		}
		// if/else/while/fors need to be scanned too.
		if(ast_is_stmt(child, ast_stmt_tag.if_block))
		{
			// progwalk_if first because if its a static_if we want that dealt with now.
			progwalk_if(child, func_scope);
			// ignore cond
			progwalk_search_function_descendents_for_locals(child, 1, 0, func_scope);
		}
		if(ast_is_stmt(child, ast_stmt_tag.else_block))
		{
			progwalk_search_function_descendents_for_locals(child, 0, 0, func_scope);
		}
		if(ast_is_stmt(child, ast_stmt_tag.while_block))
		{
			// ignore cond
			progwalk_search_function_descendents_for_locals(child, 0, 0, func_scope);
		}
		if(ast_is_stmt(child, ast_stmt_tag.for_block))
		{
			// ignore init, cond, iter
			// todo: future harry, if you make the parser allow decls in the init, then do actually progwalk cond.
			progwalk_search_function_descendents_for_locals(child, 3, 0, func_scope);
		}
	}
};

progwalk_function : func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_fn ::= node->function;

	func_scope ::= program_add_scope();
	[func_scope] = lexical_scope
	{
		.type := scope_type.function;
		.name := ast_fn.name;
		.name_len := ast_fn.name_len;
		.parent_id := scope->id;
	};

	// we want to back all parameters
	// this is guaranteed to be a function typename
	typename_node ::= ast_get_child(node, 0);
	// child count is number of parameters + return type
	param_count ::= typename_node->children_count - 1;
	// each of these params are actually decls
	i : u64 mut;
	for(i = 0;  i < param_count;  i = i + 1)
	{
		param_node ::= ast_get_child(typename_node, i);
		// assume this is a decl
		param_decl ::= param_node->decl;
		scope_add_variable(func_scope, variable
		{
			.node := param_node;
			.type := zero;
			.compile_time_storage := zero;
			.param_idx := i;
			.cg := zero;
			.db := zero;
		});
	}
	
	// so we need to iterate over every child node (aside from child 0-N which is the typename and params)
	// and catch all local variables
	// and then shove them in the scope.
	progwalk_search_function_descendents_for_locals(node, 1, 0, func_scope);

	already_exists ::= scope_find_function(func_scope, ast_fn.name, ast_fn.name_len);
	if(already_exists != zero)
	{
		psyc_error_begin(node->loc);
		putzstr("duplicate declaration of function named ");
		putchar('"');
		putbytes(ast_fn.name, ast_fn.name_len);
		putchar('"');
		putchar(10);
		// printing the nodes directly here prints out the whole function which sucks
		// so if we print the functions first child its the typename which covers the signature line only
		node_child ::= ast_get_child(node, 0);
		ast_print_annotated_source(program_find_source_file(node_child->loc.file)->src, node_child, 1, underline_colour.red);
		psyc_colour_blue();
		putchar(10);
		putzstr("function ");
		putchar('"');
		putbytes(ast_fn.name, ast_fn.name_len);
		putchar('"');
		putzstr(" was previously defined at ");
		putloc(already_exists->node->loc);
		putzstr(":");
		putchar(10);
		already_child ::= ast_get_child(already_exists->node, 0);
		ast_print_annotated_source(program_find_source_file(already_child->loc.file)->src, already_child, 1, underline_colour.blue);
		psyc_diag_end();
		psyc_exit_failure();
	}
	scope_add_function(scope, function
	{
		.node := node;
		.type := zero;
		.scope := func_scope;
		.name := ast_fn.name;
		.name_len := ast_fn.name_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_enumeration : func(node : ast?, scope : lexical_scope mut? -> v0)
{
	enumdata ::= node->enumeration;
	entcount ::= node->children_count;
	retty ::= ty
	{
		.tag := tytag.enm;
		.name := enumdata.name;
		.name_len := enumdata.name_len;
		.enm := enumty
		{
			.entries := arena_alloc(global_arena, sizeof u64 * entcount);
			.entry_names := arena_alloc(global_arena, sizeof u8? * entcount);
			.entry_name_lens := arena_alloc(global_arena, sizeof u64 * entcount);
			.entries_count := entcount;
		};
	};
	i : u64 mut;
	for(i = 0;  i < entcount;  i = i + 1)
	{
		// ent is going to be a desiginit with a single child value
		ent ::= ast_get_child(node, i);
		ent_val ::= val_convert_to(val_node(ast_get_child(ent, 0), scope, val_resolution.compile_time_only), tyid_integral_literal(), zero, val_resolution.compile_time_only, ent);
		desig ::= ent->desiginit;
		if(desig.descriptor != (ast_desiginit_descriptor.symbol))
		{
			psyc_error_begin(node->loc);
			putzstr("enum entry designator must be a symbol (name), not a number");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		[retty.enm.entry_names # i] = (desig.symbol);
		[retty.enm.entry_name_lens # i] = (desig.symbol_len);
		[retty.enm.entries # i] = val_must_get_integer(ent_val, program_scope(), ent);
	}
	scope_add_enumeration(scope, enumeration
	{
		.node := node;
		.type := ty_wrap(retty, zero);
		.cg := zero;
		.db := zero;
	});
};

progwalk_assembly : func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_asm ::= node->assembly;
	// child 0 is the typename
	// child 1 is the unparsed_token symbol
	symbol_node ::= ast_get_child(node, 1);
	//assert(symbol_node->tag == (ast_tag.unparsed_token));
	lexeme ::= symbol_node->utok.tok.lexeme;
	scope_add_assembly(scope, assembly
	{
		.node := node;
		.name := ast_asm.name;
		.name_len := ast_asm.name_len;
		.type := zero;
		.code := program_current_source_file().src # (lexeme.off);
		.code_len := lexeme.len;
		.constraints := ast_asm.constraints;
		.constraints_len := ast_asm.constraints_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_region : func(node : ast?, scope : lexical_scope mut? -> v0)
{
	regiondata ::= node->region;
	scope_add_region(scope, region
	{
		.node := node;
		.name := regiondata.name;
		.name_len := regiondata.name_len;
	});
};

progwalk_if : func(node : ast mut?, scope : lexical_scope mut? -> v0)
{
	// this exists for 2 reasons:
	// 1. we need to check inside if blocks etc for hoisting reasons
	// 2. we want to evaluate static_ifs as early as possible. i.e now.
	// 3. static_ifs have special functionality such that if they are true then their contents are treated as if they were in the scope that the if is in.

	// 1 and 2
	i : u64 mut;
	ifdata ::= node->ifblk;
	cond_node ::= ast_get_child(node, 0);
	last_child ::= ast_get_child(node, (node->children_count - 1));
	else_node : ast mut? mut := zero;
	if((last_child->tag == (ast_tag.stmt)) && (last_child->stmt == (ast_stmt_tag.else_block)))
	{
		else_node = last_child;
	}

	if(ifdata.is_static)
	{
		cond_val ::= val_node(cond_node, program_scope(), val_resolution.compile_time_only);
		if(val_must_get_boolean(cond_val, program_scope(), cond_node))
		{
			// static_if(true)
			// forget about the else node if it exists
			if(else_node != zero)
			{
				node->children_count = (node->children_count - 1);
			}
		}
		else
		{
			// static_if(false)
			// if we have no else then just set childcount to 1
			if(else_node == zero)
			{
				node->children_count = 1;
			}
			else // otherwise, move the elsenode's children to be our own.
			{
				// let the first child stay put as its the cond
				node->children_count = 1;
				// but the rest should be replaced with the children of the else node.
				for(i = 0;  i < (else_node->children_count);  i = i + 1)
				{
					ast_add_child(node, [ast_get_child(else_node, i)], global_arena);
				}
			}
		}


		// 3
		// we no longer care about the condition because of above, iterate over the non-condition children
		// and then progwalk them
		for(i = 1;  i < (node->children_count);  i = i + 1)
		{
			progwalk_node(ast_get_child(node, i), scope);
		}
		// and yes, when you're codegenning you ignore the condition of a static-if and just codegen its children as if they were part of the parent scope (this was known as a composite in psyc 1.x)
	}
};

progwalk_global_variable_decl : func(node : ast mut?, scope : lexical_scope mut? -> v0)
{
	scope_add_variable(scope, variable
	{
		.node := node;
		.type := zero;
		.compile_time_storage := zero;
		.param_idx := -1;
		.cg := zero;
		.db := zero;			
	});
};
