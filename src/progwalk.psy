// given an ast, walk through it and populate program bits
// e.g global/locals, scopes, functions, structs, etc...

// in theory you'd think its as simple as progwalk_node + progwalk_children and then dispatch it all to the right node types
// however this would mean alot of unnecessary work
// so instead we just iterate over all the immediate children. globals/functions/structs etc are recorded.
progwalk_file ::= func(node : ast? -> lexical_scope mut?)
{
	psyc_timed_begin(psyc_stage.semantic);
	defer psyc_timed_end();
	file_scope ::= program_add_scope();
	deref(file_scope) = lexical_scope
	{
		.type := scope_type.file;
		.name := node->loc.file;
		.name_len := zstrlen(node->loc.file);
	};

	i : u64 mut;
	for(i = 0, i < (node->children_count), i = i + 1)
	{
		child ::= ast_get_child(node, i);
		progwalk_node(child, file_scope);
	}
	return file_scope;
};

progwalk_node ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.structure)))
	{
		// its a structure
		progwalk_structure(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.function)))
	{
		// its a function
		progwalk_function(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.enumeration)))
	{
		// its a enumeration
		progwalk_enumeration(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.assembly)))
	{
		// its a assembly
		progwalk_assembly(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.region)))
	{
		// its a region
		progwalk_region(node, scope);
	}
	if((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.if_block)))
	{
		// its a region
		progwalk_if(node, scope);
	}
};

progwalk_structure ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	structdata ::= node->structure;
	// todo: do something with ast_struct
	memcount ::= node->children_count;
	unfinished_type ::= ty
	{
		.tag := tytag.strct;
		.name := structdata.name;
		.name_len := structdata.name_len;
		.strct := structty
		{
			.members := arena_alloc(global_arena, memcount * __sizeof(tyid));
			.member_names := arena_alloc(global_arena, memcount * __sizeof(u8?));
			.member_name_lens := arena_alloc(global_arena, memcount * __sizeof(u64));
			.members_count := memcount;
			.node := node;
		};
	};
	already ::= scope_find_structure(scope, structdata.name, structdata.name_len);
	if(already != zero)
	{
		psyc_error_begin(node->loc);
		putzstr("duplicate struct ");
		putchar('"');
		putbytes(structdata.name, structdata.name_len);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_current_source_file().src, node, 1, underline_colour.red);
		putchar(10);
		putzstr("previous definition was ");
		putloc(already->node->loc);
		putchar(':');
		already_src ::= program_find_source_file(already->node->loc.file);
		putchar(10);
		ast_print_annotated_source(already_src->src, already->node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	scope_add_structure(scope, structure
	{
		.node := node;
		.type := ty_wrap(unfinished_type, zero);
		.cg := zero;
		.db := zero;
	});
};

progwalk_search_function_descendents_for_locals ::= func(node : ast?, begin_offset : u64, end_offset : u64, func_scope : lexical_scope mut? -> v0)
{
	i : u64 mut;
	last ::= node->children_count - end_offset;
	for(i = begin_offset, i < last, i = i + 1)
	{
		child ::= ast_get_child(node, i);
		if(ast_is_stmt(child, ast_stmt_tag.decl))
		{
			// yes this decl needs to be hoisted
			scope_add_variable(func_scope, variable
			{
				.node := child;
				// need to defer typing this till after progwalk because it could e.g be a struct that isnt declared yet.
				.type := zero;
				.cg := zero;
				.db := zero;			
			});
		}
		// if/else/while/fors need to be scanned too.
		if(ast_is_stmt(child, ast_stmt_tag.if_block))
		{
			// progwalk_if first because if its a static if we want that dealt with now.
			progwalk_if(child, func_scope);
			// ignore cond
			progwalk_search_function_descendents_for_locals(child, 1, 0, func_scope);
		}
		if(ast_is_stmt(child, ast_stmt_tag.else_block))
		{
			progwalk_search_function_descendents_for_locals(child, 0, 0, func_scope);
		}
		if(ast_is_stmt(child, ast_stmt_tag.while_block))
		{
			// ignore cond
			progwalk_search_function_descendents_for_locals(child, 0, 0, func_scope);
		}
		if(ast_is_stmt(child, ast_stmt_tag.for_block))
		{
			// ignore init, cond, iter
			// todo: future harry, if you make the parser allow decls in the init, then do actually progwalk cond.
			progwalk_search_function_descendents_for_locals(child, 3, 0, func_scope);
		}
	}
};

progwalk_function ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_fn ::= node->function;

	func_scope ::= program_add_scope();
	func_scope->name = (ast_fn.name);
	func_scope->name_len = (ast_fn.name_len);
	func_scope->parent_id = (scope->id);

	// so we need to iterate over every child node (aside from child 0 which is the typename)
	// and catch all local variables
	// and then shove them in the scope.
	progwalk_search_function_descendents_for_locals(node, 1, 0, func_scope);

	scope_add_function(scope, function
	{
		.node := node;
		.scope := func_scope;
		.name := ast_fn.name;
		.name_len := ast_fn.name_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_enumeration ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	enumdata ::= node->enumeration;
	entcount ::= node->children_count;
	retty ::= ty
	{
		.tag := tytag.enm;
		.name := enumdata.name;
		.name_len := enumdata.name_len;
		.enm := enumty
		{
			.entries := arena_alloc(global_arena, __sizeof(u64) * entcount);
			.entry_names := arena_alloc(global_arena, __sizeof(u8?) * entcount);
			.entry_name_lens := arena_alloc(global_arena, __sizeof(u64) * entcount);
			.entries_count := entcount;
		};
	};
	i : u64 mut;
	for(i = 0, i < entcount, i = i + 1)
	{
		// ent is going to be a desiginit with a single child value
		ent ::= ast_get_child(node, i);
		ent_val ::= val_convert_to(val_node(ast_get_child(ent, 0)), tyid.s64, ent);
		desig ::= ent->desiginit;
		deref(retty.enm.entry_names # i) = (desig.name);
		deref(retty.enm.entry_name_lens # i) = (desig.name_len);
		deref(retty.enm.entries # i) = val_must_get_integer_literal(ent_val, ent);
	}
	scope_add_enumeration(scope, enumeration
	{
		.node := node;
		.type := ty_wrap(retty, zero);
		.cg := zero;
		.db := zero;
	});
};

progwalk_assembly ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	ast_asm ::= node->assembly;
	// child 0 is the typename
	// child 1 is the unparsed_token symbol
	symbol_node ::= ast_get_child(node, 1);
	//assert(symbol_node->tag == (ast_tag.unparsed_token));
	lexeme ::= symbol_node->utok.tok.lexeme;
	scope_add_assembly(scope, assembly
	{
		.node := node;
		.name := ast_asm.name;
		.name_len := ast_asm.name_len;
		.code := program_current_source_file().src # (lexeme.off);
		.code_len := lexeme.len;
		.constraints := ast_asm.constraints;
		.constraints_len := ast_asm.constraints_len;
		.cg := zero;
		.db := zero;
	});
};

progwalk_region ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	regiondata ::= node->region;
	scope_add_region(scope, region
	{
		.node := node;
		.name := regiondata.name;
		.name_len := regiondata.name_len;
	});
};

progwalk_if ::= func(node : ast mut?, scope : lexical_scope mut? -> v0)
{
	// this exists for 2 reasons:
	// 1. we need to check inside if blocks etc for hoisting reasons
	// 2. we want to evaluate static_ifs as early as possible. i.e now.
	// 3. static_ifs have special functionality such that if they are true then their contents are treated as if they were in the scope that the if is in.

	// 1 and 2
	i : u64 mut;
	ifdata ::= node->ifblk;
	cond_node ::= ast_get_child(node, 0);
	last_child ::= ast_get_child(node, (node->children_count - 1));
	else_node : ast mut? mut := zero;
	if((last_child->tag == (ast_tag.stmt)) && (last_child->stmt == (ast_stmt_tag.else_block)))
	{
		else_node = last_child;
	}

	if(ifdata.is_static)
	{
		cond_val ::= val_node(cond_node);
		if(val_must_get_boolean_literal(cond_val, cond_node))
		{
			// static_if(true)
			// forget about the else node if it exists
			if(else_node != zero)
			{
				node->children_count = (node->children_count - 1);
			}
		}
		else
		{
			// static_if(false)
			// if we have no else then just set childcount to 1
			if(else_node == zero)
			{
				node->children_count = 1;
			}
			else // otherwise, move the elsenode's children to be our own.
			{
				// let the first child stay put as its the cond
				node->children_count = 1;
				// but the rest should be replaced with the children of the else node.
				for(i = 0, i < (else_node->children_count), i = i + 1)
				{
					ast_add_child(node, deref(ast_get_child(else_node, i)), global_arena);
				}
			}
		}


		// 3
		// we no longer care about the condition because of above, iterate over the non-condition children
		// and then progwalk them
		for(i = 1, i < (node->children_count), i = i + 1)
		{
			progwalk_node(ast_get_child(node, i), scope);
		}
		// and yes, when you're codegenning you ignore the condition of a static-if and just codegen its children as if they were part of the parent scope (this was known as a composite in psyc 1.x)
	}
};
