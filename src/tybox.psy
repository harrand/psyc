// stores a bunch of types
// most likely you will not use this directly - the global program variable 'prog' has its own tybox which is used for everything and wrappers exist e.g ty_wrap and ty_unwrap
tybox ::= struct
{
	data : ty mut?;
	data_count : u64;
	data_cap : u64;
};

// create a new box. it will have the prims but nothing else.
tybox_create ::= func(capacity : u64 -> tybox)
{
	ret ::= zero@tybox mut;
	// all tyboxes include primitives
	ret.data_cap = (capacity + __countof(tyid));

	ret.data = arena_alloc(global_arena, __sizeof(deref (ret.data)) * (ret.data_cap));
	ret.data_count = impl_tybox_populate_prims(ref ret);

	return ret;
};

// add a new type to the box and return its id. dont check for duplicates.
tybox_do_add ::= func(box : tybox mut?, newty : ty -> tyid)
{
	while(box->data_count >= (box->data_cap))
	{
		oldcap ::= box->data_cap;
		olddata ::= box->data;
		box->data_cap = (box->data_cap * 2);
		box->data = arena_alloc(global_arena, __sizeof(deref(box->data)) * (box->data_cap));
		memcopy(box->data, olddata, oldcap * __sizeof(deref(box->data)));
	}
	id ::= box->data_count;
	deref(box->data # id) = newty;
	box->data_count = (box->data_count + 1);
	return id@s64@tyid;
};

// like tybox_do_add, but if the type already exists return its id.
tybox_add ::= func(box : tybox mut?, newty : ty -> tyid)
{
	already ::= tybox_find(box, newty.name, newty.name_len);
	if(already != zero)
	{
		return already;
	}
	return tybox_do_add(box, newty);
};

tybox_find ::= func(box : tybox?, name : u8?, name_len : u64 -> tyid)
{
	// linear search :/
	i : u64 mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		cur ::= box->data # i;
		if(cur->name_len == name_len)
		{
			if(streql_n(cur->name, name, name_len))
			{
				return i@tyid;
			}
		}
	}
	return zero;
};

// add an empty type to the box and return its id
tybox_add_empty ::= func(box : tybox mut? -> tyid)
{
	return tybox_do_add(box, zero);
};

tybox_add_ptr ::= func(box : tybox mut?, underlying : tyid -> tyid)
{
	u ::= tybox_at(box, underlying);
	name : u8 mut? := arena_alloc(string_arena, u->name_len + 1);
	memcopy(name, u->name, u->name_len);
	deref(name # (u->name_len)) = '?';
	return tybox_add(box, ty
	{
		.tag := tytag.ptr;
		.name := name;
		.name_len := u->name_len + 1;
		.base := underlying;
	});
};

tybox_add_array ::= func(box : tybox mut?, underlying : tyid, array_len : u64 -> tyid)
{
	u ::= tybox_at(box, underlying);
	name : u8 mut? := arena_alloc(string_arena, u->name_len + 3);
	memcopy(name, u->name, u->name_len);
	deref(name # (u->name_len + 0)) = '[';
	deref(name # (u->name_len + 0)) = '_';
	deref(name # (u->name_len + 2)) = ']';
	return tybox_add(box, ty
	{
		.tag := tytag.arr;
		.name := name;
		.name_len := u->name_len + 1;
		.base := underlying;
	});
};

// get the type within a box at the given id
tybox_at ::= func(box : tybox mut?, id : tyid -> ty mut?)
{
	return box->data # (id@s64);
};

// implementation detail. given a fully empty box, populate the prims.
impl_tybox_populate_prims ::= func(box : tybox mut? -> u64)
{
	prim_count ::= __countof(tyid);
	i : u64 mut;
	for(i = 0, i < prim_count, i = i + 1)
	{
		prim ::= i@tyid;
		name ::= __enumname(prim);
		deref(box->data # i) = ty
		{
			.tag := tytag.prim;
			.name := name;
			.name_len := zstrlen(name);
			.base := prim;
		};
	}
	return prim_count;
};
