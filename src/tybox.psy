// stores a bunch of types
// most likely you will not use this directly - the global program variable 'prog' has its own tybox which is used for everything and wrappers exist e.g ty_wrap and ty_unwrap
tybox : struct
{
	data : ty mut?;
	data_count : u64;
	data_cap : u64;
};

// create a new box. it will have the prims but nothing else.
tybox_create : func(capacity : u64 -> tybox)
{
	ret ::= zero@tybox mut;
	// all tyboxes include primitives
	ret.data_cap = (capacity + __countof(tyid));

	ret.data = arena_alloc(global_arena, __sizeof(deref (ret.data)) * (ret.data_cap));
	ret.data_count = impl_tybox_populate_prims(ref ret);

	return ret;
};

// add a new type to the box and return its id. dont check for duplicates.
tybox_do_add : func(box : tybox mut?, newty : ty -> tyid)
{
	while(box->data_count >= (box->data_cap))
	{
		oldcap ::= box->data_cap;
		olddata ::= box->data;
		box->data_cap = (box->data_cap * 2);
		box->data = arena_alloc(global_arena, __sizeof(deref(box->data)) * (box->data_cap));
		memcopy(box->data, olddata, oldcap * __sizeof(deref(box->data)));
	}
	id ::= box->data_count;
	deref(box->data # id) = newty;
	box->data_count = (box->data_count + 1);
	return id@s64@tyid;
};

// like tybox_do_add, but if the type already exists return its id.
tybox_add : func(box : tybox mut?, newty : ty -> tyid)
{
	already ::= tybox_find(box, newty.name, newty.name_len);
	if(already != zero)
	{
		return already;
	}
	return tybox_do_add(box, newty);
};

// remember doesnt really work for qualifiers
tybox_find : func(box : tybox?, name : u8?, name_len : u64 -> tyid)
{
	// linear search :/
	i : u64 mut;
	for(i = 0; i < (box->data_count); i = i + 1)
	{
		cur ::= box->data # i;
		if(cur->name_len == name_len)
		{
			if(streql_n(cur->name, name, name_len))
			{
				return i@tyid;
			}
		}
	}
	return zero;
};

// add an empty type to the box and return its id
tybox_add_empty : func(box : tybox mut? -> tyid)
{
	return tybox_do_add(box, zero);
};

tybox_add_ptr : func(box : tybox mut?, underlying : tyid -> tyid)
{
	u ::= tybox_at(box, underlying);
	name : u8 mut? := arena_alloc(string_arena, u->name_len + quals_max_strlen + 1);
	memcopy(name, u->name, u->name_len);
	// need to add extra quals
	name_offset : u64 mut := u->name_len;
	if(ty_has_qual(underlying, tyqual.qual_mut))
	{
		memcopy(name # (name_offset), qual_str_mut, zstrlen(qual_str_mut));
		name_offset = (name_offset + zstrlen(qual_str_mut));
	}
	if(ty_has_qual(underlying, tyqual.qual_weak))
	{
		memcopy(name # (name_offset), qual_str_weak, zstrlen(qual_str_weak));
		name_offset = (name_offset + zstrlen(qual_str_weak));
	}
	if(ty_has_qual(underlying, tyqual.qual_static))
	{
		memcopy(name # (name_offset), qual_str_static, zstrlen(qual_str_static));
		name_offset = (name_offset + zstrlen(qual_str_static));
	}
	deref(name # name_offset) = '?';
	return tybox_add(box, ty
	{
		.tag := tytag.ptr;
		.name := name;
		.name_len := name_offset + 1;
		.base := underlying;
	});
};

tybox_add_array : func(box : tybox mut?, underlying : tyid, array_len : u64 -> tyid)
{
	u ::= tybox_at(box, underlying);
	len_strlen ::= lenuint(array_len);
	name : u8 mut? := arena_alloc(string_arena, u->name_len + quals_max_strlen + 2 + len_strlen);
	memcopy(name, u->name, u->name_len);
	name_offset : u64 mut := u->name_len;
	if(ty_has_qual(underlying, tyqual.qual_mut))
	{
		memcopy(name # (name_offset), qual_str_mut, zstrlen(qual_str_mut));
		name_offset = (name_offset + zstrlen(qual_str_mut));
	}
	if(ty_has_qual(underlying, tyqual.qual_weak))
	{
		memcopy(name # (name_offset), qual_str_weak, zstrlen(qual_str_weak));
		name_offset = (name_offset + zstrlen(qual_str_weak));
	}
	if(ty_has_qual(underlying, tyqual.qual_static))
	{
		memcopy(name # (name_offset), qual_str_static, zstrlen(qual_str_static));
		name_offset = (name_offset + zstrlen(qual_str_static));
	}
	deref(name # (name_offset + 0)) = '[';
	sputuint(name # (name_offset + 1), array_len);
	deref(name # (name_offset + 1 + len_strlen)) = ']';
	return tybox_add(box, ty
	{
		.tag := tytag.arr;
		.name := name;
		.name_len := name_offset + 2 + len_strlen;
		.base := underlying;
		.array_len := array_len;
	});
};

tybox_add_function : func(box : tybox mut?, ret_id : tyid, param_ids : tyid?, params_count : u64 -> tyid)
{
	i : u64 mut;
	// need to calculate the name len... ugh...
	maximum_name_len : u64 mut := zstrlen("func( -> )");
	for(i = 0; i < params_count; i = i + 1)
	{
		// include enough space for the actual name
		// + qual_max_strlen
		// + a space and comma
		maximum_name_len = (maximum_name_len + (tybox_at(box, ty_clear_all_quals(deref(param_ids # i)))->name_len) + quals_max_strlen + 2);
	}
	maximum_name_len = (maximum_name_len + quals_max_strlen + 2 + tybox_at(box, ty_clear_all_quals(ret_id))->name_len);
	name : u8 mut? := arena_alloc(string_arena, maximum_name_len);

	funcname_prefix ::= "func(";
	name_offset : u64 mut := 0;
	memcopy(name # name_offset, funcname_prefix, zstrlen(funcname_prefix));
	name_offset = name_offset + zstrlen(funcname_prefix);
	// ok do params
	for(i = 0; i < params_count; i = i + 1)
	{
		param_id ::= [param_ids # i];
		param ::= tybox_at(box, ty_clear_all_quals(param_id));
		memcopy(name # name_offset, param->name, param->name_len);
		name_offset = (name_offset + param->name_len);
		if(ty_has_qual(param_id, tyqual.qual_mut))
		{
			memcopy(name # (name_offset), qual_str_mut, zstrlen(qual_str_mut));
			name_offset = (name_offset + zstrlen(qual_str_mut));
		}
		if(ty_has_qual(param_id, tyqual.qual_weak))
		{
			memcopy(name # (name_offset), qual_str_weak, zstrlen(qual_str_weak));
			name_offset = (name_offset + zstrlen(qual_str_weak));
		}
		if(ty_has_qual(param_id, tyqual.qual_static))
		{
			memcopy(name # (name_offset), qual_str_static, zstrlen(qual_str_static));
			name_offset = (name_offset + zstrlen(qual_str_static));
		}
		if(i < (params_count - 1))
		{
			// not last param, add the comma and space
			per_param_suffix ::= ", ";
			memcopy(name # name_offset, per_param_suffix, zstrlen(per_param_suffix));
			name_offset = (name_offset + zstrlen(per_param_suffix));
		}
	}
	pre_retty_suffix ::= " -> ";
	memcopy(name # name_offset, pre_retty_suffix, zstrlen(pre_retty_suffix));
	name_offset = (name_offset + zstrlen(pre_retty_suffix));
	// now do the retty
	retty ::= tybox_at(box, ty_clear_all_quals(ret_id));
	memcopy(name # name_offset, retty->name, retty->name_len);
	name_offset = (name_offset + retty->name_len);
	if(ty_has_qual(ret_id, tyqual.qual_mut))
	{
		memcopy(name # (name_offset), qual_str_mut, zstrlen(qual_str_mut));
		name_offset = (name_offset + zstrlen(qual_str_mut));
	}
	if(ty_has_qual(ret_id, tyqual.qual_weak))
	{
		memcopy(name # (name_offset), qual_str_weak, zstrlen(qual_str_weak));
		name_offset = (name_offset + zstrlen(qual_str_weak));
	}
	if(ty_has_qual(ret_id, tyqual.qual_static))
	{
		memcopy(name # (name_offset), qual_str_static, zstrlen(qual_str_static));
		name_offset = (name_offset + zstrlen(qual_str_static));
	}
	// finally add a ) at the end
	deref(name # name_offset) = ')';
	name_offset = name_offset + 1;
	return tybox_add(box, ty
	{
		.tag := tytag.fn;
		.name := name;
		.name_len := name_offset;
		.fn := fnty
		{
			.return_type := ret_id;
			.param_types := param_ids;
			.params_count := params_count;
		};
	});
};

// get the type within a box at the given id
tybox_at : func(box : tybox mut?, id : tyid -> ty mut?)
{
	return box->data # (id@s64);
};

tybox_print_all : func(box : tybox? -> v0)
{
	i : u64 mut;
	for(i = 0; i < (box->data_count); i = i + 1)
	{
		id ::= i@tyid;
		t ::= ty_unwrap(id);
		putuint(i);
		putzstr(": ");
		putty(id);
		putzstr(" (");
		putzstr(__enumname(t->tag));
		putzstr(")");
		putchar(10);
	}
};

// implementation detail. given a fully empty box, populate the prims.
impl_tybox_populate_prims : func(box : tybox mut? -> u64)
{
	prim_count ::= __countof(tyid);
	i : u64 mut;
	// badtype = zero
	badtype_name ::= "<invalid type>";
	[box->data # 0] = ty{.tag := zero; .name := badtype_name; .name_len := zstrlen(badtype_name);};
	for(i = 1; i < (prim_count + 1); i = i + 1)
	{
		prim ::= i@tyid;
		name ::= __enumname(prim);
		deref(box->data # i) = ty
		{
			.tag := tytag.prim;
			.name := name;
			.name_len := zstrlen(name);
			.base := prim;
		};
	}
	return prim_count;
};
