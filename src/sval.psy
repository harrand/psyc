sval_tag ::= enum
{
	.zero_value := 1;
	.primitive := 2;
	.array := 3;
	//.structure := 4;
};

sval ::= struct
{
	tag : sval_tag;
	primitive : ast_literal;
	array : v0?;
	array_len : u64;
};

sval_primitive ::= func(primitive : ast_literal -> sval)
{
	return sval
	{
		.tag := sval_tag.primitive;
		.primitive := primitive;
	};
};

sval_zero ::= func(-> sval)
{
	return sval{.tag := sval_tag.zero_value;};
};

sval_node ::= func(node : ast? -> sval)
{
	if(ast_is_expr(node, ast_expr_tag.literal))
	{
		return sval_primitive(node->literal);
	}
	if(ast_is_expr(node, ast_expr_tag.unop))
	{
		operand ::= sval_node(ast_get_child(node, 0));
		return sval_unop(node->unop, ref operand, node);
	}
	if(ast_is_expr(node, ast_expr_tag.biop))
	{
		lhs ::= sval_node(ast_get_child(node, 0));
		rhs ::= sval_node(ast_get_child(node, 1));
		return sval_biop(node->biop, ref lhs, ref rhs, node);
	}
	return zero;
};

sval_is_valid ::= func(s : sval -> bool)
{
	return s.tag != zero;
};

sval2type ::= func(s : sval -> tyid)
{
	if(s.tag == (sval_tag.primitive))
	{
		literal ::= s.primitive;
		if(literal.tag == (ast_literal_tag.integer))
		{
			return tyid_integral_literal();
		}
		if(literal.tag == (ast_literal_tag.floating_point))
		{
			return tyid_floating_point_literal();
		}
		if(literal.tag == (ast_literal_tag.char))
		{
			return tyid_char_literal();
		}
		if(literal.tag == (ast_literal_tag.string))
		{
			return tyid_string_literal();
		}
		if(literal.tag == (ast_literal_tag.boolean))
		{
			return tyid_bool_literal();
		}
	}
	return zero;
};

// add, sub etc... still kinda get into type conversion rules
// e.g adding a zero_value to a integral or an integral to a floating-point.
sval_convert_to ::= func(s : sval, to : tyid, source : ast? -> sval)
{
	ret_sval : sval mut := zero;
	toty ::= ty_unwrap(to);
	if(s.tag == (sval_tag.zero_value))
	{
		ret_sval.tag = (sval_tag.primitive);
		ret_sval.primitive = zero;
		// tag does need to match the primty.
		if(ty_is_integral(to))
		{
			ret_sval.primitive.tag = (ast_literal_tag.integer);
			return ret_sval;
		}
		if(ty_is_floating_point(to))
		{
			ret_sval.primitive.tag = (ast_literal_tag.floating_point);
			return ret_sval;
		}
		psyc_panic_begin(source->loc);
		putzstr("missing codepath in sval_must_convert_to for a zero_value converting to ");
		putchar('"');
		putty(to);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
		return ret_sval;
	}
	from ::= sval2type(s);
	ty_ensure_convertible_to(from, to, source);
	// prims
	toprim ::= toty->base;
	if(s.tag == (sval_tag.primitive))
	{
		fromprim ::= s.primitive;
		if(toty->tag == (tytag.prim))
		{
			// integer 2 x
			if(fromprim.tag == (ast_literal_tag.integer))
			{
				if(ty_is_integral(to))
				{
					// already done.
					return s;
				}
				if(ty_is_floating_point(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.floating_point);
					ret_sval.primitive.floating_point = (s.primitive.integer@_);
					return ret_sval;
				}
				if(ty_is_bool(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.boolean);
					ret_sval.primitive.boolean = (s.primitive.integer != 0);
					return ret_sval;
				}
				if(ty_is_char(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.char);
					ret_sval.primitive.chars = arena_alloc(global_arena, 1);
					ret_sval.primitive.chars_len = 1;
					deref(ret_sval.primitive.chars) = (s.primitive.integer@_);
				}
			}
			// floating point 2 x
			if(fromprim.tag == (ast_literal_tag.floating_point))
			{
				if(ty_is_integral(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.integer);
					ret_sval.primitive.integer = (s.primitive.floating_point@_);
				}
				if(ty_is_floating_point(to))
				{
					// already done.
					return s;
				}
				if(ty_is_char(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.char);
					ret_sval.primitive.chars = arena_alloc(global_arena, 1);
					ret_sval.primitive.chars_len = 1;
					deref(ret_sval.primitive.chars) = (s.primitive.floating_point@_);
				}
			}
			// char 2 x
			if(fromprim.tag == (ast_literal_tag.char))
			{
				ch ::= deref(s.primitive.chars # 0);
				if(ty_is_integral(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.integer);
					ret_sval.primitive.integer = (ch@_);
					return ret_sval;
				}
				if(ty_is_floating_point(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.floating_point);
					ret_sval.primitive.floating_point = (ch@_);
					return ret_sval;
				}
				if(ty_is_char(to))
				{
					// already done.
					return s;
				}
				if(ty_is_bool(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.boolean);
					ret_sval.primitive.boolean = (ch != 0);
					return ret_sval;
				}
			}
			// boolean 2 x
			if(fromprim.tag == (ast_literal_tag.boolean))
			{
				if(ty_is_integral(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.integer);
					if(s.primitive.boolean)
					{
						ret_sval.primitive.integer = 1;
					}
					else
					{
						ret_sval.primitive.integer = 0;
					}
					return ret_sval;
				}
				if(ty_is_char(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.char);
					ret_sval.primitive.chars = arena_alloc(global_arena, 1);
					ret_sval.primitive.chars_len = 1;
					if(s.primitive.boolean)
					{
						deref(ret_sval.primitive.chars) = 1;
					}
					else
					{
						deref(ret_sval.primitive.chars) = 0;
					}
				}
				if(ty_is_bool(to))
				{
					// already done.
					return s;
				}
			}
		}
	}
	if(from == tyid_string_literal())
	{
		if(to == tyid_string_literal())
		{
			return s;
		}
	}
	psyc_panic_begin(source->loc);
	putzstr("missing codepath in sval_must_convert_to for a sval_tag.");
	putzstr(__enumname(s.tag));
	putzstr(" converting to ");
	putchar('"');
	putty(to);
	putchar('"');
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_int ::= func(op : ast_unop, operand : s64 mut?, source : ast? -> s64)
{
	if(op == (ast_unop.minus))
	{
		return -deref(operand);
	}
	if(op == (ast_unop.bitwise_invert))
	{
		return ~deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on an integral literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_float ::= func(op : ast_unop, operand : f64 mut?, source : ast? -> f64)
{
	if(op == (ast_unop.minus))
	{
		return -deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a floating-point literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_bool ::= func(op : ast_unop, operand : bool mut?, source : ast? -> bool)
{
	if(op == (ast_unop.logical_invert))
	{
		return !deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a boolean literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_int ::= func(op : ast_biop, lhs : s64 mut?, rhs : s64 mut?, source : ast? -> s64)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs))@_;
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs))@_;
	}
	if(op == (ast_biop.compare_less))
	{
		return (deref(lhs) < deref(rhs))@_;
	}
	if(op == (ast_biop.compare_less_equal))
	{
		return (deref(lhs) <= deref(rhs))@_;
	}
	if(op == (ast_biop.compare_greater))
	{
		return (deref(lhs) > deref(rhs))@_;
	}
	if(op == (ast_biop.compare_greater_equal))
	{
		return (deref(lhs) >= deref(rhs))@_;
	}
	if(op == (ast_biop.add))
	{
		return deref(lhs) + deref(rhs);
	}
	if(op == (ast_biop.sub))
	{
		return deref(lhs) - deref(rhs);
	}
	if(op == (ast_biop.mul))
	{
		return deref(lhs) * deref(rhs);
	}
	if(op == (ast_biop.div))
	{
		if(deref(rhs) == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("statically detected integer divide-by-zero");
			psyc_diag_end();
			psyc_exit_failure();
		}
		return deref(lhs) / deref(rhs);
	}
	if(op == (ast_biop.bitwise_or))
	{
		return deref(lhs) | deref(rhs);
	}
	if(op == (ast_biop.bitwise_and))
	{
		return deref(lhs) & deref(rhs);
	}
	if(op == (ast_biop.xor))
	{
		return deref(lhs) ^ deref(rhs);
	}
	if(op == (ast_biop.bitshift_left))
	{
		return deref(lhs) << deref(rhs);
	}
	if(op == (ast_biop.bitshift_right))
	{
		return deref(lhs) >> deref(rhs);
	}
	if(op == (ast_biop.modulo))
	{
		return deref(lhs) % deref(rhs);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two integral literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_float ::= func(op : ast_biop, lhs : f64 mut?, rhs : f64 mut?, source : ast? -> f64)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_less))
	{
		return (deref(lhs) < deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_less_equal))
	{
		return (deref(lhs) <= deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_greater))
	{
		return (deref(lhs) > deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_greater_equal))
	{
		return (deref(lhs) >= deref(rhs))@s64@_;
	}
	if(op == (ast_biop.add))
	{
		return deref(lhs) + deref(rhs);
	}
	if(op == (ast_biop.sub))
	{
		return deref(lhs) - deref(rhs);
	}
	if(op == (ast_biop.mul))
	{
		return deref(lhs) * deref(rhs);
	}
	if(op == (ast_biop.div))
	{
		// floating point divide-by-zero is permitted statically.
		return deref(lhs) / deref(rhs);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two floating-point literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_bool ::= func(op : ast_biop, lhs : bool mut?, rhs : bool mut?, source : ast? -> bool)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs));
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs));
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two boolean literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

sval_unop ::= func(op : ast_unop, s : sval mut?, source : ast? -> sval)
{
	type ::= sval2type(deref s);
	if(s->tag == (sval_tag.primitive))
	{
		if(ty_is_integral(type))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.integer;
					.integer := apply_unop_int(op, ref(s->primitive.integer), source);
				};
			};
		}
		if(ty_is_floating_point(type))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.integer;
					.floating_point := apply_unop_float(op, ref(s->primitive.floating_point), source);
				};
			};
		}
		if(ty_is_bool(type))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.boolean;
					.boolean := apply_unop_bool(op, ref(s->primitive.boolean), source);
				};
			};
		}
		psyc_error_begin(source->loc);
		putzstr("cannot perform unary ");
		putzstr(__enumname(op));
		putzstr(" operation on a ");
		putty(type);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
		psyc_diag_end();
		psyc_exit_failure();
		return zero;
	}
	psyc_error_begin(source->loc);
	putzstr("cannot perform unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a non-primitive ");
	putty(type);
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

sval_biop ::= func(op : ast_biop, lhs : sval mut?, rhs : sval mut?, source : ast? -> sval)
{
	// so this one is a little more complicated as we need to deal with zero-value.
	// these types are immediately wrong if these are zero values so lets check that now.
	lhs_type : tyid mut := sval2type(deref lhs);
	rhs_type : tyid mut := sval2type(deref rhs);
	if(lhs->tag == (sval_tag.zero_value))
	{
		if(rhs->tag == (sval_tag.primitive))
		{
			lhs_type = rhs_type;
		}
		else
		{
			psyc_error_begin(source->loc);
			putzstr("binary operator ");
			putzstr(__enumname(op));
			putzstr(" with lhs as 'zero' is only valid if the rhs is a primitive type, but it is a ");
			putty(rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
	if(rhs->tag == (sval_tag.zero_value))
	{
		if(lhs->tag == (sval_tag.primitive))
		{
			rhs_type = lhs_type;
		}
		else
		{
			psyc_error_begin(source->loc);
			putzstr("binary operator ");
			putzstr(__enumname(op));
			putzstr(" with rhs as 'zero' is only valid if the lhs is a primitive type, but it is a ");
			putty(lhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}

	arith_ty ::= ty_of_arithmetic(lhs_type, rhs_type);

	// list all the ops that ty_of_arithmetic will help with
	if(
		(op == (ast_biop.add)) ||
		(op == (ast_biop.sub)) ||
		(op == (ast_biop.mul)) ||
		(op == (ast_biop.div)) ||
		(op == (ast_biop.bitwise_or)) ||
		(op == (ast_biop.bitwise_and)) ||
		(op == (ast_biop.xor)) ||
		(op == (ast_biop.bitshift_left)) ||
		(op == (ast_biop.bitshift_right)) ||
		(op == (ast_biop).modulo)
	)
	{
		if(arith_ty == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("binary ");
			putzstr(__enumname(op));
			putzstr(" operation is not valid on a ");
			putty(lhs_type);
			putzstr(" and a ");
			putty(rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// okay great
		deref(lhs) = sval_convert_to(deref lhs, arith_ty, source);
		deref(rhs) = sval_convert_to(deref rhs, arith_ty, source);
		if(ty_is_integral(arith_ty))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.integer;
					.integer := apply_biop_int(op, ref(lhs->primitive.integer), ref(rhs->primitive.integer), source);
				};
			};
		}
		if(ty_is_floating_point(arith_ty))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.floating_point;
					.floating_point := apply_biop_float(op, ref(lhs->primitive.floating_point), ref(rhs->primitive.floating_point), source);
				};
			};
		}
		if(ty_is_bool(arith_ty))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.boolean;
					.boolean := apply_biop_bool(op, ref(lhs->primitive.boolean), ref(rhs->primitive.boolean), source);
				};
			};
		}
	}
	// list all the comparison ops that return bool
	if(
		(op == (ast_biop.compare_equal)) ||
		(op == (ast_biop.compare_not_equal)) ||
		(op == (ast_biop.compare_less)) ||
		(op == (ast_biop.compare_less_equal)) ||
		(op == (ast_biop.compare_greater)) ||
		(op == (ast_biop.compare_greater_equal))
	)
	{
		// convert rhs type to lhs type
		// still use arithmetic type
		if(arith_ty == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("binary ");
			putzstr(__enumname(op));
			putzstr(" operation is not valid on a ");
			putty(lhs_type);
			putzstr(" and a ");
			putty(rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// okay great
		deref(lhs) = sval_convert_to(deref lhs, arith_ty, source);
		deref(rhs) = sval_convert_to(deref rhs, arith_ty, source);
		if(ty_is_integral(arith_ty))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.boolean;
					.boolean := apply_biop_int(op, ref(lhs->primitive.integer), ref(rhs->primitive.integer), source)@bool;
				};
			};
		}
		if(ty_is_floating_point(arith_ty))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.boolean;
					.boolean := apply_biop_float(op, ref(lhs->primitive.floating_point), ref(rhs->primitive.floating_point), source)@s64@bool;
				};
			};
		}
		if(ty_is_bool(arith_ty))
		{
			return sval
			{
				.tag := sval_tag.primitive;
				.primitive := ast_literal
				{
					.tag := ast_literal_tag.boolean;
					.boolean := apply_biop_bool(op, ref(lhs->primitive.boolean), ref(rhs->primitive.boolean), source);
				};
			};
		}
	}
	// logical_or and logical_and are still missing i think. need to confirm theyre both bools and then return the sval comparison result.
	// also havent done biop.at but i basically dont expect that to really be used in svals (todo: sval arrays)
	psyc_panic_begin(source->loc);
	putzstr("control reached end of sval_biop. either your code is wrong or mine havent figured it out yet.");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};
