sval_tag ::= enum
{
	.zero_value := 1;
	.primitive := 2;
	.array := 3;
	//.structure := 4;
};

sval ::= struct
{
	tag : sval_tag;
	primitive : ast_literal;
	array : v0?;
	array_len : u64;
};

sval_primitive ::= func(primitive : ast_literal -> sval)
{
	return sval
	{
		.tag := sval_tag.primitive;
		.primitive := primitive;
	};
};

sval_zero ::= func(-> sval)
{
	return sval{.tag := sval_tag.zero_value;};
};

sval_node ::= func(node : ast? -> sval)
{
	if(ast_is_expr(node, ast_expr_tag.literal))
	{
		return sval_primitive(node->literal);
	}
	return zero;
};

sval_is_valid ::= func(s : sval -> bool)
{
	return s.tag != zero;
};

sval2type ::= func(s : sval -> tyid)
{
	if(s.tag == (sval_tag.primitive))
	{
		literal ::= s.primitive;
		if(literal.tag == (ast_literal_tag.integer))
		{
			return tyid_integral_literal();
		}
		if(literal.tag == (ast_literal_tag.floating_point))
		{
			return tyid_floating_point_literal();
		}
		if(literal.tag == (ast_literal_tag.char))
		{
			return tyid_char_literal();
		}
		if(literal.tag == (ast_literal_tag.string))
		{
			return tyid_string_literal();
		}
		if(literal.tag == (ast_literal_tag.boolean))
		{
			return tyid_bool_literal();
		}
	}
	return zero;
};

// add, sub etc... still kinda get into type conversion rules
// e.g adding a zero_value to a integral or an integral to a floating-point.
sval_convert_to ::= func(s : sval, to : tyid, source : ast? -> sval)
{
	ret_sval : sval mut := zero;
	toty ::= ty_unwrap(to);
	if(s.tag == (sval_tag.zero_value))
	{
		ret_sval.tag = (sval_tag.primitive);
		ret_sval.primitive = zero;
		// tag does need to match the primty.
		if(ty_is_integral(to))
		{
			ret_sval.primitive.tag = (ast_literal_tag.integer);
			return ret_sval;
		}
		if(ty_is_floating_point(to))
		{
			ret_sval.primitive.tag = (ast_literal_tag.floating_point);
			return ret_sval;
		}
		psyc_panic_begin(source->loc);
		putzstr("missing codepath in sval_must_convert_to for a zero_value converting to ");
		putchar('"');
		putty(to);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
		return ret_sval;
	}
	from ::= sval2type(s);
	ty_ensure_convertible_to(from, to, source);
	// prims
	toprim ::= toty->base;
	if(s.tag == (sval_tag.primitive))
	{
		fromprim ::= s.primitive;
		if(toty->tag == (tytag.prim))
		{
			// integer 2 x
			if(fromprim.tag == (ast_literal_tag.integer))
			{
				if(ty_is_integral(to))
				{
					// already done.
					return s;
				}
				if(ty_is_floating_point(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.floating_point);
					ret_sval.primitive.floating_point = (s.primitive.integer@_);
					return ret_sval;
				}
				if(ty_is_bool(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.boolean);
					ret_sval.primitive.boolean = (s.primitive.integer != 0);
					return ret_sval;
				}
				if(ty_is_char(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.char);
					ret_sval.primitive.chars = arena_alloc(global_arena, 1);
					ret_sval.primitive.chars_len = 1;
					deref(ret_sval.primitive.chars) = (s.primitive.integer@_);
				}
			}
			// floating point 2 x
			if(fromprim.tag == (ast_literal_tag.floating_point))
			{
				if(ty_is_integral(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.integer);
					ret_sval.primitive.integer = (s.primitive.floating_point@_);
				}
				if(ty_is_floating_point(to))
				{
					// already done.
					return s;
				}
				if(ty_is_char(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.char);
					ret_sval.primitive.chars = arena_alloc(global_arena, 1);
					ret_sval.primitive.chars_len = 1;
					deref(ret_sval.primitive.chars) = (s.primitive.floating_point@_);
				}
			}
			// char 2 x
			if(fromprim.tag == (ast_literal_tag.char))
			{
				ch ::= deref(s.primitive.chars # 0);
				if(ty_is_integral(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.integer);
					ret_sval.primitive.integer = (ch@_);
					return ret_sval;
				}
				if(ty_is_floating_point(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.floating_point);
					ret_sval.primitive.floating_point = (ch@_);
					return ret_sval;
				}
				if(ty_is_char(to))
				{
					// already done.
					return s;
				}
				if(ty_is_bool(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.boolean);
					ret_sval.primitive.boolean = (ch != 0);
					return ret_sval;
				}
			}
			// boolean 2 x
			if(fromprim.tag == (ast_literal_tag.boolean))
			{
				if(ty_is_integral(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.integer);
					if(s.primitive.boolean)
					{
						ret_sval.primitive.integer = 1;
					}
					else
					{
						ret_sval.primitive.integer = 0;
					}
					return ret_sval;
				}
				if(ty_is_char(to))
				{
					ret_sval.primitive.tag = (ast_literal_tag.char);
					ret_sval.primitive.chars = arena_alloc(global_arena, 1);
					ret_sval.primitive.chars_len = 1;
					if(s.primitive.boolean)
					{
						deref(ret_sval.primitive.chars) = 1;
					}
					else
					{
						deref(ret_sval.primitive.chars) = 0;
					}
				}
				if(ty_is_bool(to))
				{
					// already done.
					return s;
				}
			}
		}
	}
	if(from == tyid_string_literal())
	{
		if(to == tyid_string_literal())
		{
			return s;
		}
	}
	psyc_panic_begin(source->loc);
	putzstr("missing codepath in sval_must_convert_to for a sval_tag.");
	putzstr(__enumname(s.tag));
	putzstr(" converting to ");
	putchar('"');
	putty(to);
	putchar('"');
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_int ::= func(op : ast_unop, operand : s64 mut?, source : ast? -> s64)
{
	if(op == (ast_unop.minus))
	{
		return -deref(operand);
	}
	if(op == (ast_unop.bitwise_invert))
	{
		return ~deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on an integral literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_float ::= func(op : ast_unop, operand : f64 mut?, source : ast? -> f64)
{
	if(op == (ast_unop.minus))
	{
		return -deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a floating-point literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_bool ::= func(op : ast_unop, operand : bool mut?, source : ast? -> bool)
{
	if(op == (ast_unop.logical_invert))
	{
		return !deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a boolean literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_int ::= func(op : ast_biop, lhs : s64 mut?, rhs : s64 mut?, source : ast? -> s64)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs))@_;
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs))@_;
	}
	if(op == (ast_biop.compare_less))
	{
		return (deref(lhs) < deref(rhs))@_;
	}
	if(op == (ast_biop.compare_less_equal))
	{
		return (deref(lhs) <= deref(rhs))@_;
	}
	if(op == (ast_biop.compare_greater))
	{
		return (deref(lhs) > deref(rhs))@_;
	}
	if(op == (ast_biop.compare_greater_equal))
	{
		return (deref(lhs) >= deref(rhs))@_;
	}
	if(op == (ast_biop.add))
	{
		return deref(lhs) + deref(rhs);
	}
	if(op == (ast_biop.sub))
	{
		return deref(lhs) - deref(rhs);
	}
	if(op == (ast_biop.mul))
	{
		return deref(lhs) * deref(rhs);
	}
	if(op == (ast_biop.div))
	{
		if(deref(rhs) == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("statically detected integer divide-by-zero");
			psyc_diag_end();
			psyc_exit_failure();
		}
		return deref(lhs) / deref(rhs);
	}
	if(op == (ast_biop.bitwise_or))
	{
		return deref(lhs) | deref(rhs);
	}
	if(op == (ast_biop.bitwise_and))
	{
		return deref(lhs) & deref(rhs);
	}
	if(op == (ast_biop.xor))
	{
		return deref(lhs) ^ deref(rhs);
	}
	if(op == (ast_biop.bitshift_left))
	{
		return deref(lhs) << deref(rhs);
	}
	if(op == (ast_biop.bitshift_right))
	{
		return deref(lhs) >> deref(rhs);
	}
	if(op == (ast_biop.modulo))
	{
		return deref(lhs) % deref(rhs);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two integral literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_float ::= func(op : ast_biop, lhs : f64 mut?, rhs : f64 mut?, source : ast? -> f64)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_less))
	{
		return (deref(lhs) < deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_less_equal))
	{
		return (deref(lhs) <= deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_greater))
	{
		return (deref(lhs) > deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_greater_equal))
	{
		return (deref(lhs) >= deref(rhs))@s64@_;
	}
	if(op == (ast_biop.add))
	{
		return deref(lhs) + deref(rhs);
	}
	if(op == (ast_biop.sub))
	{
		return deref(lhs) - deref(rhs);
	}
	if(op == (ast_biop.mul))
	{
		return deref(lhs) * deref(rhs);
	}
	if(op == (ast_biop.div))
	{
		// floating point divide-by-zero is permitted statically.
		return deref(lhs) / deref(rhs);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two floating-point literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_bool ::= func(op : ast_biop, lhs : bool mut?, rhs : bool mut?, source : ast? -> bool)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs));
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs));
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two boolean literals, which is not valid");
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};
