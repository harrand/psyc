// all compile-time value modifications live here
// basically this is constexpr land. almost all functions here will have a cg_xyz (runtime) equivalent in cg.psy

s_convert_to : func(v : val mut, to : tyid, source : ast? -> val)
{
	i : u64 mut;
	// conversions always produce an rvalue
	ret ::= val mut
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := to;
		.compile_time := zero;
		.runtime := zero;
	};
	// convert v to type to
	// already confirmed its a valid conversion so any invalid codepaths in this code are compiler bugs.
	from ::= v.type;
	if(ty_is_char(from))
	{
		// we're converting from u8 to something else
		// remember this is an integral type but chars are stored differently in static values
		// so what we will do is just pretend we are an integer for now
		v.compile_time.primitive.tag = (ast_literal_tag.integer);
		v.compile_time.primitive.integer = ([v.compile_time.primitive.chars]@_);
	}
	if(ty_is_integral(from))
	{
		if(ty_is_char(to))
		{
			// i2i (char)
			ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.char; .chars := arena_alloc(string_arena, 1); .chars_len := 1;};};
			[ret.compile_time.primitive.chars] = (v.compile_time.primitive.integer@_);
			return ret;
		}
		if(ty_is_integral(to))
		{
			// i2i
			ret.compile_time = (v.compile_time);
			return ret;
		}
		if(ty_is_floating_point(to))
		{
			// i2f
			ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.floating_point; .floating_point := (v.compile_time.primitive.integer@_);};};
			return ret;
		}
		if(ty_is_bool(to))
		{
			// i2f
			ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.boolean; .boolean := (v.compile_time.primitive.integer != 0);};};
			return ret;
		}

		// special checks
		// s64 to enum:
		if(ty_matches_ignore_quals(from, tyid.s64) && ty_is_enum(to))
		{
			// enum is still an integral literal under-the-hood
			ret.compile_time = (v.compile_time);
			return ret;
		}
		// u64 to ptr:
		if(ty_matches_ignore_quals(from, tyid.u64) && ty_is_ptr(to))
		{
			// ptr is still an integral literal under-the-hood (pointer address)
			ret.compile_time = (v.compile_time);
			return ret;
		}
		// u64 to function:
		if(ty_matches_ignore_quals(from, tyid.u64) && ty_is_fn(to))
		{
			// fn is still an integral literal under-the-hood (pointer address)
			ret.compile_time = (v.compile_time);
			return ret;
		}
	}
	if(ty_is_floating_point(from))
	{
		if(ty_is_char(to))
		{
			// f2i (char)
			ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.char; .chars := arena_alloc(string_arena, 1); .chars_len := 1;};};
			[ret.compile_time.primitive.chars] = (v.compile_time.primitive.floating_point@s64@_);
			return ret;
		}
		if(ty_is_integral(to))
		{
			// f2i
			ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.integer; .integer := (v.compile_time.primitive.floating_point@_);};};
			return ret;
		}
		if(ty_is_floating_point(to))
		{
			// f2f
			ret.compile_time = (v.compile_time);
			return ret;
		}
	}
	if(ty_is_bool(from))
	{
		if(ty_is_char(to))
		{
			// b2i (char)
			ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.char; .chars := arena_alloc(string_arena, 1); .chars_len := 1;};};
			if(v.compile_time.primitive.boolean)
			{
				[ret.compile_time.primitive.chars] = 1;
			}
			else
			{
				[ret.compile_time.primitive.chars] = 0;
			}
			return ret;
		}
		if(ty_is_integral(to))
		{
			// b2i
			if(v.compile_time.primitive.boolean)
			{
				ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.integer; .integer := 1;};};
			}
			else
			{
				ret.compile_time = valcompile_time{.primitive := ast_literal{.tag := ast_literal_tag.integer; .integer := 0;};};
			}
			return ret;
		}
		if(ty_is_bool(to))
		{
			// b2b
			ret.compile_time = (v.compile_time);
			return ret;
		}
	}
	if(ty_is_enum(from))
	{
		if(ty_is_enum(to))
		{
			// e2e
			ret.compile_time = (v.compile_time);
			return ret;
		}
		if(ty_matches_ignore_quals(to, tyid.s64))
		{
			// e2i
			ret.compile_time = (v.compile_time);
			return ret;
		}
	}
	if(ty_is_ptr(from))
	{
		if(ty_matches_ignore_quals(to, tyid.u64))
		{
			// p2i
			ret.compile_time = (v.compile_time);
			return ret;
		}
		if(ty_is_ptr(to))
		{
			// p2p
			ret.compile_time = (v.compile_time);
			return ret;
		}
		if(ty_is_fn(to))
		{
			// p2fn
			ret.compile_time = (v.compile_time);
			return ret;
		}
	}
	if(ty_is_fn(from))
	{
		if(ty_matches_ignore_quals(to, tyid.u64))
		{
			// fn2i
			ret.compile_time = (v.compile_time);
			return ret;
		}
		if(ty_is_ptr(to))
		{
			// fn2p
			ret.compile_time = (v.compile_time);
			return ret;
		}
		if(ty_is_fn(to))
		{
			// fn2fn
			ret.compile_time = (v.compile_time);
			return ret;
		}
	}
	if(ty_is_arr(to))
	{
		memcount ::= ty_unwrap(to)->array_len;
		// members pointer needs to be deep copied
		ret.compile_time = (v.compile_time);
		ret.compile_time.members = arena_alloc(global_arena, sizeof val * (ret.compile_time.members_count));
		memcopy(ret.compile_time.members, v.compile_time.members, sizeof val * (ret.compile_time.members_count));
		for(i = 0;  i < memcount;  i = i + 1)
		{
			mem ::= ret.compile_time.members@val mut? # i;
			[mem] = s_convert_to([mem], ty_underlying(to), source);
		}
		return ret;
	}
	// structs dont convert to anything
	// but if we got here its the same type
	if(ty_is_struct(to))
	{
		return ret;
	}
	psyc_panic_begin(source->loc);
	putzstr("control reached end of s_convert_to type ");
	putchar('"');
	putty(to);
	putchar('"');
	putzstr(" for: ");
	putval(v);
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

// note the members array of val.compile_time.members is correctly sized but of an indeterminate value that you *must* overwrite
s_empty_blkinit : func(type : tyid -> val)
{
	// todo: support arrays for this too
	memcount : u64 mut := 0;
	if(ty_is_struct(type))
	{
		memcount = (ty_unwrap(type)->strct.members_count);
	}
	else
	{
		// must be an array then
		memcount = (ty_unwrap(type)->array_len);
	}
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := zero;
			.members_count := memcount;
			.members := arena_alloc(global_arena, sizeof val * memcount);
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

s_blkinit_add : func(v : val mut, memidx : u64, init : val -> val)
{
	[v.compile_time.members@val mut? # memidx] = init;
	return v;
};

s_unop_minus : func(v : val, scope : lexical_scope mut?, source : ast? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := v.type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal
			{
				.tag := v.compile_time.primitive.tag;
				.integer := -(v.compile_time.primitive.integer);
				.floating_point := -(v.compile_time.primitive.floating_point);
			};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

s_unop_bitwise_invert : func(v : val, scope : lexical_scope mut?, source : ast? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := v.type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal
			{
				.tag := v.compile_time.primitive.tag;
				.integer := ~(v.compile_time.primitive.integer);
			};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

s_unop_logical_invert : func(v : val, scope : lexical_scope mut?, source : ast? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := v.type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal
			{
				.tag := v.compile_time.primitive.tag;
				.boolean := !(v.compile_time.primitive.boolean);
			};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

s_biop_assign : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// assume lhs is a varref and rhs has been converted to lhs.
	var ::= scope_find_variable(scope, lhs.compile_time.varref_name, lhs.compile_time.varref_name_len);
	var->compile_time_storage = rhs;
	return lhs;
};

s_biop_add : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) + val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(float_as_val(val_must_get_float(lhs, scope, source) + val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_sub : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) - val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(float_as_val(val_must_get_float(lhs, scope, source) - val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_mul : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) * val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(float_as_val(val_must_get_float(lhs, scope, source) * val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_div : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	// todo: check for compile-time divide by zero?
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) / val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(float_as_val(val_must_get_float(lhs, scope, source) / val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_bitwise_or : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) | val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_bitwise_and : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) & val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_logical_or : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(bool_as_val(val_must_get_boolean(lhs, scope, source) || val_must_get_boolean(lhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_logical_and : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(bool_as_val(val_must_get_boolean(lhs, scope, source) && val_must_get_boolean(lhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_xor : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) ^ val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_bitshift_left : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) << val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_bitshift_right : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) >> val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_modulo : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	return val_convert_to(integer_as_val(val_must_get_integer(lhs, scope, source) % val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_compare_equal : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(bool_as_val(val_must_get_integer(lhs, scope, source) == val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(bool_as_val(val_must_get_float(lhs, scope, source) == val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_compare_not_equal : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(bool_as_val(val_must_get_integer(lhs, scope, source) != val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(bool_as_val(val_must_get_float(lhs, scope, source) != val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_compare_less_equal : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(bool_as_val(val_must_get_integer(lhs, scope, source) <= val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(bool_as_val(val_must_get_float(lhs, scope, source) <= val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_compare_less : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(bool_as_val(val_must_get_integer(lhs, scope, source) < val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(bool_as_val(val_must_get_float(lhs, scope, source) < val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_compare_greater_equal : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(bool_as_val(val_must_get_integer(lhs, scope, source) >= val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(bool_as_val(val_must_get_float(lhs, scope, source) >= val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_biop_compare_greater : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// lhs and rhs are guaranteed to be the same type
	type ::= lhs.type;
	if(ty_is_integral(lhs.type))
	{
		return val_convert_to(bool_as_val(val_must_get_integer(lhs, scope, source) > val_must_get_integer(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
	}
	return val_convert_to(bool_as_val(val_must_get_float(lhs, scope, source) > val_must_get_float(rhs, scope, source)), type, scope, val_resolution.compile_time_only, source);
};

s_decl : func(var : variable mut?, scope : lexical_scope mut? -> val)
{
	// variable declared but in a fully compile-time setting.
	if(var->node->children_count == 2)
	{
		var->compile_time_storage = val_node(ast_get_child(var->node, 1), scope, val_resolution.compile_time_only);
	}
	return zero;
};

s_builtin_assert : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	cond ::= val_must_get_boolean([params # 0], scope, source);
	if(!cond)
	{
		psyc_error_begin(source->loc);
		putzstr("static assert failure: condition was false");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return zero;
};

s_builtin_add_source_file : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	path_strdata : u8 mut? mut;
	path_strlen : u64 mut;
	val_must_get_string([params # 0], scope, source, ref path_strdata, ref path_strlen);
	path_zstr ::= sstr2zstr(path_strdata, path_strlen, string_arena);

	if(!file_exists(path_zstr))
	{
		psyc_error_begin(source->loc);
		putzstr("source file ");
		putchar('"');
		putzstr(path_zstr);
		putchar('"');
		putzstr(" could not be found:");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	program_queue_source_file(path_strdata, path_strlen);
	return zero;
};

s_builtin_add_build_file : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	path_strdata : u8 mut? mut;
	path_strlen : u64 mut;
	val_must_get_string([params # 0], scope, source, ref path_strdata, ref path_strlen);
	path_zstr ::= sstr2zstr(path_strdata, path_strlen, string_arena);

	if(!file_exists(path_zstr))
	{
		psyc_error_begin(source->loc);
		putzstr("build file ");
		putchar('"');
		putzstr(path_zstr);
		putchar('"');
		putzstr(" could not be found:");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	program_queue_build_file(path_strdata, path_strlen, "default");
	return zero;
};

s_builtin_executable : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	name_strdata : u8 mut? mut;
	name_strlen : u64 mut;
	val_must_get_string([params # 0], scope, source, ref name_strdata, ref name_strlen);
	prog.output.name = sstr2zstr(name_strdata, name_strlen, string_arena);
	return zero;
};

s_builtin_optimization : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	prog.optimization = (val_must_get_integer([params # 0], scope, source)@program_optimization);
	return zero;
};

s_builtin_debug_symbols : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	prog.debug_symbols = val_must_get_boolean([params # 0], scope, source);
	return zero;
};

s_path_has_extension : func(path_zstr : u8?, extension_zstr : u8? -> bool)
{
	extlen ::= zstrlen(extension_zstr);
	pathlen ::= zstrlen(path_zstr);
	if(extlen >= pathlen)
	{
		return false;
	}
	if(streql_n(path_zstr # (pathlen - extlen), extension_zstr, extlen))
	{
		return true;
	}
	return false;
};

s_impl_curdir : u8? mut := zero;
s_impl_add_source_file : func(path : u8? -> v0)
{
	// make sure its a .psy file
	if(!s_path_has_extension(path, ".psy"))
	{
		return;
	}
	parented_path_len ::= zstrlen(s_impl_curdir) + 1 + zstrlen(path);
	parented_path : u8 mut? := arena_alloc(string_arena, parented_path_len);
	memcopy(parented_path, s_impl_curdir, zstrlen(s_impl_curdir));
	[parented_path # zstrlen(s_impl_curdir)] = '/';
	memcopy(parented_path # (1 + zstrlen(s_impl_curdir)), path, zstrlen(path));
	program_queue_source_file(parented_path, parented_path_len);
};

s_builtin_add_source_directory : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	dir_strdata : u8 mut? mut;
	dir_strlen : u64 mut;
	val_must_get_string([params # 0], scope, source, ref dir_strdata, ref dir_strlen);
	dir_zstr ::= sstr2zstr(dir_strdata, dir_strlen, string_arena);
	s_impl_curdir = dir_zstr;
	directory_iterate(dir_zstr, s_impl_add_source_file, string_arena);
	return zero;
};

s_builtin_add_link_library : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	lib_strdata : u8 mut? mut;
	lib_strlen : u64 mut;
	val_must_get_string([params # 0], scope, source, ref lib_strdata, ref lib_strlen);
	program_add_link_library(lib_strdata, lib_strlen);
	return zero;
};

s_builtin_embed : func(params : val?, scope : lexical_scope?, source : ast? -> val)
{
	file_strdata : u8 mut? mut;
	file_strlen : u64 mut;
	val_must_get_string([params # 0], scope, source, ref file_strdata, ref file_strlen);
	file_path_zstr ::= sstr2zstr(file_strdata, file_strlen, string_arena);
	if(!file_exists(file_path_zstr))
	{
		psyc_error_begin(source->loc);
		putzstr("embedded file ");
		putchar('"');
		putzstr(file_path_zstr);
		putchar('"');
		putzstr(" could not be found");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	filebuf_len ::= file_size_bytes(file_path_zstr);
	filebuf : u8 mut? := arena_alloc(string_arena, filebuf_len);
	file_read(file_path_zstr, filebuf, filebuf_len);
	embed_srcloc ::= srcloc
	{
		.file := file_path_zstr;
		.line := 1;
		.column := 1;
	};
	embed_node ::= ast
	{
		.tag := ast_tag.stmt;
		.stmt := ast_stmt_tag.expr;
		.expr := ast_expr_tag.blkinit;
		.loc := source->loc;
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	ast_add_child(ref embed_node, ast
	{
		.tag := ast_tag.typename;
		.typename := ast_typename
		{
			.tag := ast_typename_tag.finalised;
			.quals := zero;
			.descriptor := ast_typename_descriptor.base;
			.basename := "embed_data";
			.basename_len := 10;
		};
		.loc := source->loc;
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	}, global_arena);
	desiginit_data ::= ast
	{
		.tag := ast_tag.desiginit;
		.desiginit := ast_desiginit
		{
			.descriptor := ast_desiginit_descriptor.symbol;
			.symbol := "data";
			.symbol_len := 4;
		};
		.loc := source->loc;
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	init_data ::= ast
	{
		.tag := ast_tag.expr;
		.expr := ast_expr_tag.literal;
		.literal := ast_literal
		{
			.tag := ast_literal_tag.string;
			.chars := filebuf;
			.chars_len := filebuf_len;
		};
		.loc := source->loc;
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	ast_add_child(ref desiginit_data, init_data, global_arena);
	ast_add_child(ref embed_node, desiginit_data, global_arena);
	desiginit_len ::= ast
	{
		.tag := ast_tag.desiginit;
		.desiginit := ast_desiginit
		{
			.descriptor := ast_desiginit_descriptor.symbol;
			.symbol := "len";
			.symbol_len := 3;
		};
		.loc := source->loc;
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	init_len ::= ast
	{
		.tag := ast_tag.expr;
		.expr := ast_expr_tag.literal;
		.literal := ast_literal
		{
			.tag := ast_literal_tag.integer;
			.integer := filebuf_len@_;
		};
		.loc := source->loc;
		.children := zero;
		.children_count := zero;
		.children_cap := zero;
	};
	ast_add_child(ref desiginit_len, init_len, global_arena);
	ast_add_child(ref embed_node, desiginit_len, global_arena);
	return val_blkinit(ref embed_node, scope, val_resolution.compile_time_only);
};
