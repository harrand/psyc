s_integral_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.integer;
			.integer := apply_unop_int(op, ref(v->s.primitive.integer), source);
		};
	});
};

s_integral_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.integer;
			.integer := apply_biop_int(op, ref(lhs->s.primitive.integer), ref(rhs->s.primitive.integer), source);
		};
	});
};

s_integral_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.boolean;
			.boolean := apply_biop_int(op, ref(lhs->s.primitive.integer), ref(rhs->s.primitive.integer), source)@bool;
		};
	});
};

s_floating_point_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.floating_point;
			.floating_point := apply_unop_float(op, ref(v->s.primitive.floating_point), source);
		};
	});
};

s_floating_point_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.floating_point;
			.floating_point := apply_biop_float(op, ref(lhs->s.primitive.floating_point), ref(rhs->s.primitive.floating_point), source);
		};
	});
};

s_floating_point_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.boolean;
			.boolean := apply_biop_float(op, ref(lhs->s.primitive.floating_point), ref(rhs->s.primitive.floating_point), source)@s64@bool;
		};
	});
};

s_bool_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.boolean;
			.boolean := apply_unop_bool(op, ref(v->s.primitive.boolean), source);
		};
	});
};

s_bool_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	return val_static(sval
	{
		.tag := sval_tag.primitive;
		.primitive := ast_literal
		{
			.tag := ast_literal_tag.boolean;
			.boolean := apply_biop_bool(op, ref(lhs->s.primitive.boolean), ref(rhs->s.primitive.boolean), source);
		};
	});
};

s_bool_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	// in this case its the same
	return s_bool_arith_biop(op, lhs, rhs, source);
};

// the below apply functions happen directly to the actual arithmetic types instead of values
// just to keep the value code above simpler.

apply_unop_int ::= func(op : ast_unop, operand : s64 mut?, source : ast? -> s64)
{
	if(op == (ast_unop.minus))
	{
		return -deref(operand);
	}
	if(op == (ast_unop.bitwise_invert))
	{
		return ~deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on an integral literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_float ::= func(op : ast_unop, operand : f64 mut?, source : ast? -> f64)
{
	if(op == (ast_unop.minus))
	{
		return -deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a floating-point literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_unop_bool ::= func(op : ast_unop, operand : bool mut?, source : ast? -> bool)
{
	if(op == (ast_unop.logical_invert))
	{
		return !deref(operand);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a boolean literal, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_int ::= func(op : ast_biop, lhs : s64 mut?, rhs : s64 mut?, source : ast? -> s64)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs))@_;
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs))@_;
	}
	if(op == (ast_biop.compare_less))
	{
		return (deref(lhs) < deref(rhs))@_;
	}
	if(op == (ast_biop.compare_less_equal))
	{
		return (deref(lhs) <= deref(rhs))@_;
	}
	if(op == (ast_biop.compare_greater))
	{
		return (deref(lhs) > deref(rhs))@_;
	}
	if(op == (ast_biop.compare_greater_equal))
	{
		return (deref(lhs) >= deref(rhs))@_;
	}
	if(op == (ast_biop.add))
	{
		return deref(lhs) + deref(rhs);
	}
	if(op == (ast_biop.sub))
	{
		return deref(lhs) - deref(rhs);
	}
	if(op == (ast_biop.mul))
	{
		return deref(lhs) * deref(rhs);
	}
	if(op == (ast_biop.div))
	{
		if(deref(rhs) == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("statically detected integer divide-by-zero");
			psyc_diag_end();
			psyc_exit_failure();
		}
		return deref(lhs) / deref(rhs);
	}
	if(op == (ast_biop.bitwise_or))
	{
		return deref(lhs) | deref(rhs);
	}
	if(op == (ast_biop.bitwise_and))
	{
		return deref(lhs) & deref(rhs);
	}
	if(op == (ast_biop.xor))
	{
		return deref(lhs) ^ deref(rhs);
	}
	if(op == (ast_biop.bitshift_left))
	{
		return deref(lhs) << deref(rhs);
	}
	if(op == (ast_biop.bitshift_right))
	{
		return deref(lhs) >> deref(rhs);
	}
	if(op == (ast_biop.modulo))
	{
		return deref(lhs) % deref(rhs);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two integral literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_float ::= func(op : ast_biop, lhs : f64 mut?, rhs : f64 mut?, source : ast? -> f64)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_less))
	{
		return (deref(lhs) < deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_less_equal))
	{
		return (deref(lhs) <= deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_greater))
	{
		return (deref(lhs) > deref(rhs))@s64@_;
	}
	if(op == (ast_biop.compare_greater_equal))
	{
		return (deref(lhs) >= deref(rhs))@s64@_;
	}
	if(op == (ast_biop.add))
	{
		return deref(lhs) + deref(rhs);
	}
	if(op == (ast_biop.sub))
	{
		return deref(lhs) - deref(rhs);
	}
	if(op == (ast_biop.mul))
	{
		return deref(lhs) * deref(rhs);
	}
	if(op == (ast_biop.div))
	{
		// floating point divide-by-zero is permitted statically.
		return deref(lhs) / deref(rhs);
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two floating-point literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

apply_biop_bool ::= func(op : ast_biop, lhs : bool mut?, rhs : bool mut?, source : ast? -> bool)
{
	if(op == (ast_biop.assign))
	{
		deref(lhs) = deref(rhs);
		return deref(lhs);
	}
	if(op == (ast_biop.compare_equal))
	{
		return (deref(lhs) == deref(rhs));
	}
	if(op == (ast_biop.compare_not_equal))
	{
		return (deref(lhs) != deref(rhs));
	}
	psyc_error_begin(source->loc);
	putzstr("attempt to statically perform a binary ");
	putzstr(__enumname(op));
	putzstr(" operation on two boolean literals, which is not valid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

