default_obj_extension ::= ".o";
static if(_win32)
{
	default_exe_extension ::= ".exe";
}
else
{
	default_exe_extension ::= ".elf";
}

find_and_invoke_build_region ::= func(scope : lexical_scope?, region_name : u8?, region_name_len : u64, source : ast? -> v0)
{
	the_region : region mut? mut := zero;

	i : u64 mut;
	for(i = 0, i < (scope->regions_count), i = i + 1)
	{
		cur_region ::= scope->regions # i;
		if(cur_region->name_len == region_name_len)
		{
			if(streql_n(cur_region->name, region_name, region_name_len))
			{
				the_region = cur_region;
			}
		}
	}

	if(the_region == zero)
	{
		// todo: maybe pass in a called_from ast so we can give a more specific error message in the case that the build region was invoked from another?
		psyc_error_begin(source->loc);
		putzstr("build file ");
		putchar('"');
		putbytes(scope->name, scope->name_len);
		putchar('"');
		putzstr(" had no region named ");
		putchar('"');
		putbytes(region_name, region_name_len);
		putchar('"');
		if(source != zero)
		{
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		}
		psyc_diag_end();
		psyc_exit_failure();
	}
	invoke_build_region(the_region->node, scope);
};

invoke_node_children_as_build_instructions ::= func(node : ast?, begin : u64, end : u64, scope : lexical_scope? -> v0)
{
	i : u64 mut;
	for(i = begin, i < end, i = i + 1)
	{
		invoke_build_instruction(ast_get_child(node, i), scope);
	}
};

invoke_build_region ::= func(node : ast?, scope : lexical_scope? -> v0)
{
	invoke_node_children_as_build_instructions(node, 0, node->children_count, scope);
};

invoke_build_instruction ::= func(node : ast?, scope : lexical_scope? -> v0)
{
	if(ast_is_expr(node, ast_expr_tag.call))
	{
		callname_node ::= ast_get_child(node, 0);
		if(!ast_is_expr(callname_node, ast_expr_tag.symbol))
		{
			psyc_error_begin(callname_node->loc);
			putzstr("in a static context, all calls must be to a symbol expression");
			putchar(10);
			ast_print_annotated_source(program_current_source_file().src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		callname_sym ::= callname_node->symbol;
		maybe_builtin ::= builtin_find(callname_sym.data, callname_sym.len);
		if(maybe_builtin != zero)
		{
			val_call(node, program_scope(), val_resolution.compile_time_only);
			//builtin_invoke(deref maybe_builtin, shit...);
			//psyc_panic_begin(node->loc);
			//putzstr("todo: builtin_invoke for build regions");
			//psyc_diag_end();
			//psyc_exit_failure();
		}
		// todo: delete this old builtin1 code
		//maybe_builtin ::= builtin_match_name(callname_sym.data, callname_sym.len);
		//if(maybe_builtin != zero)
		//{
		//	builtin_get(maybe_builtin).on_call_static(node);
		//}
		else
		{
			// the call isnt a builtin
			// how about another build region, Murray?
			// but it better be a symbol expression
			find_and_invoke_build_region(scope, callname_sym.data, callname_sym.len, node);
		}
		return;
	}
	// what if its just a valid sval stmt
	if(ast_is_any_stmt(node) && ast_is_any_expr(node))
	{
		as_val ::= val_node(node, zero, val_resolution.compile_time_only);
		if(val_is_valid(as_val))
		{
			return;
		}
	}

	if(ast_is_stmt(node, ast_stmt_tag.if_block))
	{
		if(!(node->ifblk.is_static))
		{
			psyc_error_begin(node->loc);
			putzstr("all if statements within a build region must be static (i.e use static_if)");
			putchar(10);
			ast_print_annotated_source(program_current_source_file().src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		cond_node ::= ast_get_child(node, 0);
		else_node : ast? mut := zero;
		if(node->children_count > 1)
		{
			last_child ::= ast_get_child(node, node->children_count - 1);
			if(ast_is_stmt(last_child, ast_stmt_tag.else_block))
			{
				else_node = last_child;
			}
		}
		cond_val ::= val_node(cond_node, program_scope(), val_resolution.compile_time_only);
		cond ::= val_must_get_boolean(cond_val, program_scope(), cond_node);
		if(cond)
		{
			end : u64 mut := node->children_count;
			if(else_node != zero)
			{
				end = (end - 1);
			}
			
			// iterate over 1-count children and invoke those as build instructions too
			invoke_node_children_as_build_instructions(node, 1, end, scope);
			return;
		}
		else
		{
			// if theres an else node do that
			if(else_node != zero)
			{
				invoke_node_children_as_build_instructions(else_node, 0, else_node->children_count, scope);
			}
			return;
		}
	}

	if(ast_is_stmt(node, ast_stmt_tag.decl))
	{
		// basically pretend it is a global variable.
		psyc_panic_begin(node->loc);
		putzstr("todo: treat a decl in a build region as if it were a global variable");
		putchar(10);
		ast_print_annotated_source(program_current_source_file().src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	psyc_panic_begin(node->loc);	
	putzstr("not sure how to invoke the following code within a build region:");
	putchar(10);
	ast_print_annotated_source(program_current_source_file().src, node, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
};
