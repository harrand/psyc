ast ::= struct
{
	// top-level bits
	tag : ast_tag;
	utok : ast_unparsed_token;
	stmt : ast_stmt_tag;
	expr : ast_expr_tag;

	// expr payloads
	literal : ast_literal;
	symbol : ast_symbol;
	unop : ast_unop;
	biop : ast_biop;
	call : ast_call;

	// other payloads
	decl : ast_decl;
	typename : ast_typename;
	desiginit : ast_desiginit;
	ifblk : ast_if;
	structure : ast_structure;
	function : ast_function;
	enumeration : ast_enumeration;
	assembly : ast_assembly;
	region : ast_region;

	// meta info
	begin_cursor : u64;
	end_cursor : u64;
	loc : srcloc;
	children : v0?;
	children_count : u64;
	children_cap : u64;
};

ast_tag ::= enum
{
	.unparsed_token := 1;
	.expr := 2;
	.stmt := 3;
	.decl := 4;
	.typename := 5;
	.desiginit := 6;
	.structure := 7;
	.function := 8;
	.enumeration := 9;
	.assembly := 10;

	.callwip := 11;
	.call_expect_comma_or_cparen := 12;
	.castwip := 13;
	.blkinitwip := 14;
	.desiginitwip := 15;
	.fieldwip := 16;
	.ptrfieldwip := 17;
	.ifwip := 18;
	.elsewip := 19;
	.whilewip := 20;
	.forwip1 := 21;
	.forwip2 := 22;
	.forwip := 23;
	.regionwip := 24;
};

ast_unparsed_token ::= struct
{
	tok : token_data;
};

ast_stmt_tag ::= enum
{
	.expr := 1;
	.decl := 2;
	.structure := 3;
	.function := 4;
	.enumeration := 5;
	.assembly := 6;
	.region := 7;
	// first child is condition, rest is the block
	.if_block := 8;
	// all children is block
	.else_block := 9;
	// first child is condition, rest is the block
	.while_block := 10;
	// first child is init, second child cond, third child iter, rest is the block
	.for_block := 11;
	.ret := 12;
	.desiginit := 13;
};

ast_expr_tag ::= enum
{
	.symbol := 1;
	.literal := 2;
	.zero_value := 3;
	.unop := 4;
	.biop := 5;
	.call := 6;
	.blkinit := 7;
	.dereference := 8;
	.cast := 9;
	.field := 10;
	.ptrfield := 11;
};

ast_decl_tag ::= enum
{
	.await_type := 1;
	.noinit := 2;
	.await_init_expr := 3;
	.finalised := 4;
};

ast_decl ::= struct
{
	tag : ast_decl_tag;
	name : u8?;
	name_len : u64;
	// note: first child of a decl is always the typename
	// rest represent stmts constituting the impl block
};

ast_typename_descriptor ::= enum
{
	.base := 1;
	.array := 2;
	.pointer := 3;
	.function := 4;
	.inferred_from := 5; // aka typeof
	.deduced := 6;
};

ast_typename_tag ::= enum
{
	.wip := 1;
	.array_await_length := 2;
	.function_await_param_or_arrow := 3;
	.function_await_return_type := 4;
	.finalised := 5;
};

ast_typename ::= struct
{
	tag : ast_typename_tag;

	quals : tyqual;
	descriptor : ast_typename_descriptor;
	basename : u8?;
	basename_len : u64;
	// pointer means child 0 is the underlying type
	// array means child 0 is the underlying type and child 1 is the array length
	// function means child 0-(n-1) are the param typenames and child n is the return typename
	// deduced means we dont have the type info to hand and it should be deduced later on
	// inferred_from means child 0 is some expr whose type is our type.
};

ast_literal_tag ::= enum
{
	.integer := 1;
	.floating_point := 2;
	.char := 3;
	.string := 4;
	.boolean := 5;
};

ast_literal ::= struct
{
	tag : ast_literal_tag;
	integer : s64;
	floating_point : f64;
	// both for char and string literal (escaped char literals have more than 1 char in source for example)
	chars : u8 mut?;
	chars_len : u64;
	boolean : bool;
};

ast_symbol ::= struct
{
	data : u8?;
	len : u64;
};

ast_unop ::= enum
{
	.minus := 1;
	.bitwise_invert := 2;
	.logical_invert := 3;
	.reference := 4;
};
ast_unop_tokens : lex_token mut[5] mut := zero;

ast_biop ::= enum
{
	.assign := 1;
	.compare_equal := 2;
	.compare_not_equal := 3;
	.compare_less := 4;
	.compare_less_equal := 5;
	.compare_greater := 6;
	.compare_greater_equal := 7;
	.add := 8;
	.sub := 9;
	.mul := 10;
	.div := 11;
	.bitwise_or := 12;
	.bitwise_and := 13;
	.logical_or := 14;
	.logical_and := 15;
	.xor := 16;
	.bitshift_left := 17;
	.bitshift_right := 18;
	.modulo := 19;
	.at := 20;
};
ast_biop_tokens : lex_token mut[24] mut := zero;

ast_all_op_tokens : lex_token mut[29] mut := zero;
ast_all_op_tokens_cursor : u64 mut := 0;

ast_call ::= struct
{
	call_name : u8?;
	call_name_len : u64;
};

ast_desiginit ::= struct
{
	name : u8?;
	name_len : u64;
};

ast_if ::= struct
{
	is_static : bool;
};

ast_structure_tag ::= enum
{
	.wip := 1;
	.finalised := 2;
};

ast_structure ::= struct
{
	tag : ast_structure_tag;
	name : u8?;
	name_len : u64;
};

ast_function_tag ::= enum
{
	.impl := 1;
	.finalised := 2;
};

ast_function ::= struct
{
	tag : ast_function_tag;
	name : u8?;
	name_len : u64;
	is_extern : bool;
	// first child is the typename of the function itself (not the return type)
	// second child is a node who stores all the stmts of the implementation as its children
};

ast_enumeration_tag ::= enum
{
	.wip := 1;
	.finalised := 2;
};

ast_enumeration ::= struct
{
	tag : ast_enumeration_tag;
	name : u8?;
	name_len : u64;
};

ast_assembly_tag ::= enum
{
	.wip := 1;
	.coding := 2;
	.finalised := 3;
};

ast_assembly ::= struct
{
	tag : ast_assembly_tag;
	name : u8?;
	name_len : u64;
	constraints : u8?;
	constraints_len : u64;
};

ast_region ::= struct
{
	name : u8?;
	name_len : u64;
};

ast_reserve_children ::= func(node : ast mut?, count : u64, ar : arena mut? -> v0)
{
	if(node->children_cap < count)
	{
		old ::= node->children;
		oldcap ::= node->children_cap;
		node->children_cap = count;
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));	
		if(old != zero)
		{
			memcopy(node->children, old, oldcap * __sizeof(ast));
			arena_free(ar, old, oldcap * __sizeof(ast));
		}
	}
};

ast_add_child ::= func(node : ast mut?, child : ast, ar : arena mut? -> v0)
{
	if(node->children == zero)
	{
		node->children_cap = 2;
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));
	}
	while(node->children_cap <= (node->children_count))
	{
		old ::= node->children;
		oldcap ::= node->children_cap;

		node->children_cap = (node->children_cap * 2);
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));	
		memcopy(node->children, old, oldcap * __sizeof(ast));
		arena_free(ar, old, oldcap * __sizeof(ast));
	}
	children ::= node->children@ast mut?;
	deref(children # (node->children_count)) = child;
	node->children_count = (node->children_count + 1);
	// note: i have decided that if you add a node as a child, the parent node almost certainly should include it when quoting source
	// so im potentially extending its end cursor
	// if thats wrong then comment this shit out.
	if(node->end_cursor < (child.end_cursor))
	{
		node->end_cursor = (child.end_cursor);
	}
};

ast_get_child ::= func(node : ast mut?, idx : u64 -> ast mut?)
{
	return node->children@ast mut? # idx;
};

// countof + 1 because enum entries start at 1 not 0
tag_offset_utok ::= func(-> u64 weak)
{
	return __countof(ast_tag) + 1;
};

tag_offset_expr ::= func(-> u64 weak)
{
	return tag_offset_utok() + __countof(lex_token) + 1;
};

tag_offset_stmt ::= func(-> u64 weak)
{
	return tag_offset_expr() + __countof(ast_expr_tag) + 1;
};

tag_offset_typename ::= func(-> u64 weak)
{
	return tag_offset_stmt() + __countof(ast_stmt_tag) + 1;
};

tag_offset_function ::= func(-> u64 weak)
{
	return tag_offset_typename() + __countof(ast_typename_tag) + 1;
};

tag_offset_structure ::= func(-> u64 weak)
{
	return tag_offset_function() + __countof(ast_function_tag) + 1;
};

tag_offset_enumeration ::= func(-> u64 weak)
{
	return tag_offset_structure() + __countof(ast_structure_tag) + 1;
};

tag_offset_assembly ::= func(-> u64 weak)
{
	return tag_offset_enumeration() + __countof(ast_enumeration_tag) + 1;
};

tag_offset_decl ::= func(-> u64 weak)
{
	return tag_offset_assembly() + __countof(ast_assembly_tag) + 1;
};


// whats the largest possible value we can get from ast_uid?
ast_maximum_uid ::= func(-> u64)
{
	return (tag_offset_decl() + __countof(ast_decl_tag) + 1);
};

ast_uid ::= func(node : ast? -> u64)
{
	// the idea is this generates a unique id for every possible specific ast type
	// some are more strict than others (e.g all asts that are functions will have the same uid, but asts that are decls will have a different uid depending on the decl tag)
	// the default is that all ast_tag N have the same uid. the exceptions to that are below
	// the reason for this is the grammar might have a reduction for a literal expression but not necessarily a symbol expression. but the grammar might treat all functions/structs the exact same.
	// the previous thing was to try and hash everything together but it was slow (both for all the hash calculations and dealing with collisions)
	// this way is much more specific and attempts to guarantee uniqueness in cases where it matters without a noticeable perf cost.
	tag ::= node->tag;
	if(tag == zero){return zero;}
	if(tag == (ast_tag.unparsed_token))
	{
		return tag_offset_utok() + (node->utok.tok.tok@s64);
	}
	if(tag == (ast_tag.expr))
	{
		return tag_offset_expr() + (node->expr@s64);
	}
	if(tag == (ast_tag.stmt))
	{
		return tag_offset_stmt() + (node->stmt@s64);
	}
	if(tag == (ast_tag.typename))
	{
		return tag_offset_typename() + (node->typename.tag@s64);
	}
	if(tag == (ast_tag.function))
	{
		return tag_offset_function() + (node->function.tag@s64);
	}
	if(tag == (ast_tag.structure))
	{
		return tag_offset_structure() + (node->structure.tag@s64);
	}
	if(tag == (ast_tag.enumeration))
	{
		return tag_offset_enumeration() + (node->enumeration.tag@s64);
	}
	if(tag == (ast_tag.assembly))
	{
		return tag_offset_assembly() + (node->assembly.tag@s64);
	}
	if(tag == (ast_tag.decl))
	{
		return tag_offset_decl() + (node->decl.tag@s64);
	}
	// anything not listed above just uses its ast_tag as its uid
	return node->tag@s64@_;
};

ast_is_any_stmt ::= func(node : ast? -> bool)
{
	return node->tag == (ast_tag.stmt);
};

ast_is_stmt ::= func(node : ast?, tag : ast_stmt_tag -> bool)
{
	return ast_is_any_stmt(node) && (node->stmt == tag);
};

ast_is_any_expr ::= func(node : ast? -> bool)
{
	return (node->tag == (ast_tag.expr)) || ((node->tag == (ast_tag.stmt)) && (node->stmt == (ast_stmt_tag.expr)));
};

ast_is_expr ::= func(node : ast?, tag : ast_expr_tag -> bool)
{
	return ast_is_any_expr(node) && (node->expr == tag);
};

ast_is_weakness_idiom ::= func(node : ast? -> bool)
{
	// weakness idiom is the typename '_'
	if(node->tag != (ast_tag.typename))
	{
		return false;
	}
	typename ::= node->typename;
	if(typename.descriptor != (ast_typename_descriptor.base))
	{
		return false;
	}
	weakness_idiom_str ::= "_";
	weakness_idiom_strlen ::= zstrlen(weakness_idiom_str);
	if(weakness_idiom_strlen == (typename.basename_len))
	{
		if(streql_n(weakness_idiom_str, typename.basename, weakness_idiom_strlen))
		{
			return true;
		}
	}
	return false;
};

// give me the begin src (DONT PASS ZERO) and a node and i will tell you where the source lives
ast_quote_source ::= func(nodes : ast?, nodes_count : u64, src : u8? mut?, len : u64 mut? -> v0)
{
	first ::= nodes # 0;
	last ::= nodes # (nodes_count - 1);
	if(last->end_cursor < (first->begin_cursor))
	{
		psyc_panic_begin(first->loc);
		putzstr("node span's begin_cursor (");
		putuint(first->begin_cursor);
		putzstr(") > end_cursor(");
		putuint(last->end_cursor);
		putzstr(") - super illegal");
		psyc_diag_end();
		psyc_exit_failure();
	}
	read_ptr ::= deref src;
	deref(src) = (read_ptr # (first->begin_cursor));
	deref(len) = (last->end_cursor - (first->begin_cursor));
};

// return the number of chars we have moved backwards for the newline
ast_quote_source_from_line_begin ::= func(nodes : ast?, nodes_count : u64, src : u8? mut?, len : u64 mut?, tab_extra : u64 mut? -> u64)
{
	distance : u64 mut := 0;
	first ::= deref src;
	ast_quote_source(nodes, nodes_count, src, len);
	deref(tab_extra) = 0;
	while(deref(deref(src)) != 10 && (first@u64 < (deref src@u64)))
	{
		if(deref(deref(src)) == 9)
		{
			// tab size
			deref(tab_extra) = (deref tab_extra + 1);
		}
		distance = distance + 1;
		deref(src) = (deref(src) # -1);
		deref(len) = (deref len + 1);
	}
	// dont want to include the newline
	hit_first ::= (first@u64 == (deref src@u64));
	if(!hit_first)
	{
		deref(src) = (deref(src) # 1);
		deref(len) = (deref len - 1);
		return distance - 1;
	}
	return distance;
};

underline_colour ::= enum
{
	.red := 1;
	.yellow := 2;
	.blue := 3;
};

// give me a node (or multiple) that are erroneous and i will print out that annotated source code
// you should call me after psyc_error_begin(node->loc) and then putzstr'ing a relevant message + newline
ast_print_annotated_source ::= func(src : u8?, node : ast?, node_count : u64, u : underline_colour -> v0)
{
	loc ::= node->loc;

	snip_begin : u8? mut := src;
	snip_len : u64 mut;
	tab_extra : u64 mut;
	err_begin ::= ast_quote_source_from_line_begin(node, node_count, ref snip_begin, ref snip_len, ref tab_extra);
	till_newline : u64 mut := 0;
	// this assumes src is null terminated.
	while((deref(snip_begin # (snip_len + till_newline)) != 10) && (deref(snip_begin # (snip_len + till_newline)) != 0))
	{
		till_newline = (till_newline + 1);
	}

	line_prefix ::= " | ";
	// quote source
	psyc_colour_reset();
	line_number_digit_count ::= lenuint(loc.line) + 1;
	putuint(loc.line);
	putchar(' ');
	putzstr(line_prefix);
	// if we print the whole thing we will include newlines
	// so lets do it manually and if we hit a newline thats okay we just print the prefix out again
	i : u64 mut := 0;
	new_line_counter : u64 mut := 1;
	for(i = 0, i < (snip_len + till_newline), i = i + 1)
	{
		char ::= deref(snip_begin # i);
		if(char != 13)
		{
			if(char == 9) // tab
			{
				putzstr("    ");
			}
			else
			{
				putchar(char);
			}
		}
		if(char == 10)
		{
			putuint(loc.line + new_line_counter);
			if(lenuint(loc.line + new_line_counter)  <= (line_number_digit_count))
			{
				putchar(' ');
			}
			new_line_counter = (new_line_counter + 1);
			putzstr(line_prefix);
		}
	}
	putchar(10);

	// make equal space for the pointer line
	for(i = 0, i < line_number_digit_count, i = i + 1)
	{
		putchar(' ');
	}
	putzstr(line_prefix);
	for(i = 0, i < tab_extra, i = i + 1)
	{
		putzstr("    ");
	}
	for(i = 1, i < err_begin, i = i + 1)
	{
		putchar(' ');
	}
	if(u == (underline_colour.red))
	{
		psyc_colour_red();
	}
	if(u == (underline_colour.yellow))
	{
		psyc_colour_yellow();
	}
	if(u == (underline_colour.blue))
	{
		psyc_colour_blue();
	}
	putchar('^');

	for(i = 1, i < (snip_len - err_begin), i = i + 1)
	{
		putchar('~');
	}
};


ast_rotate_left ::= func(node_array : ast mut?, node_array_count : u64 mut?, pivot : u64, shift_amount : u64 -> v0)
{
	// say our nodes are:
	// 0, 1, 2, 3, 4, 5, 6
	// the pivot represents some index in this list
	// we overwrite 'shift_amount' elements # and rightwards of the pivot by the same number of proceeding elements
	// so: ast_rotate_left(nodes, nodes_len, 3, 2) =>
	// 0, 1, 2, 5, 6	
	copydst ::= node_array # pivot;
	copysrc ::= copydst # shift_amount;

	count ::= deref(node_array_count) - (pivot + shift_amount);
	memcopy(copydst, copysrc, __sizeof(ast) * count);
	deref(node_array_count) = (deref(node_array_count) - shift_amount);
	// note we dont zero out any stuff that is beyond the cursor. we could but we shouldnt need to.
};

// assumes node_array capacity >= (node_array_count + shift_amount)
ast_rotate_right ::= func(node_array : ast mut?, node_array_count : u64 mut?, pivot : u64, shift_amount : u64 -> v0)
{
	// say our nodes are:
	// 0, 1, 2, 3, 4
	// the pivot represents some index in this list
	// the shift_amount will shift all elements # and rightwards of the pivot by that amount, adding extra space which will be zero'd out.
	// so: impl_shift_nodes_right(nodes, 3, 2) =>
	// 0, 1, 2, 0, 0, 3, 4	
	copysrc ::= node_array # pivot;
	copydst ::= copysrc # shift_amount;
	// the copy length is not __sizeof(ast) * shift_amount as that wouldnt shift all nodes
	// it will be node_array_count - (shift_amount + pivot)
	memcopy_backwards(copydst, copysrc, __sizeof(ast) * ((1 + deref(node_array_count)) - (pivot + shift_amount)));
	// zero the hole
	memfill(copysrc, 0, __sizeof(ast) * shift_amount);
	deref(node_array_count) = (deref(node_array_count) + shift_amount);
};

ast_util_print_indent ::= func(indent : u64 -> v0)
{
	i : u64 mut;
	for(i = 0, i < indent, i = i + 1)
	{
		putchar(9);
	}
};

ast_print_expr_part ::= func(n : ast -> v0)
{
	if(n.expr == (ast_expr_tag.symbol))
	{
		putzstr(".");
		putchar('"');
		putbytes(n.symbol.data, n.symbol.len);
		putchar('"');
	}
	if(n.expr == (ast_expr_tag.literal))
	{
		putzstr(".");
		putzstr(__enumname(n.literal.tag));
		if(n.literal.tag == (ast_literal_tag.integer))
		{
			putzstr(".");
			putsint(n.literal.integer);
		}
		if(n.literal.tag == (ast_literal_tag.floating_point))
		{
			putzstr(".");
			putfloat(n.literal.floating_point);
		}
		if(n.literal.tag == (ast_literal_tag.char))
		{
			putzstr(".");
			putbytes(n.literal.chars, n.literal.chars_len);
		}
		if(n.literal.tag == (ast_literal_tag.string))
		{
			putzstr(".");
			putbytes(n.literal.chars, n.literal.chars_len);
		}
		if(n.literal.tag == (ast_literal_tag.boolean))
		{
			putzstr(".");
			if(n.literal.boolean)
			{
				putzstr("true");
			}
			else
			{
				putzstr("false");
			}
		}
	}
	if(n.expr == (ast_expr_tag.zero_value))
	{
	}
	if(n.expr == (ast_expr_tag.unop))
	{
		putzstr(".");
		putzstr(__enumname(n.unop));
	}
	if(n.expr == (ast_expr_tag.biop))
	{
		putzstr(".");
		putzstr(__enumname(n.biop));
	}
	if(n.expr == (ast_expr_tag.call))
	{
		putzstr(".");
		putbytes(n.call.call_name, n.call.call_name_len);
	}
};

ast_verbose_print ::= func(n : ast, indent : u64 -> v0)
{
	ast_util_print_indent(indent);
	if(n.tag == zero)
	{
		putzstr(n.loc.file);
	}
	else
	{
		putzstr(__enumname(n.tag));
	}
	if(n.tag == (ast_tag.unparsed_token))
	{
		putzstr(".");
		putzstr(__enumname(n.utok.tok.tok));
		if(n.utok.tok.tok == (lex_token.symbol))
		{
			lexeme ::= n.utok.tok.lexeme;
			putzstr(".");
			putchar('"');
			putbytes(parse_state.src # (lexeme.off), lexeme.len);
			putchar('"');
		}
	}
	if(n.tag == (ast_tag.expr))
	{
		putzstr(".");
		putzstr(__enumname(n.expr));
		ast_print_expr_part(n);
	}
	if(n.tag == (ast_tag.stmt))
	{
		putzstr(".");
		putzstr(__enumname(n.stmt));
		if(n.stmt == (ast_stmt_tag.expr))
		{
			putzstr(".");
			putzstr(__enumname(n.expr));
			ast_print_expr_part(n);
		}
		if(n.stmt == (ast_stmt_tag.desiginit))
		{
			putzstr(".");
			putbytes(n.desiginit.name, n.desiginit.name_len);
		}
	}
	if(n.tag == (ast_tag.typename))
	{
		putzstr(".");
		putzstr(__enumname(n.typename.descriptor));
		if(n.typename.descriptor == (ast_typename_descriptor.base))
		{
			putzstr(".");
			putbytes(n.typename.basename, n.typename.basename_len);
		}
	}
	if(n.tag != zero)
	{
	putzstr("[");
	putuint(n.loc.line);
	putzstr(":");
	putuint(n.loc.column);
	putzstr("]");
	}
	putchar(10);
	i : u64 mut;
	for(i = 0, i < (n.children_count), i = i + 1)
	{
		ast_verbose_print(deref ast_get_child(ref n, i), indent + 1);
	}
};

foreach_expr ::= func(callback : func(tag : ast_expr_tag -> v0) -> v0)
{
	i : u64 mut;
	for(i = 0, i < __countof(ast_expr_tag), i = i + 1)
	{
		callback((i + 1)@ast_expr_tag);
	}
};

foreach_stmt ::= func(callback : func(tag : ast_stmt_tag -> v0) -> v0)
{
	i : u64 mut;
	for(i = 0, i < __countof(ast_stmt_tag), i = i + 1)
	{
		callback((i + 1)@ast_stmt_tag);
	}
};

isdigit ::= func(ch : u8 -> bool)
{
	return (ch >= '0') && (ch <= '9');
};

interpret_numeric_literal ::= func(src : u8?, lexeme : lex_slice -> ast_literal)
{
	src_begin : u8? mut := src # (lexeme.off);
	begin_cpy ::= src_begin;
	i : u64 mut := 0;

	sign : s64 mut := 1;
	if(deref(src_begin) == '-')
	{
		sign = -1;
		src_begin = src_begin # 1;
		i = i + 1;
	}

	base : s64 mut := 10;
	ch : u8 mut;
	if(deref(src_begin) == '0')
	{
		src_begin = src_begin # 1;
		ch = deref(src_begin);
		if(ch == 'x')
		{
			base = 16;
			src_begin = src_begin # 1;
			i = i + 2;
		}
		if(ch == 'b')
		{
			base = 2;
			src_begin = src_begin # 1;
			i = i + 2;
		}
	}

	ival : s64 mut := 0;
	fval : f64 mut := 0;

	digit_val : s64 mut := 0;
	frac_div : f64 mut := 1.0;

	is_integral : bool mut := true;
	while(i < (lexeme.len))
	{
		ch = deref(begin_cpy # i);
		if(ch == '.')
		{
			is_integral = false;
		}
		if(isdigit(ch))
		{
			digit_val = (ch - '0')@_;
		}
		if(ch >= 'a')
		{
			if(ch <= 'f')
			{
				digit_val = (10 + (ch - 'a'));
			}
		}
		if(ch >= 'A')
		{
			if(ch <= 'F')
			{
				digit_val = (10 + (ch - 'A'));
			}
		}

		if(digit_val >= base)
		{
			putchar(ch);
			putuint(digit_val);
			psyc_panic(__curloc(), "waaah it all went wrong");
		}

		if(is_integral)
		{
			ival = ((ival * base) + digit_val);
		}
		if(!is_integral)
		{
			if(isdigit(ch))
			{
				frac_div = (frac_div / (base@f64));
				fval = (fval + ((digit_val@f64) * frac_div));
			}
		}

		i = i + 1;
	}

	ret : ast_literal mut;
	if(is_integral)
	{
		ival = ival * sign;
		ret.tag = (ast_literal_tag.integer);
		ret.integer = ival;
	}
	if(!is_integral)
	{
		fval = fval + (ival@f64) * (sign@f64);
		ret.tag = (ast_literal_tag.floating_point);
		ret.floating_point = fval;
	}

	return ret;
};
