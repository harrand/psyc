ast ::= struct
{
	// top-level bits
	tag : ast_tag;
	utok : ast_unparsed_token;
	stmt : ast_stmt_tag;
	expr : ast_expr_tag;

	// expr payloads
	literal : ast_literal;
	symbol : ast_symbol;
	unop : ast_unop;
	biop : ast_biop;
	callfunc : ast_callfunc;
	blkinit : ast_blkinit;

	// other payloads
	decl : ast_decl;
	typename : ast_typename;
	init : ast_init;
	structure : ast_structure;
	function : ast_function;
	enumeration : ast_enumeration;
	assembly : ast_assembly;

	// meta info
	begin_cursor : u64;
	end_cursor : u64;
	loc : srcloc;
	children : v0?;
	children_count : u64;
	children_cap : u64;
};

ast_tag ::= enum
{
	.unparsed_token := 1;
	.expr := 2;
	.stmt := 3;
	.decl := 4;
	.typename := 5;
	.init := 6;
	.structure := 7;
	.function := 8;
	.enumeration := 9;
	.assembly := 10;
};

ast_unparsed_token ::= struct
{
	tok : token_data;
};

ast_stmt_tag ::= enum
{
	.expr := 1;
	.decl := 2;
	.if_block := 3;
	.while_block := 4;
	.for_block := 5;
};

ast_expr_tag ::= enum
{
	.symbol := 1;
	.literal := 2;
	.unop := 3;
	.biop := 4;
	.callfunc := 5;
	.blkinit := 6;
	.zero_value := 7;
	.dereference := 8;
};

ast_decl_tag ::= enum
{
	// todo: intermediate parser state we can generate unique hashes from
};

ast_decl ::= struct
{
	tag : ast_decl_tag;
	name : u8?;
	name_len : u64;
	typename : ast_typename;
};

ast_typename_tag ::= enum
{
	.base := 1;
	.array := 2;
	.pointer := 3;
};

ast_typename ::= struct
{
	quals : tyqual;
	tag : ast_typename_tag;
	basename : u8?;
	basename_len : u64;
	array_len : u64;
};

ast_literal_tag ::= enum
{
	.integer := 1;
	.floating_point := 2;
	.char := 3;
	.string := 4;
	.boolean := 5;
};

ast_literal ::= struct
{
	tag : ast_literal_tag;
	integer : s64;
	floating_point : f64;
	char : u8;
	string : u8?;
	string_len : u64;
	boolean : bool;
};

ast_symbol ::= struct
{
	data : u8?;
	len : u64;
};

ast_unop ::= enum
{
	.minus := 1;
	.bitwise_invert := 2;
	.logical_invert := 3;
	.reference := 4;
};

ast_biop ::= enum
{
	.assign := 1;
	.compare_equal := 2;
	.compare_not_equal := 3;
	.compare_less := 4;
	.compare_less_equal := 5;
	.compare_greater := 6;
	.compare_greater_equal := 7;
	.add := 8;
	.sub := 9;
	.mul := 10;
	.div := 11;
	.bitwise_or := 12;
	.bitwise_and := 13;
	.logical_or := 14;
	.logical_and := 15;
	.xor := 16;
	.bitshift_left := 17;
	.bitshift_right := 18;
	.modulo := 19;
	.at := 20;
	.field := 21;
	.ptr_field := 22;
	.cast := 23;
};

ast_callfunc_tag ::= enum
{
	// todo: intermediate parser state we can generate unique hashes from
};

ast_callfunc ::= struct
{
	tag : ast_callfunc_tag;
	call_name : u8?;
	call_name_len : u64;
};

ast_blkinit ::= struct
{
	typename : ast_typename;
};

ast_init ::= struct
{
	name : u8?;
	name_len : u64;
};

ast_structure ::= struct
{
	name : u8?;
	name_len : u64;
};

ast_function ::= struct
{
	name : u8?;
	name_len : u64;
	return_type : ast_typename;
};

ast_enumeration ::= struct
{
	name : u8?;
	name_len : u64;
};

ast_assembly ::= struct
{
	name : u8?;
	name_len : u64;
	return_type : ast_typename;
};

ast_add_child ::= func(node : ast mut?, child : ast, ar : arena mut? -> v0)
{
	if(node->children == zero)
	{
		node->children_cap = 8;
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));
	}
	while(node->children_cap <= (node->children_count))
	{
		old ::= node->children;
		oldcap ::= node->children_cap;

		node->children_cap = (node->children_cap * 2);
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));	
		memcopy(node->children, old, oldcap * __sizeof(ast));
		arena_free(ar, old, oldcap * __sizeof(ast));
	}
	children ::= node->children@ast mut?;
	deref(children # (node->children_count)) = child;
	node->children_count = (node->children_count + 1);
};

ast_get_child ::= func(node : ast mut?, idx : u64 -> ast mut?)
{
	return node->children@ast mut? # idx;
};

// countof + 1 because enum entries start at 1 not 0
tag_offset_utok ::= func(-> u64 weak)
{
	return __countof(ast_tag) + 1;
};

tag_offset_expr ::= func(-> u64 weak)
{
	return tag_offset_utok() + __countof(lex_token) + 1;
};

tag_offset_stmt ::= func(-> u64 weak)
{
	return tag_offset_expr() + __countof(ast_expr_tag) + 1;
};

tag_offset_decl ::= func(-> u64 weak)
{
	return tag_offset_stmt() + __countof(ast_stmt_tag) + 1;
};

ast_uid ::= func(node : ast? -> u64)
{
	// the idea is this generates a unique id for every possible specific ast type
	// some are more strict than others (e.g all asts that are functions will have the same uid, but asts that are decls will have a different uid depending on the decl tag)
	// the default is that all ast_tag N have the same uid. the exceptions to that are below
	// the reason for this is the grammar might have a reduction for a literal expression but not necessarily a symbol expression. but the grammar might treat all functions/structs the exact same.
	// the previous thing was to try and hash everything together but it was slow (both for all the hash calculations and dealing with collisions)
	// this way is much more specific and attempts to guarantee uniqueness in cases where it matters without a noticeable perf cost.
	tag ::= node->tag;
	if(tag == (ast_tag.unparsed_token))
	{
		return tag_offset_utok() + (node->utok.tok.tok@s64);
	}
	if(tag == (ast_tag.expr))
	{
		return tag_offset_expr() + (node->expr@s64);
	}
	if(tag == (ast_tag.stmt))
	{
		return tag_offset_stmt() + (node->stmt@s64);
	}
	if(tag == (ast_tag.decl))
	{
		return tag_offset_decl() + (node->decl.tag@s64);
	}
	// anything not listed above just uses its ast_tag as its uid
	return node->tag@s64@_;
};

// give me the begin src (DONT PASS ZERO) and a node and i will tell you where the source lives
ast_quote_source ::= func(node : ast?, src : u8? mut?, len : u64 mut? -> v0)
{
	if(node->end_cursor < (node->begin_cursor))
	{
		psyc_panic_begin(node->loc);
		putzstr("node's begin_cursor (");
		putuint(node->begin_cursor);
		putzstr(") > end_cursor(");
		putuint(node->end_cursor);
		putzstr(") - super illegal");
		psyc_diag_end();
		psyc_exit_failure();
	}
	read_ptr ::= deref src;
	deref(src) = (read_ptr # (node->begin_cursor));
	deref(len) = (node->end_cursor - (node->begin_cursor));
};
