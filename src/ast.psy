ast_stmt_tag ::= enum
{
	.expr := 1;
	.decl := 2;
};

ast_expr_tag ::= enum
{
	.symbol := 1;
	.literal := 2;
	.unop := 3;
	.biop := 4;
	.callfunc := 5;
	.structinit := 6;
};

ast_typename_tag ::= enum
{
	.base := 1;
	.array := 2;
	.pointer := 3;
};

ast_typename ::= struct
{
	quals : tyqual;
	tag : ast_typename_tag;
	basename : u8?;
	basename_len : u64;
	array_len : u64;
};

ast_tag ::= enum
{
	.stmt := 1;
	.expr := 2;
	.typename := 3;
	.zero_value := 4;
};

ast_literal_tag ::= enum
{
	.integer := 1;
	.floating_point := 2;
	.char := 3;
	.string := 4;
	.boolean := 5;
};

ast_literal ::= struct
{
	tag : ast_literal_tag;
	integer : s64;
	floating_point : f64;
	char : u8;
	string : u8?;
	string_len : u64;
	boolean : bool;
};

ast_symbol ::= struct
{
	data : u8?;
	len : u64;
};

ast_unop ::= enum
{
	.minus := 1;
	.bitwise_invert := 2;
	.logical_invert := 3;
	.reference := 4;
	.dereference := 5;
};

ast_biop ::= enum
{
};

ast_callfunc ::= struct
{
	call_name : u8?;
	call_name_len : u64;
};

ast ::= struct
{
	tag : ast_tag;
	stmt : ast_stmt_tag;
	expr : ast_expr_tag;

	typename : ast_typename;

	literal : ast_literal;
	symbol : ast_symbol;
	unop : ast_unop;
	biop : ast_biop;
	callfunc : ast_callfunc;

	begin_cursor : u64;
	end_cursor : u64;
	loc : srcloc;
	children : v0?;
	children_count : u64;
	children_cap : u64;
};

ast_add_child ::= func(node : ast mut?, child : ast, ar : arena mut? -> v0)
{
	if(node->children == zero)
	{
		node->children_cap = 8;
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));
	}
	while(node->children_cap <= (node->children_count))
	{
		old ::= node->children;
		oldcap ::= node->children_cap;

		node->children_cap = (node->children_cap * 2);
		node->children = arena_alloc(ar, __sizeof(ast) * (node->children_cap));	
		memcopy(node->children, old, oldcap * __sizeof(ast));
		arena_free(ar, old, oldcap * __sizeof(ast));
	}
	children ::= node->children@ast mut?;
	deref(children # (node->childcount)) = child;
	node->childcount = (node->childcount + 1);
};
