semar : arena mut& mut;

semal_setup ::= func(a : arena mut&) -> v0
{
	semar = a;
};

decl_ty ::= func(node : ast&, s : scope mut&) -> ty
{
	return zero;
};

semal_resolve_typename_complex ::= func(tyname : u8&, tyname_len : u64, semal_struct_ptr : func(def : structdef mut&, s : scope mut&, prog : program mut&) -> v0, s : scope mut&, prog : program mut&, current_struct : structdef&, current_memname : u8&, current_memname_len : u64) -> ty
{
	// try to find the ty normally:
	retty : ty mut := scope_parse_typename(s, tyname, tyname_len);
	if(!ty_isbad(retty))
	{
		return retty;
	}
	// couldnt figure it out. its either an erroneous tyname *or* a struct that hasn't been semal'd yet.
	base_end ::= typarse_basename_end(tyname, tyname_len);
	maybe_struct ::= scope_find_struct(s, tyname, base_end);
	if(maybe_struct == null)
	{
		// ok cant find it
		return zero;
	}
	if(maybe_struct == current_struct)
	{
		node ::= maybe_struct->node;
		psyc_error_begin(node->loc);
		puts("recursive struct ");
		putchar('"');
		putss(maybe_struct->name, maybe_struct->name_len);
		putchar('"');
		puts(" detected - data member ");
		putchar('"');
		putss(current_memname, current_memname_len);
		putchar('"');
		puts(" is of type ");
		putchar('"');
		putss(tyname, tyname_len);
		putchar('"');
		puts(" which is based on the enclosing struct");
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(!ty_isbad(maybe_struct->type))
	{
		// this shouldnt really happen coz scope_parse_typename should've worked
		psyc_panic(zero, "waaaaaah");
	}
	if(maybe_struct->in_progress)
	{
		psyc_panic(zero, "ruh roh struct already in progress");
	}
	semal_struct_ptr(maybe_struct@_, s, prog);
	retty = (maybe_struct->type);
	typarse_extras(tyname at base_end, tyname_len - base_end, ref retty);
	return retty;
};

semal_resolve_typename ::= func(tyname : u8&, tyname_len : u64, semal_struct_ptr : func(def : structdef mut&, s : scope mut&, prog : program mut&) -> v0, s : scope mut&, prog : program mut&) -> ty
{
	return semal_resolve_typename_complex(tyname, tyname_len, semal_struct_ptr, s, prog, null, null, 0);
};

// semal struct is a bit complicated...
// one of its data members could be another struct - one that we haven't semal'd yet either
semal_struct ::= func(def : structdef mut&, s : scope mut&, prog : program mut&) -> v0
{
	node ::= def->node;

	if(!ty_isbad(def->type))
	{
		// we already did this earlier, probably due to it being a dependency of an earlier struct.
		return;
	}
	(def->in_progress) = true;

	retstruct : structty mut := zero;
	(retstruct.member_count) = (def->member_count);
	(retstruct.name) = (def->name);
	(retstruct.name_len) = (def->name_len);

	(retstruct.member_types) = arena_push(semar, __sizeof(ty) * (def->member_count));
	(retstruct.member_names) = arena_push(semar, __sizeof(u8&) * (def->member_count));
	(retstruct.member_name_lens) = arena_push(semar, __sizeof(u64) * (def->member_count));
	memtypes ::= (retstruct.member_types)@ty mut&;

	i : u64 mut;

	for(i = 0, i < (def->member_count), i = i + 1)
	{
		memnode ::= ast_get_child(node@_, i);
		memdecl ::= (memnode->decl);
		memty ::= semal_resolve_typename_complex(memdecl.typename, memdecl.typename_len, semal_struct, s, prog, def, memdecl.name, memdecl.name_len);
		
		if(ty_isbad(memty))
		{
			psyc_error_begin(node->loc);
			puts("struct data member ");
			putchar('"');
			putss(def->name, def->name_len);
			puts("::");
			putss(memdecl.name, memdecl.name_len);
			putchar('"');
			puts(" with typename ");
			putchar('"');
			putss(memdecl.typename, memdecl.typename_len);
			putchar('"');
			puts(" yielded badtype");
			psyc_diag_end();
			psyc_exit_failure();
		}
		putss(def->name, def->name_len);
		puts("::");
		putss(memdecl.name, memdecl.name_len);
		puts(" is of type ");
		putty(memty);
		putchar(10);
		
		deref(memtypes at i) = memty;
		deref((retstruct.member_names) at i) = (memdecl.name);
		deref((retstruct.member_name_lens) at i) = (memdecl.name_len);
	}

	retty ::= ref(def->type);
	(retty->tag) = (tytag.strct);
	(retty->strct) = retstruct;

	scope_declare_struct_type(s, retstruct, node->loc);
};

semal_func ::= func(f : function mut&, s : scope mut&, prog : program mut&) -> v0
{
	puts("semal'ing func ");
	putss(f->name, f->name_len);
	putchar(10);
};

semal_macro ::= func(m : macrodef mut&, s : scope mut&, prog : program mut&) -> v0
{
	puts("semal'ing macro ");
	putss(m->name, m->name_len);
	putchar(10);
};

semal ::= func(prog : program mut&) -> v0
{
	psyc_timed(psyc_stage.semal);
	glob ::= ref(prog->global);
	structs ::= ref(glob->structs);
	funcs ::= ref(glob->funcs);
	macros ::= ref(glob->macros);

	i : u64 mut;
	for(i = 0, i < (structs->size), i = i + 1)
	{
		semal_struct((structs->data) at i, glob, prog);
	}

	for(i = 0, i < (funcs->size), i = i + 1)
	{
		semal_func((funcs->data) at i, glob, prog);
	}

	for(i = 0, i < (macros->size), i = i + 1)
	{
		semal_macro((macros->data) at i, glob, prog);
	}
};

 == build ==
 {
 	add_source_file("program.psy");
 }
