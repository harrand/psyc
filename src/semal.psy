builtin ::= enum
{
	.message := 0;
	.warning := 1;
	.dumptype := 2;
	.add_source_file := 3;
	.add_link_library := 4;
};

builtin_fn ::= struct
{
	fn : func(call : ast_callfunc_expr, ctx : context mut, prog : program mut&) -> sval;
	type : fnty;
};

builtins : builtin_fn mut#5;

semal_function ::= struct
{
	fn : func(ctx : context mut, prog : program mut&) -> sval;
};

semar : arena mut& mut;
semal_jump_table : semal_function mut#4;
stmt_jump_table : semal_function mut#9;

literal_types : ty mut#5;

node_get_idx_of_first_return ::= func(node : ast mut&) -> u64
{
	i : u64 mut;
	for(i = 0, i < (node->childcount), i = i + 1)
	{
		if(ast_is_expr(ast_get_child(node, i), ast_expr_type.ret))
		{
			return i;
		}
	}
	return i - 1;
};


// if the node is deferred, return the actual node as if it wasnt deferred. if the node isnt deferred at all, return null
deferred_node_get ::= func(node : ast&) -> ast&
{
	if((node->type) != (ast_type.stmt))
	{
		return null;
	}
	stmt ::= node->stmt;
	if(stmt != (ast_stmt.expr_stmt))
	{
		return null;
	}
	expr ::= node->expr;
	if((expr.type) == (ast_expr_type.unop))
	{
		unop ::= expr.unop;
		if((unop.type) == (ast_unop_type.op_defer))
		{
			// yes we are a deferred node.
			// return our child
			return ast_get_child(node@_, 0);
		}
	}
	return null;
};

defer_children ::= func(node : ast mut&) -> v0
{
	if((node->childcount) == 0)
	{
		return;
	}
	// re-arrange children to deal with deferred nodes.
	i : u64 mut := 0;
	curchild : ast& mut;
	cur_deferred : ast& mut;
	cache : ast mut;
	last_id ::= node_get_idx_of_first_return(node);
	last ::= ast_get_child(node@_, last_id);
	while(i < (node->childcount))
	{
		curchild = ast_get_child(node, i);
		cur_deferred = deferred_node_get(curchild);
		if(cur_deferred != null)
		{
			cache = (deref cur_deferred);
			// move all subsequent children down to replace us
			__memcpy(curchild, curchild at 1, __sizeof(ast) * (last_id));
			(deref last) = cache;
		}
		if(cur_deferred == null)
		{
			i = i + 1;
		}
	}
};

semal_node ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;

	pre_transform_idx ::= (node->type)@s64;
	subtraction ::= (ast_type.stmt)@s64;

	idx ::= pre_transform_idx - subtraction;
	jump ::= deref(semal_jump_table at idx);
	jump.fn(ctx, prog);
};

semal_children ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;
	defer_children(node@_);
	childrenptr ::= (node->children)@ast&;
	count ::= node->childcount;
	i : u64 mut;
	for(i = 0, i < count, i = i + 1)
	{
		semal_node(context
		{
			.node := childrenptr at i;
			.local := ctx.local;
		}, prog);
	}
};

semal_children_recursive ::= func(ctx : context mut, prog : program mut&) -> v0
{
	node ::= ctx.node;
	childrenptr ::= (node->children)@ast&;
	count ::= node->childcount;
	i : u64 mut;
	for(i = 0, i < count, i = i + 1)
	{
		semal_node(context
		{
			.node := childrenptr at i;
			.local := ctx.local;
		}, prog);
		semal_children_recursive(context
		{
			.node := childrenptr at i;
			.local := ctx.local;
		}, prog);
	}
};

semal_stmt ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	pre_transform_idx ::= (node->stmt)@s64;
	subtraction ::= (ast_stmt.expr_stmt)@s64;

	idx ::= pre_transform_idx - subtraction;
	jump ::= deref(stmt_jump_table at idx);
	return jump.fn(ctx, prog);
};

semal_structdef ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	def ::= node->structdef;

	childcount ::= node->childcount;
	// todo: check if structname is already defined.
	retstruct : structty mut := zero;
	(retstruct.member_count) = childcount;
	(retstruct.name) = (def.structname);
	(retstruct.name_len) = (def.structname_len);

	(retstruct.member_types) = arena_push(semar, __sizeof(ty) * childcount);
	(retstruct.member_names) = arena_push(semar, __sizeof(u8&) * childcount);
	(retstruct.member_name_lens) = arena_push(semar, __sizeof(u64) * childcount);

	i : u64 mut;

	cur_member_node : ast& mut;
	cur_decl : ast_decl mut;
	cur_member_type : ty mut;
	for(i = 0, i < childcount, i = i + 1)
	{
		cur_member_node = ast_get_child(node@_, i);
		cur_decl = (cur_member_node->decl);
		cur_member_type = scope_parse_typename(ctx.local, cur_decl.typename, cur_decl.typename_len);
		if(ty_isbad(cur_member_type))
		{
			psyc_error_begin(cur_member_node->loc);
			if(cstreql_n(cur_decl.typename, def.structname, cur_decl.name_len))
			{
				putss(def.structname, def.structname_len);
				puts("::");
				putss(cur_decl.name, cur_decl.name_len);
				puts(" was of type ");
				putss(def.structname, def.structname_len);
				puts(" - struct's data member cannot be itself");
				psyc_diag_end();
				psyc_exit_failure();
			}
			putss(def.structname, def.structname_len);
			puts("::");
			putss(cur_decl.name, cur_decl.name_len);
			puts(" yielded badtype");
			psyc_diag_end();
			psyc_exit_failure();
		}
		memty_ptr ::= (retstruct.member_types)@ty mut&;
		deref(memty_ptr at i) = cur_member_type;
		deref((retstruct.member_names) at i) = (cur_decl.name);
		deref((retstruct.member_name_lens) at i) = (cur_decl.name_len);
	}

	// note: local scope is going to be (at the very most) file scope
	// this means that other files will not currently be able to see this definition
	// this can be fixed by simply using program_declare_struct, but i don't feel comfortable just doing that willy-nilly
	already ::= scope_find_struct(ctx.local, def.structname, def.structname_len);
	if(already != null)
	{
		psyc_error_begin(node->loc);
		puts("a struct named ");
		putchar('"');
		putss(def.structname, def.structname_len);
		putchar('"');
		puts(" was already defined ");
		print_srcloc(already->defined_at);
		psyc_diag_end();
		psyc_exit_failure();
	}
	scope_declare_struct(ctx.local, retstruct, node->loc);
	return zero;
};

semal_fn ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	fn ::= node->fn;

	ret_ty : ty mut := scope_parse_typename(ctx.local, fn.ret_typename, fn.ret_typename_len);
	// so the param count is *not* just equal to the childcount if the function is not extern.
	// the statements within are also child nodes.
	// however, all ast_fn children will start off as decls (all the params) and then the contents of the implementation will follow
	i : u64 mut;
	childcount ::= node->childcount;
	beyond_param_idx : u64 mut := 0;
	param_count : u64 mut := 0;
	for(i = 0, i < childcount, i = i + 1)
	{
		cur_param_node ::= ast_get_child(node@_, i);
		if((cur_param_node->type) == (ast_type.decl))
		{
			param_count = param_count + 1;
			beyond_param_idx = beyond_param_idx + 1;
		}
		if((cur_param_node->type) != (ast_type.decl))
		{
			// early out
			i = childcount;
		}
	}
	type : ty mut := ty_getfn(ret_ty, param_count, zero);
	for(i = 0, i < param_count, i = i + 1)
	{
		cur_param_node ::= ast_get_child(node@_, i);
		cur_param_decl ::= cur_param_node->decl;

		declty : ty mut := scope_parse_typename(ctx.local, cur_param_decl.typename, cur_param_decl.typename_len);
		ty_fn_set_param(ref type, i, declty);
	}
	if(param_count > 8)
	{
		psyc_panic(node->loc, "function had too many arguments. more than 8 params is NYI");
	}

	// note: local scope is going to be (at the very most) file scope
	// this means that other files will not currently be able to see this definition
	// this can be fixed by simply using program_declare_function, but i don't feel comfortable just doing that willy-nilly
	scope_declare_function(ctx.local, semar,
		function{
			.node := ctx.node;
			.name := fn.fn_name;
			.name_len := fn.fn_name_len;
			.type := type;
		});
	ret ::= just_type(type);

	if(fn.is_extern)
	{
		if(beyond_param_idx != childcount)
		{
			psyc_panic(node->loc, "extern fn expected all children to be decls representing params, but that seems to not be the case.");
		}
		return ret;
	}
	// go through the implementation
	impl_child_node : ast mut& mut;
	fn_scope ::= program_new_scope(prog, semar, ctx.local, scope_type.fn, node->loc, fn.fn_name, fn.fn_name_len);
	defer_children(node@_);
	for(i = beyond_param_idx, i < childcount, i = i + 1)
	{
		impl_child_node = ast_get_child(node@_, i);
		semal_node(context
		{
			.node := impl_child_node;
			.local := fn_scope;
		}, prog);
	}
	return ret;
};

semal_mac ::= func(ctx : context mut, prog : program mut&) -> sval
{
	node ::= ctx.node;
	mac ::= node->mac;
	puts("macro detected: ");
	putss(mac.mac_name, mac.mac_name_len);
	putchar(10);

	yield_id : u64 mut := -1;

	// so the param count is *not* just equal to the childcount if the function is not extern.
	// the statements within are also child nodes.
	// however, all ast_fn children will start off as decls (all the params) and then the contents of the implementation will follow
	i : u64 mut;
	childcount ::= node->childcount;
	beyond_param_idx : u64 mut := 0;
	param_count : u64 mut := 0;
	for(i = 0, i < childcount, i = i + 1)
	{
		cur_param_node ::= ast_get_child(node@_, i);
		if((cur_param_node->type) == (ast_type.decl))
		{
			param_count = param_count + 1;
			beyond_param_idx = beyond_param_idx + 1;
		}
		if((cur_param_node->type) != (ast_type.decl))
		{
			// early out
			i = childcount;
		}
	}

	curstmt : ast_stmt mut;
	for(i = beyond_param_idx, i < childcount, i = i + 1)
	{
		curchild ::= ast_get_child(node@_, i);
		// todo: find yield_id and set it.
		if((curchild->type) == (ast_type.stmt))
		{
			curstmt = (curchild->stmt);
			if(curstmt == (ast_stmt.expr_stmt))
			{
				curexpr ::= curchild->expr;
				if((curexpr.type) == (ast_expr_type.yld))
				{
					if(yield_id != -1)
					{
						previous_yield ::= ast_get_child(node@_, yield_id);
						psyc_error_begin(curchild->loc);
						puts("multiple 'yield' statements detected within the same macro, previously defined ");
						print_srcloc(previous_yield->loc);
						psyc_diag_end();
						psyc_exit_failure();
					}
					yield_id = i;
				}
			}
		}
	}

	scope_declare_macro(ctx.local, semar, macrodef
	{
		.node := node;
		.name := mac.mac_name;
		.name_len := mac.mac_name_len;
		.yield_type := scope_parse_typename(ctx.local, mac.yield_typename, mac.yield_typename_len);
		.first_id := beyond_param_idx;
		.yield_id := yield_id;
	});
	return zero;
};

semal_noop ::= func(ctx : context mut, prog : program mut&) -> sval
{
	return zero;
};

semal_setup ::= func(a : arena mut&) -> v0
{
	psyc_timed(psyc_stage.setup);
	semar = a;

	deref(semal_jump_table at 0) = semal_function{.fn := semal_stmt;};
	deref(semal_jump_table at 1) = semal_function{.fn := semal_noop;};
	deref(semal_jump_table at 2) = semal_function{.fn := semal_noop;};
	deref(semal_jump_table at 3) = semal_function{.fn := semal_noop;};

	deref(stmt_jump_table at 0) = semal_function{.fn := semal_noop;};
	deref(stmt_jump_table at 1) = semal_function{.fn := semal_noop;};
	deref(stmt_jump_table at 2) = semal_function{.fn := semal_noop;};
	deref(stmt_jump_table at 3) = semal_function{.fn := semal_structdef;};
	deref(stmt_jump_table at 4) = semal_function{.fn := semal_fn;};
	deref(stmt_jump_table at 5) = semal_function{.fn := semal_mac;};
	deref(stmt_jump_table at 6) = semal_function{.fn := semal_noop;};
	deref(stmt_jump_table at 7) = semal_function{.fn := semal_noop;};
	deref(stmt_jump_table at 8) = semal_function{.fn := semal_noop;};
};

semal_file ::= func(prog : program mut&, source : ast&) -> v0
{
	psyc_timed(psyc_stage.semal);
	global ::= prog->global;

	// file scope is a child of the program scope
	file_scope ::= program_new_scope(prog, semar, ref global, scope_type.file, source->loc, null, zero);

	semal_children(context
	{
		.node := source;
		.local := file_scope;
	}, prog);
};

== build ==
{
	add_source_file("program.psy");
	add_source_file("diag.psy");

	add_source_file("sval.psy");
}
