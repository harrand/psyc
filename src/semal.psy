semal ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.semantic);
	semal_all_structs();
	semal_all_functions();
	psyc_timed_end();
};

semal_all_structs ::= func(-> v0)
{
	// go through every single struct type
	// populate the types.
	box ::= ref(prog.types);
	i : u64 mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id ::= i@tyid;
		if(ty_is_struct(id))
		{
			semal_struct(id);
		}
	}
};

semal_struct ::= func(type : tyid -> v0)
{
	s ::= ty_unwrap(type);
	node ::= s->strct.node;
	i : u64 mut;
	for(i = 0, i < (node->children_count), i = i + 1)
	{
		child ::= ast_get_child(node, i);
		decl ::= child->decl;
		deref(s->strct.member_names # i) = (decl.name);
		deref(s->strct.member_name_lens # i) = (decl.name_len);
		// typename is first child of the decl
		typename_node ::= ast_get_child(child, 0);
		cur_ty ::= ty_typename_node(typename_node);
		if(cur_ty == zero)
		{
			// dodgy member type.
			psyc_error_begin(child->loc);
			putzstr("type of data member ");
			putty(type);
			putzstr("::");
			putbytes(decl.name, decl.name_len);
			putzstr(" was not valid");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(ty_matches_ignore_quals(cur_ty, type))
		{
			// struct is a member of itself.
			psyc_error_begin(child->loc);
			putzstr("recursive struct - data member ");
			putty(type);
			putzstr("::");
			putbytes(decl.name, decl.name_len);
			putzstr(" is itself a ");
			putchar('"');
			putty(cur_ty);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		deref(s->strct.members # i) = cur_ty;
	}
};

semal_all_functions ::= func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0, i < (progscope->functions_count), i = i + 1)
	{
		semal_function(progscope->functions # i);
	}
};

semal_function ::= func(fn : function mut? -> v0)
{
	// function typename is first child of node
	function_typename_node ::= ast_get_child(fn->node, 0);
	fn->type = ty_typename_node(function_typename_node);

	// also go through the scope and semal all the typenames
	i : u64 mut;
	funcscope ::= fn->scope@lexical_scope mut?;
	for(i = 0, i < (funcscope->variables_count), i = i + 1)
	{
		semal_variable(funcscope->variables # i, funcscope);
	}
};

semal_variable ::= func(var : variable mut?, scope : lexical_scope mut? -> v0)
{
	decl ::= var->node->decl;
	// set the typename of a variable
	var_typename_node ::= ast_get_child(var->node, 0);
	typename ::= var_typename_node->typename;
	if(var->node->children_count > 1)
	{
		var->init = val_node(ast_get_child(var->node, 1), scope, true);
	}
	// handle the special typename bits
	if(typename.descriptor == (ast_typename_descriptor.deduced))
	{
		if(!val_is_valid(var->init))
		{
			psyc_error_begin(var->node->loc);
			putzstr("variable ");
			putchar('"');
			putbytes(decl.name, decl.name_len);
			putchar('"');
			putzstr(" is of deduced type, but it did not have a valid initialiser");
		}
		var->type = (var->init.type);
	}
	else
	{
		if(typename.descriptor == (ast_typename_descriptor.inferred_from))
		{
			inferred_expr_node ::= ast_get_child(var_typename_node, 0);
			var->type = ty_set_qual(val_node(inferred_expr_node, scope, true).type, typename.quals);
		}
		else
		{
			// ok this typename relies on no program state so just call the ty_tyname thing on it
			var->type = ty_typename_node(var_typename_node);
		}
	}
	if(val_is_valid(var->init))
	{
		ty_ensure_convertible_to(var->init.type, var->type, var->node);
	}
	if(val_is_dynamic(var->init))
	{
		// dynamically computed with some garbage value most likely
		// reset it so codegen can do it properly
		var->init = zero;
	}
	putzstr("variable ");
	putbytes(decl.name, decl.name_len);
	putzstr(" is of type: ");
	putty(var->type);
	putchar(10);
};
