semar : arena mut& mut;

semal_setup ::= func(a : arena mut&) -> v0
{
	semar = a;
};

semal_is_build_region ::= func(n : ast&) -> bool
{
	if((n->type) != (ast_type.stmt))
	{
		return false;
	}
	stmt ::= n->stmt;
	if((stmt.type) != (ast_stmt_type.region_stmt))
	{
		return false;
	}
	region ::= stmt.region;
	build_region_name ::= "build";
	len ::= cstrlen(build_region_name);
	return cstreql_n(region.name, build_region_name, len);
};

semal_find_build_region ::= func(source : ast&) -> ast&
{
	idx ::= ast_child_find_if(source, semal_is_build_region);
	if(idx == (-1@u64))
	{
		return null;
	}
	return ast_get_child(source@_, idx);
};

semal_node ::= func(ctx : context mut&, prog : program mut&) -> v0
{
	node ::= ctx->node;
	puts("semaling node ");
	print_srcloc(node->loc);
	putchar(10);
};

semal_children ::= func(ctx : context mut&, prog : program mut&) -> v0
{
	node ::= ctx->node;
	childrenptr ::= (node->children)@ast&;
	count ::= node->childcount;
	i : u64 mut;
	for(i = 0, i < count, i = i + 1)
	{
		child ::= childrenptr at i;
		child_ctx ::= context
		{
			.node := child;
			.local := ctx->local;
		};
		semal_node(ref child_ctx, prog);
	}
};

semal_build_region ::= func(ctx : context mut&, prog : program mut&) -> v0
{
	(ctx->local) = program_new_scope(prog, semar, ctx->local);

	node ::= ctx->node;
	(prog->in_metaregion) = true;
	defer (prog->in_metaregion) = false;

	semal_children(ctx, prog);
};

semal_file ::= func(prog : program mut&, source : ast&) -> v0
{
	build_region ::= semal_find_build_region(source);
	if(build_region == null)
	{
		psyc_warning_begin(source->loc);
		puts("file had no build region");
		psyc_diag_end();
		return;
	}
	global ::= prog->global;
	ctx : context mut := context
	{
		.node := source;
		.local := zero;
	};
	semal_build_region(ref ctx, prog);
	//semal_children(prog, source);
};

== build ==
{
	add_source_file("program.psy");
	add_source_file("diag.psy");

	add_source_file("sval.psy");
	add_source_file("builtin.psy");
}
