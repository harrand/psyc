semar : arena mut& mut;

semal_setup ::= func(a : arena mut&) -> v0
{
	semar = a;
};

decl_ty ::= func(node : ast&, s : scope mut&) -> ty
{
	return zero;
};
// semal struct is a bit complicated...
// one of its data members could be another struct - one that we haven't semal'd yet either
semal_struct ::= func(def : structdef mut&, s : scope mut&, prog : program mut&) -> v0
{
	node ::= def->node;

	if(!ty_isbad(def->type))
	{
		// we already did this earlier, probably due to it being a dependency of an earlier struct.
		return;
	}
	(def->in_progress) = true;

	retstruct : structty mut := zero;
	(retstruct.member_count) = (def->member_count);
	(retstruct.name) = (def->name);
	(retstruct.name_len) = (def->name_len);

	(retstruct.member_types) = arena_push(semar, __sizeof(ty) * (def->member_count));
	(retstruct.member_names) = arena_push(semar, __sizeof(u8&) * (def->member_count));
	(retstruct.member_name_lens) = arena_push(semar, __sizeof(u64) * (def->member_count));
	memtypes ::= (retstruct.member_types)@ty mut&;

	i : u64 mut;

	for(i = 0, i < (def->member_count), i = i + 1)
	{
		memnode ::= ast_get_child(node@_, i);
		memdecl ::= (memnode->decl);
		maybe_struct_member ::= scope_find_struct(s, memdecl.typename, memdecl.typename_len);
		memty ::= zero@ty mut;
		
		if(maybe_struct_member != null)
		{
			// if the current data members typename is a struct
			// we have to be really careful
			// a.) it could mean a recursive struct
			if(maybe_struct_member == def)
			{
				psyc_error_begin(node->loc);
				puts("recursive struct detected - data member ");
				putss(def->name, def->name_len);
				puts("::");
				putss(memdecl.name, memdecl.name_len);
				puts(" is itself of type ");
				putchar('"');
				putss(memdecl.typename, memdecl.typename_len);
				putchar('"');
				psyc_diag_end();
				psyc_exit_failure();
			}
			// b.) it could be another struct that we haven't semal'd yet
			if(ty_isbad(maybe_struct_member->type))
			{
				// note: this has the potential to recurse forever if we have a circular dependency.
				// so we check that it isn't already in progress
				if(maybe_struct_member->in_progress)
				{
					psyc_error_begin(node->loc);
					puts("struct circular dependency detected - data member ");
					putchar('"');
					putss(def->name, def->name_len);
					puts("::");
					putss(memdecl.name, memdecl.name_len);
					putchar('"');
					puts(" is of type ");
					putchar('"');
					putss(maybe_struct_member->name, maybe_struct_member->name_len);
					putchar('"');
					puts(" which itself appears to rely on the definition of ");
					putchar('"');
					putss(def->name, def->name_len);
					putchar('"');
					psyc_diag_end();
					psyc_exit_failure();
				}
				semal_struct(maybe_struct_member@_, s, prog);
			}
			memty = (maybe_struct_member->type);
		}
		if(maybe_struct_member == null)
		{
			memty = scope_parse_typename(s, memdecl.typename, memdecl.typename_len);
		}
		if(ty_isbad(memty))
		{
			psyc_error_begin(node->loc);
			puts("struct data member ");
			putchar('"');
			putss(def->name, def->name_len);
			puts("::");
			putss(memdecl.name, memdecl.name_len);
			putchar('"');
			puts(" with typename ");
			putchar('"');
			putss(memdecl.typename, memdecl.typename_len);
			putchar('"');
			puts(" yielded badtype");
			psyc_diag_end();
			psyc_exit_failure();
		}
		putss(def->name, def->name_len);
		puts("::");
		putss(memdecl.name, memdecl.name_len);
		puts(" is of type ");
		putty(memty);
		putchar(10);
		
		deref(memtypes at i) = memty;
		deref((retstruct.member_names) at i) = (memdecl.name);
		deref((retstruct.member_name_lens) at i) = (memdecl.name_len);
	}

	retty ::= ref(def->type);
	(retty->tag) = (tytag.strct);
	(retty->strct) = retstruct;
};

semal_func ::= func(f : function mut&, s : scope mut&, prog : program mut&) -> v0
{
	puts("semal'ing func ");
	putss(f->name, f->name_len);
	putchar(10);
};

semal_macro ::= func(m : macrodef mut&, s : scope mut&, prog : program mut&) -> v0
{
	puts("semal'ing macro ");
	putss(m->name, m->name_len);
	putchar(10);
};

semal ::= func(prog : program mut&) -> v0
{
	psyc_timed(psyc_stage.semal);
	glob ::= ref(prog->global);
	structs ::= ref(glob->structs);
	funcs ::= ref(glob->funcs);
	macros ::= ref(glob->macros);

	i : u64 mut;
	for(i = 0, i < (structs->size), i = i + 1)
	{
		semal_struct((structs->data) at i, glob, prog);
	}

	for(i = 0, i < (funcs->size), i = i + 1)
	{
		semal_func((funcs->data) at i, glob, prog);
	}

	for(i = 0, i < (macros->size), i = i + 1)
	{
		semal_macro((macros->data) at i, glob, prog);
	}
};

 == build ==
 {
 	add_source_file("program.psy");
 }
