semal ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.semantic);
	semal_all_structs();
	semal_all_assemblys();
	semal_all_global_variables();
	semal_all_functions();
	psyc_timed_end();
};

semal_all_structs ::= func(-> v0)
{
	// go through every single struct type
	// populate the types.
	box ::= ref(prog.types);
	i : u64 mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id ::= i@tyid;
		if(ty_is_struct(id))
		{
			semal_struct(id);
		}
	}
};

semal_struct ::= func(type : tyid -> v0)
{
	s ::= ty_unwrap(type);
	node ::= s->strct.node;
	i : u64 mut;
	for(i = 0, i < (node->children_count), i = i + 1)
	{
		child ::= ast_get_child(node, i);
		decl ::= child->decl;
		deref(s->strct.member_names # i) = (decl.name);
		deref(s->strct.member_name_lens # i) = (decl.name_len);
		// typename is first child of the decl
		typename_node ::= ast_get_child(child, 0);
		cur_ty ::= ty_typename_node(typename_node);
		if(cur_ty == zero)
		{
			// dodgy member type.
			psyc_error_begin(child->loc);
			putzstr("type of data member ");
			putty(type);
			putzstr("::");
			putbytes(decl.name, decl.name_len);
			putzstr(" was not valid");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(ty_matches_ignore_quals(cur_ty, type))
		{
			// struct is a member of itself.
			psyc_error_begin(child->loc);
			putzstr("recursive struct - data member ");
			putty(type);
			putzstr("::");
			putbytes(decl.name, decl.name_len);
			putzstr(" is itself a ");
			putchar('"');
			putty(cur_ty);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		deref(s->strct.members # i) = cur_ty;
	}
};

semal_all_assemblys ::= func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0, i < (progscope->assemblys_count), i = i + 1)
	{
		semal_assembly(progscope->assemblys # i);
	}
};

semal_all_global_variables ::= func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0, i < (progscope->variables_count), i = i + 1)
	{
		semal_variable(progscope->variables # i, progscope);
	}
};

assembly_constraint_count_inputs ::= func(str : u8?, len : u64 -> u64)
{
	count : u64 mut := 0;
	cursor : u64 mut := 0;
	start : bool mut := true;
	while(cursor < len)
	{
		char ::= deref(str # cursor);
		if(!start)
		{
			if(char == ',')
			{
				start = true;
			}
		}
		else
		{
			// if its a { or a digit, its an input
			start = false;
			if((char == '{') || (char == '*') || isdigit(char))
			{
				count = count + 1;
			}
		}
		cursor = cursor + 1;
	}
	return count;
};

semal_assembly ::= func(as : assembly mut? -> v0)
{
	i : u64 mut;
	input_count ::= assembly_constraint_count_inputs(as->constraints, as->constraints_len);
	params : tyid mut? := arena_alloc(global_arena, input_count * __sizeof(tyid));
	for(i = 0, i < input_count, i = i + 1)
	{
		deref(params # i) = ty_set_qual(tyid.s64, tyqual.qual_weak);
	}
	as->type = ty_fn(ty_set_qual(tyid.s64, tyqual.qual_weak), params, input_count, zero);
};

semal_all_functions ::= func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0, i < (progscope->functions_count), i = i + 1)
	{
		semal_function(progscope->functions # i);
	}
};

semal_function ::= func(fn : function mut? -> v0)
{
	// function typename is first child of node
	function_typename_node ::= ast_get_child(fn->node, 0);
	fn->type = ty_typename_node(function_typename_node);

	// also go through the scope and semal all the typenames
	i : u64 mut;
	funcscope ::= fn->scope@lexical_scope mut?;
	for(i = 0, i < (funcscope->variables_count), i = i + 1)
	{
		semal_variable(funcscope->variables # i, funcscope);
	}
};

semal_variable ::= func(var : variable mut?, scope : lexical_scope mut? -> v0)
{
	decl ::= var->node->decl;
	// set the typename of a variable
	var_typename_node ::= ast_get_child(var->node, 0);
	typename ::= var_typename_node->typename;
	// handle the special typename bits
	has_init ::= var->node->children_count > 1;
	if(typename.descriptor == (ast_typename_descriptor.deduced))
	{
		if(!has_init)
		{
			psyc_error_begin(var->node->loc);
			putzstr("variable ");
			putchar('"');
			putbytes(decl.name, decl.name_len);
			putchar('"');
			putzstr(" is of deduced-type but did not have an initialiser");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(var->node->loc.file)->src, var->node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// get the initialiser (typeonly)
		// thats our type
		var->type = (val_node(ast_get_child(var->node, 1), scope, val_resolution.type_only).type);
	}
	else
	{
		if(typename.descriptor == (ast_typename_descriptor.inferred_from))
		{
			// the child of the typename node is going to be some expression of some type.
			inferred_expr_node ::= ast_get_child(var_typename_node, 0);
			// thats our type (but also add any additional qualifiers)
			var->type = ty_set_qual(val_node(inferred_expr_node, scope, val_resolution.type_only).type, typename.quals);
		}
		else
		{
			// ok this typename relies on no program state so just call the ty_tyname thing on it
			var->type = ty_typename_node(var_typename_node);
		}
	}
	if(has_init)
	{
		init_type ::= (val_node(ast_get_child(var->node, 1), scope, val_resolution.type_only).type);
		ty_ensure_convertible_to(init_type, var->type, var->node);
	}
};
