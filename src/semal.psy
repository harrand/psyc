semal : func(-> v0)
{
	psyc_timed_begin(psyc_stage.semantic);
	semal_all_structs();
	semal_all_assemblys();
	semal_all_global_variables();
	semal_all_functions();
	psyc_timed_end();
};

semal_all_structs : func(-> v0)
{
	// go through every single struct type
	// populate the types.
	box ::= ref(prog.types);
	i : u64 mut;
	for(i = 0; i < (box->data_count); i = i + 1)
	{
		id ::= (i@s64@tyid);
		if(ty_is_struct(id))
		{
			semal_struct(id);
		}
	}
};

semal_struct : func(type : tyid -> v0)
{
	s ::= ty_unwrap(type);
	node ::= s->strct.node;
	i : u64 mut;
	for(i = 0; i < (node->children_count); i = i + 1)
	{
		child ::= ast_get_child(node, i);
		decl ::= child->decl;
		[s->strct.member_names # i] = (decl.name);
		[s->strct.member_name_lens # i] = (decl.name_len);
		// typename is first child of the decl
		typename_node ::= ast_get_child(child, 0);
		cur_ty ::= ty_typename_node(typename_node, program_scope());
		if(cur_ty == zero)
		{
			// dodgy member type.
			psyc_error_begin(child->loc);
			putzstr("type of data member ");
			putty(type);
			putzstr("::");
			putbytes(decl.name, decl.name_len);
			putzstr(" was not valid");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(ty_matches_ignore_quals(cur_ty, type))
		{
			// struct is a member of itself.
			psyc_error_begin(child->loc);
			putzstr("recursive struct - data member ");
			putty(type);
			putzstr("::");
			putbytes(decl.name, decl.name_len);
			putzstr(" is itself a ");
			putchar('"');
			putty(cur_ty);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		[s->strct.members # i] = cur_ty;
	}
};

semal_all_assemblys : func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0; i < (progscope->assemblys_count); i = i + 1)
	{
		semal_assembly(progscope->assemblys # i);
	}
};

semal_all_global_variables : func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0; i < (progscope->variables_count); i = i + 1)
	{
		semal_variable(progscope->variables # i, progscope);
	}
};

assembly_constraint_count_inputs : func(str : u8?, len : u64 -> u64)
{
	count : u64 mut := 0;
	cursor : u64 mut := 0;
	start : bool mut := true;
	while(cursor < len)
	{
		char ::= [str # cursor];
		if(!start)
		{
			if(char == ',')
			{
				start = true;
			}
		}
		else
		{
			// if its a { or a digit, its an input
			start = false;
			if((char == '{') || (char == '*') || isdigit(char))
			{
				count = count + 1;
			}
		}
		cursor = cursor + 1;
	}
	return count;
};

semal_assembly : func(as : assembly mut? -> v0)
{
	i : u64 mut;
	input_count ::= assembly_constraint_count_inputs(as->constraints, as->constraints_len);
	params : tyid mut? := arena_alloc(global_arena, input_count * sizeof typeof(tyid));
	for(i = 0; i < input_count; i = i + 1)
	{
		[params # i] = ty_set_qual(tyid.s64, tyqual.qual_weak);
	}
	as->type = ty_fn(ty_set_qual(tyid.s64, tyqual.qual_weak), params, input_count, zero);
};

semal_all_functions : func(-> v0)
{
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0; i < (progscope->functions_count); i = i + 1)
	{
		semal_funcsig(progscope->functions # i);
	}
	for(i = 0; i < (progscope->functions_count); i = i + 1)
	{
		semal_funcdef(progscope->functions # i);
	}
};

semal_funcsig : func(fn : function mut? -> v0)
{
	// function typename is first child of node
	function_typename_node ::= ast_get_child(fn->node, 0);
	fn->type = ty_typename_node(function_typename_node, program_scope());
	if(!ty_has_qual(fn->type, tyqual.qual_static))
	{
		if(ty_unstaticify(fn->type) != (fn->type))
		{
			psyc_error_begin(function_typename_node->loc);
			putzstr("non-static functions cannot have any static parameters");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(function_typename_node->loc.file)->src, function_typename_node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
};

semal_funcdef : func(fn : function mut? -> v0)
{
	// also go through the scope and semal all the typenames
	i : u64 mut;
	funcscope ::= fn->scope@lexical_scope mut?;
	for(i = 0; i < (funcscope->variables_count); i = i + 1)
	{
		semal_variable(funcscope->variables # i, funcscope);
	}
};

semal_variable : func(var : variable mut?, scope : lexical_scope mut? -> v0)
{
	decl ::= var->node->decl;
	// set the typename of a variable
	var_typename_node ::= ast_get_child(var->node, 0);
	typename ::= var_typename_node->typename;
	// handle the special typename bits
	has_init ::= var->node->children_count > 1;
	if(typename.descriptor == (ast_typename_descriptor.deduced))
	{
		if(!has_init)
		{
			psyc_error_begin(var->node->loc);
			putzstr("variable ");
			putchar('"');
			putbytes(decl.name, decl.name_len);
			putchar('"');
			putzstr(" is of deduced-type but did not have an initialiser");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(var->node->loc.file)->src, var->node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// get the initialiser (typeonly)
		// thats our type
		var->type = (val_node(ast_get_child(var->node, 1), scope, val_resolution.type_only).type);
	}
	else
	{
		var->type = ty_typename_node(var_typename_node, scope);
	}
	if(has_init)
	{
		init_node ::= ast_get_child(var->node, 1);
		// check for 'zero' as initialiser
		// we cant check its type is comparable because zero has no type
		// so we check it as a special-case here (and dont do any typechecking if its zero coz thats always valid)
		if(!ast_is_expr(init_node, ast_expr_tag.zero_value))
		{
			init_type ::= (val_node(init_node, scope, val_resolution.type_only).type);
			ty_ensure_convertible_to(init_type, var->type, var->node);
		}
	}
};
