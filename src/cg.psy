cg_integral_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

// given a value that is guaranteed to have a valid sval
// generate a u64 that corresponds to the runtime value of that sval
// note: ignore v->cg at this point as it cannot be trusted and is 99% going to be zero anyway.
cg_sval ::= func(v : val?, source : ast? -> u64)
{
	psyc_nyi(source->loc);
	return zero;
};
