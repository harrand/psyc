ir : u64 mut;

codegen ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.codegen);
	cg_begin();

	cg_all_structs();
	cg_all_functions(program_scope());
	cg_end();
	psyc_timed_end();
};

cg_begin ::= func(-> v0)
{
	prog.cg = LLVMModuleCreateWithName("Psy Program");
	ir = LLVMCreateBuilder();
	prog.db = LLVMCreateDIBuilder(prog.cg);
};

cg_end ::= func(-> v0)
{
	// todo: _fltused
	err : u8? mut;
	if(LLVMVerifyModule(prog.cg, 2, ref err) != 0)
	{
		str ::= LLVMPrintModuleToString(prog.cg);
		putzstr("Codegen: ");
		putchar(10);
		putzstr(str);
		putchar(10);
		putchar(10);

		putzstr("LLVM Internal Codegen Failed:");
		putchar(10);
		putzstr(err);
		putchar(10);
		psyc_error_begin(zero);
		psyc_diag_end();
		psyc_exit_failure();
	}

	if(prog.compile_args.verbose_codegen)
	{
		putzstr("LLVM IR:");
		putchar(10);
		putzstr(LLVMPrintModuleToString(prog.cg));
		putchar(10);
	}
};

cg_type ::= func(type : tyid -> u64)
{
	t ::= ty_clear_all_quals(type);
	if(ty_is_prim(t))
	{
		if(t == (tyid.v0))
		{
			return LLVMVoidType();
		}
		if((t == (tyid.s64)) || (t == (tyid.u64)))
		{
			return LLVMInt64Type();
		}
		if((t == (tyid.s32)) || (t == (tyid.u32)))
		{
			return LLVMInt32Type();
		}
		if((t == (tyid.s16)) || (t == (tyid.u16)))
		{
			return LLVMInt16Type();
		}
		if((t == (tyid.s8)) || (t == (tyid.u8)))
		{
			return LLVMInt8Type();
		}
		if(t == (tyid.bool))
		{
			return LLVMInt1Type();
		}
		if(t == (tyid.f64))
		{
			return LLVMDoubleType();
		}
		if(t == (tyid.f32))
		{
			return LLVMFloatType();
		}
	}
	if(ty_is_enum(t))
	{
		return cg_type(tyid.s64);
	}
	if(ty_is_struct(t))
	{
		return ty_unwrap(t)->strct.cg;
	}
	if(ty_is_ptr(t))
	{
		return LLVMPointerType(cg_type(ty_underlying(t)), 0);
	}
	if(ty_is_arr(t))
	{
		return LLVMArrayType(cg_type(ty_underlying(t)), ty_unwrap(t)->array_len@u32);
	}
	if(ty_is_fn(t))
	{
		fntype ::= ty_unwrap(t);
		paramdata : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (fntype->fn.params_count));
		ret_cg ::= cg_type(fntype->fn.return_type);
		i : u64 mut;
		for(i = 0, i < (fntype->fn.params_count), i = i + 1)
		{
			deref(paramdata # i) = cg_type(deref(fntype->fn.param_types # i));
		}
		return LLVMFunctionType(ret_cg, paramdata, fntype->fn.params_count@u32, false@s32);
	}
	psyc_panic_begin(zero);
	putzstr("attempt to resolve ");
	putchar('"');
	putty(t);
	putchar('"');
	putzstr(" reached end of cg_type. either support for this type is unimplemented or this is a dodgy type.");
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_all_structs ::= func(-> v0)
{
	box ::= ref(prog.types);
	i : u64 mut;
	id : tyid mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_sig(id);
		}
	}
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_def(id);
		}
	}
};

cg_struct_sig ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	// goal: set s->cg to something
	name_zstr ::= sstr2zstr(t->name, t->name_len, string_arena);
	s->cg = LLVMStructCreateNamed(LLVMGetGlobalContext(), sstr2zstr(t->name, t->name_len, string_arena));
};

cg_struct_def ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	i : u64 mut;

	memarr : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (s->members_count));
	for(i = 0, i < (s->members_count), i = i + 1)
	{
		deref(memarr # i) = cg_type(deref(s->members # i));
	}
	LLVMStructSetBody(s->cg, memarr, s->members_count@u32, false@s32);
};

cg_all_functions ::= func(scope : lexical_scope mut? -> v0)
{
	i : u64 mut;
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_sig(scope->functions # i);
	}
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_def(scope->functions # i);
	}
};

llvm_add_function_string_attribute ::= func(fn : function mut?, attrib_name_zstr : u8? -> v0)
{
	attr ::= LLVMCreateStringAttribute(LLVMGetGlobalContext(), attrib_name_zstr, zstrlen(attrib_name_zstr)@u32, "", 0);
	LLVMAddAttributeAtIndex(fn->cg, LLVMAttributeFunctionIndex, attr);
};

cg_func_sig ::= func(fn : function mut? -> v0)
{
	is_extern ::= fn->node->function.is_extern;
	name_zstr ::= sstr2zstr(fn->name, fn->name_len, string_arena);
	fn->cg = LLVMAddFunction(prog.cg, name_zstr, cg_type(fn->type));
};

cg_func_def ::= func(fn : function mut? -> v0)
{
	if(fn->node->function.is_extern)
	{
		return;
	}
	// todo: function implementation contents
	llvm_add_function_string_attribute(fn, "no-stack-arg-probe");
	llvm_add_function_string_attribute(fn, "no-builtin-memset");
	llvm_add_function_string_attribute(fn, "no-builtin-memcpy");

	// ok we have a scope
	funcscope ::= fn->scope@lexical_scope mut?;
	funcscope->cg = LLVMAppendBasicBlock(fn->cg, "entry");
	LLVMPositionBuilderAtEnd(ir, funcscope->cg);
	// all local variables will be in this scope
	// so lets do them now.
	i : u64 mut;
	for(i = 0, i < (funcscope->variables_count), i = i + 1)
	{
		cg_local_variable(funcscope->variables # i);
	}
	last_child ::= ast_get_last_child_if_ret(fn->node);
	if(last_child == zero)
	{
		// if we return void then just add a retvoid here
		// otherwise, error out because we must end with a return.
		if(ty_is_v0(ty_unwrap(fn->type)->fn.return_type))
		{
			LLVMBuildRetVoid(ir);
		}
	}

	for(i = 1, i < (fn->node->children_count), i = i + 1)
	{
		cg_node(ast_get_child(fn->node, i), funcscope);
	}

	LLVMClearInsertionPosition(ir);
};

cg_local_variable ::= func(var : variable mut? -> v0)
{
	// do an alloca
	decl ::= var->node->decl;
	var->cg = LLVMBuildAlloca(ir, cg_type(var->type), sstr2zstr(decl.name, decl.name_len, string_arena));
};

cg_integral_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

// given a value that is guaranteed to have a valid sval
// generate a u64 that corresponds to the runtime value of that sval
// note: ignore v->cg at this point as it cannot be trusted and is 99% going to be zero anyway.
cg_sval ::= func(v : val?, source : ast? -> u64)
{
	s ::= v->s;
	// zero_values shouldnt exist at this point, if they do then the code is invalid
	if(ty_is_integral(v->type))
	{
		return LLVMConstInt(cg_type(v->type), s.primitive.integer, false@s32);
	}
	if(ty_is_floating_point(v->type))
	{
		return LLVMConstReal(cg_type(v->type), s.primitive.floating_point);
	}
	psyc_nyi(source->loc);
	return zero;
};

cg_convert_to ::= func(v : val?, to : tyid, source : ast? -> u64)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_ref ::= func(v : val?, source : ast? -> val)
{
	// sneakily change tag to .d so we're pretending its not a variable anymore
	// but the cg value is unchanged (variables are alloca pointers in llvm)
	// and we change the type to a pointer.
	valcpy : val mut? := arena_alloc(global_arena, __sizeof(val));
	memcopy(valcpy, v, __sizeof(val));
	return val
	{
		.tag := valtag.d_rvalue;
		.type := ty_ptr(v->type, zero);
		.cg := v->cg;
		.underlying := valcpy;
	};
};

cg_deref ::= func(v : val?, source : ast? -> val)
{
	underlying_ty ::= ty_underlying(v->type);
	rettag : valtag mut := valtag.d_rvalue;
	if(v->underlying != zero)
	{
		rettag = ((v->underlying@val?)->tag);
	}
	return val
	{
		.tag := rettag;
		.type := underlying_ty;
		.cg := LLVMBuildLoad2(ir, cg_type(underlying_ty), v->cg, "");
		.underlying := zero;
	};
};

cg_decl ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	// we naturally reached a local variable decl.  // remember these have been hoisted before so the alloca exists.
	decl ::= node->decl;
	var ::= scope_find_variable(scope, decl.name, decl.name_len);
	if(val_is_valid(var->init))
	{
		// alloca is var->cg
		// get a dynamic value for sure.
		if(val_is_static(var->init))
		{
			val_static2dynamic(ref(var->init), node);
		}
		// do the store
		LLVMBuildStore(ir, var->init.cg, var->cg);
	}
	// otherwise do nothing.
	// todo: debug location goes here though.
	return val_runtime_from_variable(var);
};

cg_node ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	if(ast_is_stmt(node, ast_stmt_tag.decl))
	{
		return cg_decl(node, scope);
	}
	if(ast_is_stmt(node, ast_stmt_tag.ret))
	{
		// return stmt.
		if(node->children_count == 0)
		{
			LLVMBuildRetVoid(ir);
			return zero;
		}
		else
		{
			retval ::= cg_node(ast_get_child(node, 0), scope);
			LLVMBuildRet(ir, retval.cg);
		}
	}
	return val_node(node, scope);
};
