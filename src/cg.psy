ir : u64 mut;

codegen ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.codegen);
	cg_begin();
	i : u64 mut;
	progscope ::= program_scope();
	for(i = 0, i < (progscope->functions_count), i = i + 1)
	{
		cg_func(progscope->functions # i);
	}
	cg_end();
	psyc_timed_end();
};

cg_begin ::= func(-> v0)
{
	prog.cg = LLVMModuleCreateWithName("Psy Program");
	ir = LLVMCreateBuilder();
	prog.db = LLVMCreateDIBuilder(prog.cg);
};

cg_end ::= func(-> v0)
{
	// todo: _fltused
	err : u8? mut;
	if(LLVMVerifyModule(prog.cg, 2, ref err) != 0)
	{
		str ::= LLVMPrintModuleToString(prog.cg);
		putzstr("Codegen: ");
		putchar(10);
		putzstr(str);
		putchar(10);
		putchar(10);

		putzstr("LLVM Internal Codegen Failed:");
		putchar(10);
		putzstr(err);
		putchar(10);
		psyc_error_begin(zero);
		psyc_diag_end();
		psyc_exit_failure();
	}
};

cg_func ::= func(fn : function mut? -> v0)
{
};

cg_integral_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

// given a value that is guaranteed to have a valid sval
// generate a u64 that corresponds to the runtime value of that sval
// note: ignore v->cg at this point as it cannot be trusted and is 99% going to be zero anyway.
cg_sval ::= func(v : val?, source : ast? -> u64)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_convert_to ::= func(v : val?, to : tyid, source : ast? -> u64)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_ref ::= func(v : val?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};
