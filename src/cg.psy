ir : u64 mut := zero;

codegen ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.codegen);
	cg_begin();

	cg_all_structs();
	cg_all_functions(program_scope());
	cg_end();
	psyc_timed_end();
};

cg_begin ::= func(-> v0)
{
	prog.cg = LLVMModuleCreateWithName("Psy Program");
	ir = LLVMCreateBuilder();
	prog.db = LLVMCreateDIBuilder(prog.cg);
};

cg_end ::= func(-> v0)
{
	// todo: _fltused
	err : u8? mut;
	if(LLVMVerifyModule(prog.cg, 2, ref err) != 0)
	{
		str ::= LLVMPrintModuleToString(prog.cg);
		putzstr("Codegen: ");
		putchar(10);
		putzstr(str);
		putchar(10);
		putchar(10);

		putzstr("LLVM Internal Codegen Failed:");
		putchar(10);
		putzstr(err);
		putchar(10);
		psyc_error_begin(zero);
		psyc_diag_end();
		psyc_exit_failure();
	}

	if(prog.compile_args.verbose_codegen)
	{
		putzstr("LLVM IR:");
		putchar(10);
		putzstr(LLVMPrintModuleToString(prog.cg));
		putchar(10);
	}
};

cg_type ::= func(type : tyid -> u64)
{
	t ::= ty_clear_all_quals(type);
	if(ty_is_prim(t))
	{
		if(t == (tyid.v0))
		{
			return LLVMVoidType();
		}
		if((t == (tyid.s64)) || (t == (tyid.u64)))
		{
			return LLVMInt64Type();
		}
		if((t == (tyid.s32)) || (t == (tyid.u32)))
		{
			return LLVMInt32Type();
		}
		if((t == (tyid.s16)) || (t == (tyid.u16)))
		{
			return LLVMInt16Type();
		}
		if((t == (tyid.s8)) || (t == (tyid.u8)))
		{
			return LLVMInt8Type();
		}
		if(t == (tyid.bool))
		{
			return LLVMInt1Type();
		}
		if(t == (tyid.f64))
		{
			return LLVMDoubleType();
		}
		if(t == (tyid.f32))
		{
			return LLVMFloatType();
		}
	}
	if(ty_is_enum(t))
	{
		return cg_type(tyid.s64);
	}
	if(ty_is_struct(t))
	{
		return ty_unwrap(t)->strct.cg;
	}
	if(ty_is_ptr(t))
	{
		return LLVMPointerType(cg_type(ty_underlying(t)), 0);
	}
	if(ty_is_arr(t))
	{
		return LLVMArrayType(cg_type(ty_underlying(t)), ty_unwrap(t)->array_len@u32);
	}
	if(ty_is_fn(t))
	{
		fntype ::= ty_unwrap(t);
		paramdata : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (fntype->fn.params_count));
		ret_cg ::= cg_type(fntype->fn.return_type);
		i : u64 mut;
		for(i = 0, i < (fntype->fn.params_count), i = i + 1)
		{
			deref(paramdata # i) = cg_type(deref(fntype->fn.param_types # i));
		}
		return LLVMFunctionType(ret_cg, paramdata, fntype->fn.params_count@u32, false@s32);
	}
	psyc_panic_begin(zero);
	putzstr("attempt to resolve ");
	putchar('"');
	putty(t);
	putchar('"');
	putzstr(" reached end of cg_type. either support for this type is unimplemented or this is a dodgy type.");
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_all_structs ::= func(-> v0)
{
	box ::= ref(prog.types);
	i : u64 mut;
	id : tyid mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_sig(id);
		}
	}
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_def(id);
		}
	}
};

cg_struct_sig ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	// goal: set s->cg to something
	name_zstr ::= sstr2zstr(t->name, t->name_len, string_arena);
	s->cg = LLVMStructCreateNamed(LLVMGetGlobalContext(), sstr2zstr(t->name, t->name_len, string_arena));
};

cg_struct_def ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	i : u64 mut;

	memarr : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (s->members_count));
	for(i = 0, i < (s->members_count), i = i + 1)
	{
		deref(memarr # i) = cg_type(deref(s->members # i));
	}
	LLVMStructSetBody(s->cg, memarr, s->members_count@u32, false@s32);
};

cg_all_functions ::= func(scope : lexical_scope mut? -> v0)
{
	i : u64 mut;
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_sig(scope->functions # i);
	}
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_def(scope->functions # i);
	}
};

llvm_add_function_string_attribute ::= func(fn : function mut?, attrib_name_zstr : u8? -> v0)
{
	attr ::= LLVMCreateStringAttribute(LLVMGetGlobalContext(), attrib_name_zstr, zstrlen(attrib_name_zstr)@u32, "", 0);
	LLVMAddAttributeAtIndex(fn->cg, LLVMAttributeFunctionIndex, attr);
};

cg_func_sig ::= func(fn : function mut? -> v0)
{
	is_extern ::= fn->node->function.is_extern;
	name_zstr ::= sstr2zstr(fn->name, fn->name_len, string_arena);
	fn->cg = LLVMAddFunction(prog.cg, name_zstr, cg_type(fn->type));
};

cg_func_def ::= func(fn : function mut? -> v0)
{
	if(fn->node->function.is_extern)
	{
		return;
	}
	// todo: function implementation contents
	llvm_add_function_string_attribute(fn, "no-stack-arg-probe");
	llvm_add_function_string_attribute(fn, "no-builtin-memset");
	llvm_add_function_string_attribute(fn, "no-builtin-memcpy");

	// ok we have a scope
	funcscope ::= fn->scope@lexical_scope mut?;
	funcscope->cg = LLVMAppendBasicBlock(fn->cg, "entry");
	LLVMPositionBuilderAtEnd(ir, funcscope->cg);
	// all local variables will be in this scope
	// so lets do them now.
	i : u64 mut;
	for(i = 0, i < (funcscope->variables_count), i = i + 1)
	{
		cg_local_variable(funcscope->variables # i);
	}

	for(i = 1, i < (fn->node->children_count), i = i + 1)
	{
		cg_node(ast_get_child(fn->node, i), funcscope);
	}

	last_child ::= ast_get_last_child_if_ret(fn->node);
	if(last_child == zero)
	{
		// if we return void then just add a retvoid here
		// otherwise, error out because we must end with a return.
		if(ty_is_v0(ty_unwrap(fn->type)->fn.return_type))
		{
			LLVMBuildRetVoid(ir);
		}
	}

	LLVMClearInsertionPosition(ir);
};

cg_local_variable ::= func(var : variable mut? -> v0)
{
	// do an alloca
	decl ::= var->node->decl;
	var->cg = LLVMBuildAlloca(ir, cg_type(var->type), sstr2zstr(decl.name, decl.name_len, string_arena));
};

cg_integral_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	ret : val mut := cg_load_if_lvalue(deref v);
	if(op == (ast_unop.minus))
	{
		ret.cg = LLVMBuildNeg(ir, v->cg, "");
		return ret;
	}
	if(op == (ast_unop.bitwise_invert))
	{
		ret.cg = LLVMBuildNot(ir, v->cg, "");
		return ret;
	}
	psyc_panic_begin(source->loc);
	putzstr("control reached end of cg_integral_unop for ast_unop.");
	putzstr(__enumname(op));
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_integral_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	// assume lhs and rhs are pre-converted to the corect types.
	lhsv ::= cg_load_if_lvalue(deref lhs);
	rhsv ::= cg_load_if_lvalue(deref rhs);
	ret : val mut := lhsv;
	// dont worry about assign here. handled elsewhere in cg coz its a special case.
	if(op == (ast_biop.add))
	{
		ret.cg = LLVMBuildAdd(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.sub))
	{
		ret.cg = LLVMBuildSub(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.mul))
	{
		ret.cg = LLVMBuildMul(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.div))
	{
		if(ty_is_signed_integral(lhsv.type))
		{
			ret.cg = LLVMBuildSDiv(ir, lhsv.cg, rhsv.cg, "");
		}
		else
		{
			ret.cg = LLVMBuildUDiv(ir, lhsv.cg, rhsv.cg, "");
		}
		return ret;
	}
	if(op == (ast_biop.bitwise_or))
	{
		ret.cg = LLVMBuildOr(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.bitwise_and))
	{
		ret.cg = LLVMBuildAnd(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.xor))
	{
		ret.cg = LLVMBuildXor(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.bitshift_left))
	{
		ret.cg = LLVMBuildShl(ir, lhsv.cg, rhsv.cg, "");
		return ret;
	}
	if(op == (ast_biop.bitshift_right))
	{
		if(ty_is_signed_integral(lhsv.type))
		{
			ret.cg = LLVMBuildAShr(ir, lhsv.cg, rhsv.cg, "");
		}
		else
		{
			ret.cg = LLVMBuildLShr(ir, lhsv.cg, rhsv.cg, "");
		}
		return ret;
	}
	if(op == (ast_biop.modulo))
	{
		if(ty_is_signed_integral(lhsv.type))
		{
			ret.cg = LLVMBuildSRem(ir, lhsv.cg, rhsv.cg, "");
		}
		else
		{
			ret.cg = LLVMBuildURem(ir, lhsv.cg, rhsv.cg, "");
		}
		return ret;
	}
	
	psyc_panic_begin(source->loc);
	putzstr("control reached end of cg_integral_arith_biop for ast_biop.");
	putzstr(__enumname(op));
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_integral_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

// given a value that is guaranteed to have a valid sval
// generate a u64 that corresponds to the runtime value of that sval
// note: ignore v->cg at this point as it cannot be trusted and is 99% going to be zero anyway.
cg_sval ::= func(v : val?, source : ast? -> u64)
{
	s ::= v->s;
	// zero_values shouldnt exist at this point, if they do then the code is invalid
	if(ty_is_integral(v->type))
	{
		return LLVMConstInt(cg_type(v->type), s.primitive.integer, false@s32);
	}
	if(ty_is_floating_point(v->type))
	{
		return LLVMConstReal(cg_type(v->type), s.primitive.floating_point);
	}
	if(ty_is_bool(v->type))
	{
		return LLVMConstInt(cg_type(v->type), s.primitive.boolean@s64, false@s32);
	}
	psyc_nyi(source->loc);
	return zero;
};

cg_convert_to ::= func(v : val?, to : tyid, source : ast? -> u64)
{
	// v is guaranteed to be a dynamic value.
	from ::= v->type;
	from_size ::= ty_integral_size(from) + ty_floating_point_size(from);
	from_signed ::= ty_is_signed_integral(from);
	to_size ::= ty_integral_size(to) + ty_floating_point_size(to);
	to_signed ::= ty_is_signed_integral(to);
	cgto ::= cg_type(to);
	if(ty_is_integral(from))
	{
		if(ty_is_integral(to))
		{
			// i2i
			if(from_size < to_size)
			{
				// expanding to larger size
				if(from_signed)
				{
					return LLVMBuildSExt(ir, v->cg, cgto, "");
				}
				return LLVMBuildZExt(ir, v->cg, cgto, "");
			}
			if(from_size > to_size)
			{
				// truncating to smaller size
				return LLVMBuildTrunc(ir, v->cg, cgto, "");
			}
			// nothing
			return v->cg;
		}
		if(ty_is_floating_point(to))
		{
			// i2f
			if(from_signed)
			{
				return LLVMBuildSIToFP(ir, v->cg, cgto, "");
			}
			return LLVMBuildUIToFP(ir, v->cg, cgto, "");
		}
		if(ty_is_ptr(to))
		{
			// i2p
			return LLVMBuildIntToPtr(ir, v->cg, cgto, "");
		}
		if(ty_is_enum(to))
		{
			// trivial
			return cg_convert_to(v, tyid.s64, source);
		}
		if(ty_is_bool(to))
		{
			return LLVMBuildTrunc(ir, v->cg, cgto, "");
		}
	}
	if(ty_is_floating_point(from))
	{
		if(ty_is_integral(to))
		{
			// f2i
			if(to_signed)
			{
				return LLVMBuildFPToSI(ir, v->cg, cgto, "");
			}
			return LLVMBuildFPToUI(ir, v->cg, cgto, "");
		}
		if(ty_is_floating_point(to))
		{
			// f2f
			if(from_size > to_size)
			{
				// shrink
				return LLVMBuildFPTrunc(ir, v->cg, cgto, "");
			}
			if(from_size < to_size)
			{
				// expand
				return LLVMBuildFPExt(ir, v->cg, cgto, "");
			}
			return v->cg;
		}
	}
	if(ty_is_bool(from))
	{
		// b2i
		return LLVMBuildZExt(ir, v->cg, cgto, "");
	}
	if(ty_is_enum(from))
	{
		// can only be e2i
		return cg_convert_to(v, tyid.s64, source);
	}
	if(ty_is_ptr(from))
	{
		if(ty_is_integral(to))
		{
			// p2i
			return LLVMBuildPtrToInt(ir, v->cg, cgto, "");
		}
		if(ty_is_fn(to))
		{
			// p2fn. trivial.
			return v->cg;
		}
		if(ty_is_ptr(to))
		{
			// p2p. trivial.
			return v->cg;
		}
	}
	if(ty_is_fn(from))
	{
		// can only be fn2p. trivial.
		return v->cg;
	}

	psyc_panic_begin(source->loc);
	putzstr("control reached end of cg_convert_to. converting from ");
	putchar('"');
	putty(from);
	putchar('"');
	putzstr(" to ");
	putchar('"');
	putty(to);
	putchar('"');
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_ref ::= func(v : val?, source : ast? -> val)
{
	// sneakily change tag to .d so we're pretending its not a variable anymore
	// but the cg value is unchanged (variables are alloca pointers in llvm)
	// and we change the type to a pointer.
	valcpy : val mut? := arena_alloc(global_arena, __sizeof(val));
	memcopy(valcpy, v, __sizeof(val));
	return val
	{
		.tag := valtag.d_rvalue;
		.type := ty_ptr(v->type, zero);
		.cg := v->cg;
		.underlying := valcpy;
	};
};

cg_deref ::= func(v : val?, source : ast? -> val)
{
	underlying_ty ::= ty_underlying(v->type);
	rettag : valtag mut := valtag.d_rvalue;
	if(v->underlying != zero)
	{
		rettag = ((v->underlying@val?)->tag);
	}
	cg : u64 mut := 0;
	if(ir != zero)
	{
		cg = LLVMBuildLoad2(ir, cg_type(underlying_ty), v->cg, "");
	}
	return val
	{
		.tag := rettag;
		.type := underlying_ty;
		.cg := cg;
		.underlying := zero;
	};
};

cg_decl ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	// we naturally reached a local variable decl.  // remember these have been hoisted before so the alloca exists.
	decl ::= node->decl;
	var ::= scope_find_variable(scope, decl.name, decl.name_len);
	// so we have var->init
	// check if its valid (it could either be unset i.e tagzero or a type-only val (valtag.ty)
	if(val_is_type_only(var->init))
	{
		// the val is typeonly.
		// this means it wasnt computable at compile-time.
		// so we need to codegen the init
		var->init = cg_node(ast_get_child(var->node, 1), scope);
	}
	if(val_is_valid(var->init))
	{
		// alloca is var->cg
		// get a dynamic value for sure.
		if(val_is_static(var->init))
		{
			val_static2dynamic(ref(var->init), node);
		}
		// do the store
		LLVMBuildStore(ir, var->init.cg, var->cg);
	}
	// otherwise do nothing.
	// todo: debug location goes here though.
	return val_runtime_from_variable(var);
};

cg_static_if ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	// note form progwalk: if this is a static_if then we ignore the condition and just cg_node all the children
	// progwalk handles the condition and clears out the children as necessary (also handles else so this code is really simple hooray!)
	i : u64 mut;
	for(i = 1, i < (node->children_count), i = i + 1)
	{
		cg_node(ast_get_child(node, i), scope);
	}
	return zero;
};

cg_load_if_lvalue ::= func(v : val -> val)
{
	ret : val mut := v;
	if(val_is_lvalue(v))
	{
		ret.cg = LLVMBuildLoad2(ir, cg_type(ret.type), ret.cg, "");
		ret.tag = (valtag.d_rvalue);
	}
	return ret;
};

cg_if ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	if_blk ::= node->ifblk;
	if(if_blk.is_static)
	{
		return cg_static_if(node, scope);
	}
	// ok runtime if...
	// get the condition
	cond_node ::= ast_get_child(node, 0);
	cond_val ::= val_convert_to(cg_load_if_lvalue(cg_node(cond_node, scope)), tyid.bool, cond_node);

	// need the parent function...
	parent_fn ::= scope_get_parent_function(scope);
	if(parent_fn == zero)
	{
		psyc_error_begin(node->loc);
		putzstr("if statements that are not static are not allowed within the global scope");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}

	else_node ::= ast_get_last_child_if_else(node);

	old_block ::= LLVMGetInsertBlock(ir);
	ifscope ::= LLVMAppendBasicBlock(parent_fn->cg, "if");
	elsescope : u64 mut := zero;

	if(else_node != zero)
	{
		elsescope = LLVMAppendBasicBlock(parent_fn->cg, "else");
	}
	ifcont ::= LLVMAppendBasicBlock(parent_fn->cg, "ifcont");
	if(else_node == zero)
	{
		elsescope = ifcont;
	}
	i : u64 mut;

	// make the branch
	// if there is no else block then elsescope is just ifcont
	LLVMBuildCondBr(ir, cond_val.cg, ifscope, elsescope);
	// populate the if and else blocks now

	// if
	LLVMPositionBuilderAtEnd(ir, ifscope);
	was_return : bool mut := false;
	child : ast mut? mut := zero;

	ifnode_last_child : u64 mut := node->children_count;
	if(else_node != zero)
	{
		ifnode_last_child = (ifnode_last_child - 1);
	}
	for(i = 1, i < ifnode_last_child, i = i + 1)
	{
		child = ast_get_child(node, i);
		was_return = ast_is_stmt(child, ast_stmt_tag.ret);
		cg_node(child, scope);
	}
	if(!was_return)
	{
		// need to add an implicit jump to ifcont
		LLVMBuildBr(ir, ifcont);
	}

	// else
	if(else_node != zero)
	{
		LLVMPositionBuilderAtEnd(ir, elsescope);
		for(i = 0, i < (else_node->children_count), i = i + 1)
		{
			child = ast_get_child(else_node, i);
			was_return = ast_is_stmt(child, ast_stmt_tag.ret);
			cg_node(child, scope);
		}
		if(!was_return)
		{
			// need to add an implicit jump to ifcont
			LLVMBuildBr(ir, ifcont);
		}
	}
	
	LLVMPositionBuilderAtEnd(ir, ifcont);
	return zero;
};

cg_node ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	if(ast_is_stmt(node, ast_stmt_tag.decl))
	{
		return cg_decl(node, scope);
	}
	if(ast_is_stmt(node, ast_stmt_tag.ret))
	{
		parent_fn ::= scope_get_parent_function(scope);
		if(parent_fn == zero)
		{
			psyc_error_begin(node->loc);
			putzstr("return statements are not allowed within the global scope");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		parent_retty ::= ty_unwrap(parent_fn->type)->fn.return_type;
		// return stmt.
		if(node->children_count == 0)
		{
			if(!ty_is_v0(parent_retty))
			{
				psyc_error_begin(node->loc);
				putzstr("return statement within function ");
				putchar('"');
				putbytes(parent_fn->node->function.name, parent_fn->node->function.name_len);
				putchar('"');
				putzstr(" must return a value");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			LLVMBuildRetVoid(ir);
			return zero;
		}
		else
		{
			if(ty_is_v0(parent_retty))
			{
				psyc_error_begin(node->loc);
				putzstr("return statement within function ");
				putchar('"');
				putbytes(parent_fn->node->function.name, parent_fn->node->function.name_len);
				putchar('"');
				putzstr(" must not return anything");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			retval ::= val_convert_to(cg_node(ast_get_child(node, 0), scope), parent_retty, node);
			LLVMBuildRet(ir, retval.cg);
			return retval;
		}
	}
	if(ast_is_stmt(node, ast_stmt_tag.if_block))
	{
		return cg_if(node, scope);
	}
	if(ast_is_biop(node, ast_biop.assign))
	{
		// lhs is either a pointer or an lvalue
		lhs_val ::= cg_node(ast_get_child(node, 0), scope);
		rhs_val : val mut := cg_node(ast_get_child(node, 1), scope);
		val_static2dynamic(ref rhs_val, node);
		rhs_val = cg_load_if_lvalue(rhs_val);
		if(!ty_is_ptr(lhs_val.type) && !val_is_lvalue(lhs_val))
		{
			psyc_error_begin(node->loc);
			putzstr("lhs of assignment must either be a pointer or an lvalue");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// ok we just literally do the store
		LLVMBuildStore(ir, rhs_val.cg, lhs_val.cg);
		return lhs_val;
	}
	ret : val mut := val_node(node, scope, false);
	val_static2dynamic(ref ret, node);
	return ret;
};
