ir : u64 mut;

codegen ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.codegen);
	cg_begin();

	cg_all_structs();
	cg_all_functions(program_scope());
	cg_end();
	psyc_timed_end();
};

cg_begin ::= func(-> v0)
{
	prog.cg = LLVMModuleCreateWithName("Psy Program");
	ir = LLVMCreateBuilder();
	prog.db = LLVMCreateDIBuilder(prog.cg);
};

cg_end ::= func(-> v0)
{
	// todo: _fltused
	err : u8? mut;
	if(LLVMVerifyModule(prog.cg, 2, ref err) != 0)
	{
		str ::= LLVMPrintModuleToString(prog.cg);
		putzstr("Codegen: ");
		putchar(10);
		putzstr(str);
		putchar(10);
		putchar(10);

		putzstr("LLVM Internal Codegen Failed:");
		putchar(10);
		putzstr(err);
		putchar(10);
		psyc_error_begin(zero);
		psyc_diag_end();
		psyc_exit_failure();
	}

	if(prog.compile_args.verbose_codegen)
	{
		putzstr("LLVM IR:");
		putchar(10);
		putzstr(LLVMPrintModuleToString(prog.cg));
		putchar(10);
	}
};

cg_type ::= func(type : tyid -> u64)
{
	t ::= ty_clear_all_quals(type);
	if(ty_is_prim(t))
	{
		if(t == (tyid.v0))
		{
			return LLVMVoidType();
		}
		if((t == (tyid.s64)) || (t == (tyid.u64)))
		{
			return LLVMInt64Type();
		}
		if((t == (tyid.s32)) || (t == (tyid.u32)))
		{
			return LLVMInt32Type();
		}
		if((t == (tyid.s16)) || (t == (tyid.u16)))
		{
			return LLVMInt16Type();
		}
		if((t == (tyid.s8)) || (t == (tyid.u8)))
		{
			return LLVMInt8Type();
		}
		if(t == (tyid.bool))
		{
			return LLVMInt1Type();
		}
		if(t == (tyid.f64))
		{
			return LLVMDoubleType();
		}
		if(t == (tyid.f32))
		{
			return LLVMFloatType();
		}
	}
	if(ty_is_enum(t))
	{
		return cg_type(tyid.s64);
	}
	if(ty_is_struct(t))
	{
		return ty_unwrap(t)->strct.cg;
	}
	if(ty_is_ptr(t))
	{
		return LLVMPointerType(cg_type(ty_underlying(t)), 0);
	}
	if(ty_is_arr(t))
	{
		return LLVMArrayType(cg_type(ty_underlying(t)), ty_unwrap(t)->array_len@u32);
	}
	if(ty_is_fn(t))
	{
		fntype ::= ty_unwrap(t);
		paramdata : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (fntype->fn.params_count));
		ret_cg ::= cg_type(fntype->fn.return_type);
		i : u64 mut;
		for(i = 0, i < (fntype->fn.params_count), i = i + 1)
		{
			deref(paramdata # i) = cg_type(deref(fntype->fn.param_types # i));
		}
		return LLVMFunctionType(ret_cg, paramdata, fntype->fn.params_count@u32, false@s32);
	}
	psyc_panic_begin(zero);
	putzstr("attempt to resolve ");
	putchar('"');
	putty(t);
	putchar('"');
	putzstr(" reached end of cg_type. either support for this type is unimplemented or this is a dodgy type.");
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_all_structs ::= func(-> v0)
{
	box ::= ref(prog.types);
	i : u64 mut;
	id : tyid mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_sig(id);
		}
	}
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_def(id);
		}
	}
};

cg_struct_sig ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	// goal: set s->cg to something
	name_zstr ::= sstr2zstr(t->name, t->name_len, string_arena);
	s->cg = LLVMStructCreateNamed(LLVMGetGlobalContext(), sstr2zstr(t->name, t->name_len, string_arena));
};

cg_struct_def ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	i : u64 mut;

	memarr : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (s->members_count));
	for(i = 0, i < (s->members_count), i = i + 1)
	{
		deref(memarr # i) = cg_type(deref(s->members # i));
	}
	LLVMStructSetBody(s->cg, memarr, s->members_count@u32, false@s32);
};

cg_all_functions ::= func(scope : lexical_scope mut? -> v0)
{
	i : u64 mut;
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_sig(scope->functions # i);
	}
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_def(scope->functions # i);
	}
};

llvm_add_function_string_attribute ::= func(fn : function mut?, attrib_name_zstr : u8? -> v0)
{
	attr ::= LLVMCreateStringAttribute(LLVMGetGlobalContext(), attrib_name_zstr, zstrlen(attrib_name_zstr)@u32, "", 0);
	LLVMAddAttributeAtIndex(fn->cg, LLVMAttributeFunctionIndex, attr);
};

cg_func_sig ::= func(fn : function mut? -> v0)
{
	is_extern ::= fn->node->function.is_extern;
	name_zstr ::= sstr2zstr(fn->name, fn->name_len, string_arena);
	fn->cg = LLVMAddFunction(prog.cg, name_zstr, cg_type(fn->type));
};

cg_func_def ::= func(fn : function mut? -> v0)
{
	if(fn->node->function.is_extern)
	{
		return;
	}
	// todo: function implementation contents
	llvm_add_function_string_attribute(fn, "no-stack-arg-probe");
	llvm_add_function_string_attribute(fn, "no-builtin-memset");
	llvm_add_function_string_attribute(fn, "no-builtin-memcpy");

	// ok we have a scope
	funcscope ::= fn->scope@lexical_scope mut?;
	// all local variables will be in this scope
	// so lets do them now.
	i : u64 mut;
	for(i = 0, i < (funcscope->variables_count), i = i + 1)
	{
		var ::= funcscope->variables # i;
	}
};

cg_local_variable ::= func(var : variable mut? -> v0)
{
	// do an alloca
};

cg_integral_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_integral_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_floating_point_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_arith_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_bool_cmp_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

// given a value that is guaranteed to have a valid sval
// generate a u64 that corresponds to the runtime value of that sval
// note: ignore v->cg at this point as it cannot be trusted and is 99% going to be zero anyway.
cg_sval ::= func(v : val?, source : ast? -> u64)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_convert_to ::= func(v : val?, to : tyid, source : ast? -> u64)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_ref ::= func(v : val?, source : ast? -> val)
{
	// this is easy
	// firstly the val should be of tag d_var.
	if(v->tag == (valtag.d_lvalue))
	{
		// sneakily change tag to .d so we're pretending its not a variable anymore
		// but the cg value is unchanged (variables are alloca pointers in llvm)
		// and we change the type to a pointer.
		return val
		{
			.tag := valtag.d_rvalue;
			.type := ty_ptr(v->type, zero);
			.cg := v->cg;
		};
	}
	psyc_error_begin(source->loc);
	putzstr("ref keyword is invalid because you can only ref an lvalue");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};
