ir : u64 mut := zero;

codegen ::= func(-> v0)
{
	psyc_timed_begin(psyc_stage.codegen);
	cg_begin();

	cg_all_structs();
	cg_all_functions(program_scope());
	cg_end();
	psyc_timed_end();
};

cg_begin ::= func(-> v0)
{
	prog.cg = LLVMModuleCreateWithName("Psy Program");
	ir = LLVMCreateBuilder();
	prog.db = LLVMCreateDIBuilder(prog.cg);
};

cg_end ::= func(-> v0)
{
	// todo: _fltused
	err : u8? mut;
	if(LLVMVerifyModule(prog.cg, 2, ref err) != 0)
	{
		str ::= LLVMPrintModuleToString(prog.cg);
		putzstr("Codegen: ");
		putchar(10);
		putzstr(str);
		putchar(10);
		putchar(10);

		putzstr("LLVM Internal Codegen Failed:");
		putchar(10);
		putzstr(err);
		putchar(10);
		psyc_error_begin(zero);
		psyc_diag_end();
		psyc_exit_failure();
	}

	if(prog.compile_args.verbose_codegen)
	{
		putzstr("LLVM IR:");
		putchar(10);
		putzstr(LLVMPrintModuleToString(prog.cg));
		putchar(10);
	}
};

cg_type ::= func(type : tyid -> u64)
{
	t ::= ty_clear_all_quals(type);
	if(ty_is_prim(t))
	{
		if(t == (tyid.v0))
		{
			return LLVMVoidType();
		}
		if((t == (tyid.s64)) || (t == (tyid.u64)))
		{
			return LLVMInt64Type();
		}
		if((t == (tyid.s32)) || (t == (tyid.u32)))
		{
			return LLVMInt32Type();
		}
		if((t == (tyid.s16)) || (t == (tyid.u16)))
		{
			return LLVMInt16Type();
		}
		if((t == (tyid.s8)) || (t == (tyid.u8)))
		{
			return LLVMInt8Type();
		}
		if(t == (tyid.bool))
		{
			return LLVMInt1Type();
		}
		if(t == (tyid.f64))
		{
			return LLVMDoubleType();
		}
		if(t == (tyid.f32))
		{
			return LLVMFloatType();
		}
	}
	if(ty_is_enum(t))
	{
		return cg_type(tyid.s64);
	}
	if(ty_is_struct(t))
	{
		return ty_unwrap(t)->strct.cg;
	}
	if(ty_is_ptr(t))
	{
		return LLVMPointerType(cg_type(ty_underlying(t)), 0);
	}
	if(ty_is_arr(t))
	{
		return LLVMArrayType(cg_type(ty_underlying(t)), ty_unwrap(t)->array_len@u32);
	}
	if(ty_is_fn(t))
	{
		fntype ::= ty_unwrap(t);
		paramdata : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (fntype->fn.params_count));
		ret_cg ::= cg_type(fntype->fn.return_type);
		i : u64 mut;
		for(i = 0, i < (fntype->fn.params_count), i = i + 1)
		{
			deref(paramdata # i) = cg_type(deref(fntype->fn.param_types # i));
		}
		return LLVMFunctionType(ret_cg, paramdata, fntype->fn.params_count@u32, false@s32);
	}
	psyc_panic_begin(zero);
	putzstr("attempt to resolve ");
	putchar('"');
	putty(t);
	putchar('"');
	putzstr(" reached end of cg_type. either support for this type is unimplemented or this is a dodgy type.");
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

cg_all_structs ::= func(-> v0)
{
	box ::= ref(prog.types);
	i : u64 mut;
	id : tyid mut;
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_sig(id);
		}
	}
	for(i = 0, i < (box->data_count), i = i + 1)
	{
		id = i@tyid;
		if(ty_is_struct(id))
		{
			cg_struct_def(id);
		}
	}
};

cg_struct_sig ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	// goal: set s->cg to something
	name_zstr ::= sstr2zstr(t->name, t->name_len, string_arena);
	s->cg = LLVMStructCreateNamed(LLVMGetGlobalContext(), sstr2zstr(t->name, t->name_len, string_arena));
};

cg_struct_def ::= func(type : tyid -> v0)
{
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	i : u64 mut;

	memarr : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (s->members_count));
	for(i = 0, i < (s->members_count), i = i + 1)
	{
		deref(memarr # i) = cg_type(deref(s->members # i));
	}
	LLVMStructSetBody(s->cg, memarr, s->members_count@u32, false@s32);
};

cg_all_functions ::= func(scope : lexical_scope mut? -> v0)
{
	i : u64 mut;
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_sig(scope->functions # i);
	}
	for(i = 0, i < (scope->functions_count), i = i + 1)
	{
		cg_func_def(scope->functions # i);
	}
};

llvm_add_function_string_attribute ::= func(fn : function mut?, attrib_name_zstr : u8? -> v0)
{
	attr ::= LLVMCreateStringAttribute(LLVMGetGlobalContext(), attrib_name_zstr, zstrlen(attrib_name_zstr)@u32, "", 0);
	LLVMAddAttributeAtIndex(fn->cg, LLVMAttributeFunctionIndex, attr);
};

cg_func_sig ::= func(fn : function mut? -> v0)
{
	is_extern ::= fn->node->function.is_extern;
	name_zstr ::= sstr2zstr(fn->name, fn->name_len, string_arena);
	fn->cg = LLVMAddFunction(prog.cg, name_zstr, cg_type(fn->type));
};

cg_func_def ::= func(fn : function mut? -> v0)
{
	if(fn->node->function.is_extern)
	{
		return;
	}
	// todo: function implementation contents
	llvm_add_function_string_attribute(fn, "no-stack-arg-probe");
	llvm_add_function_string_attribute(fn, "no-builtin-memset");
	llvm_add_function_string_attribute(fn, "no-builtin-memcpy");

	// ok we have a scope
	funcscope ::= fn->scope@lexical_scope mut?;
	funcscope->cg = LLVMAppendBasicBlock(fn->cg, "entry");
	LLVMPositionBuilderAtEnd(ir, funcscope->cg);
	// all local variables will be in this scope
	// so lets do them now.
	i : u64 mut;
	for(i = 0, i < (funcscope->variables_count), i = i + 1)
	{
		cg_local_variable(funcscope->variables # i);
	}

	for(i = 1, i < (fn->node->children_count), i = i + 1)
	{
		cg_node(ast_get_child(fn->node, i), funcscope);
	}

	last_child ::= ast_get_last_child_if_ret(fn->node);
	if(last_child == zero)
	{
		// if we return void then just add a retvoid here
		// otherwise, error out because we must end with a return.
		if(ty_is_v0(ty_unwrap(fn->type)->fn.return_type))
		{
			LLVMBuildRetVoid(ir);
		}
	}

	LLVMClearInsertionPosition(ir);
};

cg_local_variable ::= func(var : variable mut? -> v0)
{
	// do an alloca
	decl ::= var->node->decl;
	var->cg = LLVMBuildAlloca(ir, cg_type(var->type), sstr2zstr(decl.name, decl.name_len, string_arena));
};

cg_convert_to ::= func(v : val, to : tyid, source : ast? -> val)
{
	psyc_nyi(source->loc);
	return zero;
};

cg_prim ::= func(type : tyid, prim : ast_literal, source : ast? -> val)
{
	i : u64 mut;
	// zero_values shouldnt exist at this point, if they do then the code is invalid
	if(ty_is_integral(type))
	{
		return val
		{
			.tag := valtag.typed_value;
			.known := valknown.runtime;
			.hand := valhand.rvalue;
			.type := type;
			.compile_time := zero;
			.runtime := valruntime{.cg := LLVMConstInt(cg_type(type), prim.integer, false@s32);};
		};
	}
	if(ty_is_floating_point(type))
	{
		return val
		{
			.tag := valtag.typed_value;
			.known := valknown.runtime;
			.hand := valhand.rvalue;
			.type := type;
			.compile_time := zero;
			.runtime := valruntime{.cg :=  LLVMConstReal(cg_type(type), prim.floating_point);};
		};
	}
	if(ty_is_bool(type))
	{
		return val
		{
			.tag := valtag.typed_value;
			.known := valknown.runtime;
			.hand := valhand.rvalue;
			.type := type;
			.compile_time := zero;
			.runtime := valruntime{.cg := LLVMConstInt(cg_type(type), prim.boolean@s64, false@s32);};
		};
	}
	psyc_nyi(source->loc);
	return zero;
};

// return a runtime val representation of a function
cg_funcref ::= func(fn : function? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.runtime;
		.hand := valhand.rvalue;
		.type := fn->type;
		.compile_time := zero;
		.runtime := valruntime{.cg := fn->cg;};
	};
};

// return a runtime val representation of a variable
cg_varref ::= func(v : variable? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.runtime;
		.hand := valhand.lvalue;
		.type := v->type;
		.compile_time := zero;
		.runtime := valruntime{.cg := v->cg;};
	};
};

cg_node ::= func(node : ast?, scope : lexical_scope? -> val)
{
	if(ast_is_stmt(node, ast_stmt_tag.ret))
	{
		parent_fn ::= scope_get_parent_function(scope);
		if(parent_fn == zero)
		{
			psyc_error_begin(node->loc);
			putzstr("return statements are not allowed within the global scope");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		parent_retty ::= ty_unwrap(parent_fn->type)->fn.return_type;
		// return stmt.
		if(node->children_count == 0)
		{
			if(!ty_is_v0(parent_retty))
			{
				psyc_error_begin(node->loc);
				putzstr("return statement within function ");
				putchar('"');
				putbytes(parent_fn->node->function.name, parent_fn->node->function.name_len);
				putchar('"');
				putzstr(" must return a value");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			LLVMBuildRetVoid(ir);
			return zero;
		}
		else
		{
			if(ty_is_v0(parent_retty))
			{
				psyc_error_begin(node->loc);
				putzstr("return statement within function ");
				putchar('"');
				putbytes(parent_fn->node->function.name, parent_fn->node->function.name_len);
				putchar('"');
				putzstr(" must not return anything");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			retval ::= val_convert_to(cg_node(ast_get_child(node, 0), scope), parent_retty, scope, val_resolution.runtime_only, node);
			LLVMBuildRet(ir, retval.runtime.cg);
			return retval;
		}
	}
	if(ast_is_stmt(node, ast_stmt_tag.if_block))
	{
		return cg_if(node, scope);
	}
	if(ast_is_stmt(node, ast_stmt_tag.while_block))
	{
		return cg_while(node, scope);
	}
	if(ast_is_stmt(node, ast_stmt_tag.for_block))
	{
		return cg_for(node, scope);
	}	
	return val_node(node, scope, val_resolution.runtime_only);
};

cg_ref ::= func(v : val, source : ast? -> val)
{
	// i have some value. its guaranteed to be an lvalue (i.e a direct variable)
	// it just got val_dynamic'd
	// so the runtime cg would be the alloca.
	// well we just return a runtime val with the cg still being the alloca
	// but its an rvalue and its type is ref(v.type)
	ret : val mut := v;
	ret.type = ty_ptr(v.type, zero);
	ret.hand = (valhand.rvalue);
	return ret;
};

cg_deref ::= func(v : val, source : ast? -> val)
{
	// i need to deref something
	// i definitely have a pointer.
	// we maintain lvalue-ness (so deref(foo) = 5 works)

	// so we *dont* do a load here
	// we just pretend that its an lvalue
	ret : val mut := v;
	ret.type = ty_underlying(v.type);
	ret.hand = (valhand.lvalue);
	return ret;

	//ret : val mut := v;
	//ret.type = ty_underlying(v.type);
	//ret.runtime = valruntime{.cg := LLVMBuildLoad2(ir, cg_type(ret.type), v.runtime.cg, "");};
};

cg_undef_as ::= func(type : tyid -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.runtime;
		.hand := valhand.rvalue;
		.type := type;
		.compile_time := zero;
		.runtime := valruntime
		{
			.cg := LLVMGetUndef(cg_type(type));
		};
	};
};

cg_empty_blkinit ::= func(type : tyid -> val)
{
	return cg_undef_as(type);
};

cg_blkinit_add ::= func(v : val mut, memidx : u64, init : val -> val)
{
	v.runtime.cg = LLVMBuildInsertValue(ir, v.runtime.cg, init.runtime.cg, memidx@u32, "");
	return v;
};

cg_biop_assign ::= func(lhs : val, rhs : val, source : ast? -> val)
{
	LLVMBuildStore(ir, rhs.runtime.cg, lhs.runtime.cg);
	return lhs;
};

cg_biop_add ::= func(lhs : val, rhs : val, source : ast? -> val)
{
	type ::= lhs.type;
	ret ::= val mut
	{
		.tag := valtag.typed_value;
		.known := valknown.runtime;
		.hand := valhand.rvalue;
		.type := type;
		.compile_time := zero;
		.runtime := zero;
	};
	// guaranteed to be the same type
	if(ty_is_integral(type))
	{
		ret.runtime.cg = LLVMBuildAdd(ir, lhs.runtime.cg, rhs.runtime.cg, "");
	}
	else
	{
		ret.runtime.cg = LLVMBuildFAdd(ir, lhs.runtime.cg, rhs.runtime.cg, "");
	}

	return ret;
};

cg_load_if_lvalue ::= func(v : val -> val)
{
	ret : val mut := v;
	if(v.hand == (valhand.lvalue))
	{
		ret.runtime.cg = LLVMBuildLoad2(ir, cg_type(ret.type), ret.runtime.cg, "");
		ret.hand = (valhand.rvalue);
	}
	return ret;
};

cg_decl ::= func(var : variable mut?, scope : lexical_scope mut? -> val)
{
	if(var->node->children_count == 2)
	{
		// has an initialiser
		init ::= cg_load_if_lvalue(cg_node(ast_get_child(var->node, 1), scope));
		LLVMBuildStore(ir, init.runtime.cg, var->cg);
	}
	// todo: debug declare the variable here.
	return zero;
};

cg_static_if ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	// note form progwalk: if this is a static_if then we ignore the condition and just cg_node all the children
	// progwalk handles the condition and clears out the children as necessary (also handles else so this code is really simple hooray!)
	i : u64 mut;
	for(i = 1, i < (node->children_count), i = i + 1)
	{
		cg_node(ast_get_child(node, i), scope);
	}
	return zero;
};

cg_if ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	if_blk ::= node->ifblk;
	if(if_blk.is_static)
	{
		return cg_static_if(node, scope);
	}
	// ok runtime if...
	// need the parent function...
	parent_fn ::= scope_get_parent_function(scope);
	if(parent_fn == zero)
	{
		psyc_error_begin(node->loc);
		putzstr("if statements that are not static are not allowed within the global scope");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}

	// get the condition
	cond_node ::= ast_get_child(node, 0);
	cond_val ::= val_convert_to(cg_load_if_lvalue(cg_node(cond_node, scope)), tyid.bool, scope, val_resolution.runtime_only, cond_node);

	else_node ::= ast_get_last_child_if_else(node);

	ifscope ::= LLVMAppendBasicBlock(parent_fn->cg, "if");
	elsescope : u64 mut := zero;

	if(else_node != zero)
	{
		elsescope = LLVMAppendBasicBlock(parent_fn->cg, "else");
	}
	ifcont ::= LLVMAppendBasicBlock(parent_fn->cg, "ifcont");
	if(else_node == zero)
	{
		elsescope = ifcont;
	}
	i : u64 mut;

	// make the branch
	// if there is no else block then elsescope is just ifcont
	LLVMBuildCondBr(ir, cond_val.runtime.cg, ifscope, elsescope);
	// populate the if and else blocks now

	// if
	LLVMPositionBuilderAtEnd(ir, ifscope);
	was_return : bool mut := false;
	child : ast mut? mut := zero;

	ifnode_last_child : u64 mut := node->children_count;
	if(else_node != zero)
	{
		ifnode_last_child = (ifnode_last_child - 1);
	}
	for(i = 1, i < ifnode_last_child, i = i + 1)
	{
		child = ast_get_child(node, i);
		was_return = ast_is_stmt(child, ast_stmt_tag.ret);
		cg_node(child, scope);
	}
	if(!was_return)
	{
		// need to add an implicit jump to ifcont
		LLVMBuildBr(ir, ifcont);
	}

	// else
	if(else_node != zero)
	{
		LLVMPositionBuilderAtEnd(ir, elsescope);
		for(i = 0, i < (else_node->children_count), i = i + 1)
		{
			child = ast_get_child(else_node, i);
			was_return = ast_is_stmt(child, ast_stmt_tag.ret);
			cg_node(child, scope);
		}
		if(!was_return)
		{
			// need to add an implicit jump to ifcont
			LLVMBuildBr(ir, ifcont);
		}
	}
	
	LLVMPositionBuilderAtEnd(ir, ifcont);
	return zero;
};

cg_while ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	// need the parent function...
	parent_fn ::= scope_get_parent_function(scope);
	if(parent_fn == zero)
	{
		psyc_error_begin(node->loc);
		putzstr("while statements are not allowed within the global scope");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}

	// get the condition
	cond_node ::= ast_get_child(node, 0);
	cond_val ::= val_convert_to(cg_load_if_lvalue(cg_node(cond_node, scope)), tyid.bool, scope, val_resolution.runtime_only, cond_node);

	whilescope ::= LLVMAppendBasicBlock(parent_fn->cg, "while");
	whilecont ::= LLVMAppendBasicBlock(parent_fn->cg, "whilecont");
	i : u64 mut;

	// make the branch
	LLVMBuildCondBr(ir, cond_val.runtime.cg, whilescope, whilecont);
	// populate the while block now

	// while
	LLVMPositionBuilderAtEnd(ir, whilescope);
	was_return : bool mut := false;
	child : ast mut? mut := zero;

	for(i = 1, i < (node->children_count), i = i + 1)
	{
		child = ast_get_child(node, i);
		was_return = ast_is_stmt(child, ast_stmt_tag.ret);
		cg_node(child, scope);
	}
	if(!was_return)
	{
		// loop back if cond is still true, otherwise whilecont
		new_cond_val ::= val_convert_to(cg_load_if_lvalue(cg_node(cond_node, scope)), tyid.bool, scope, val_resolution.runtime_only, cond_node);
		LLVMBuildCondBr(ir, new_cond_val.runtime.cg, whilescope, whilecont);
	}
	
	LLVMPositionBuilderAtEnd(ir, whilecont);
	return zero;
};

cg_for ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	// need the parent function...
	parent_fn ::= scope_get_parent_function(scope);
	if(parent_fn == zero)
	{
		psyc_error_begin(node->loc);
		putzstr("for statements are not allowed within the global scope");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}

	init_node ::= ast_get_child(node, 0);
	cond_node ::= ast_get_child(node, 1);
	iter_node ::= ast_get_child(node, 2);
	// first just do the init
	cg_node(init_node, scope);
	forscope ::= LLVMAppendBasicBlock(parent_fn->cg, "for");
	forcont ::= LLVMAppendBasicBlock(parent_fn->cg, "forcont");
	i : u64 mut;

	initial_cond_val ::= cg_node(cond_node, scope);
	LLVMBuildCondBr(ir, initial_cond_val.runtime.cg, forscope, forcont);

	// populate the for block
	LLVMPositionBuilderAtEnd(ir, forscope);
	was_return : bool mut := false;
	child : ast mut? mut := zero;

	for(i = 3, i < (node->children_count), i = i + 1)
	{
		child = ast_get_child(node, i);
		was_return = ast_is_stmt(child, ast_stmt_tag.ret);
		cg_node(child, scope);
	}
	cg_node(iter_node, scope);
	if(!was_return)
	{
		// loop back if cond is still true, otherwise forcont
		new_cond_val ::= val_convert_to(cg_load_if_lvalue(cg_node(cond_node, scope)), tyid.bool, scope, val_resolution.runtime_only, cond_node);
		LLVMBuildCondBr(ir, new_cond_val.runtime.cg, forscope, forcont);
	}

	LLVMPositionBuilderAtEnd(ir, forcont);
	return zero;
};
