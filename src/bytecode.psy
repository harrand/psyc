bc_arena : arena mut& mut;

bcdata_type ::= enum
{
	.literal := 1;
	.ptr := 2;
};

bcdata ::= struct
{
	type : bcdata_type;
	literal : sval_literal;
};

bc_type ::= enum
{
	.builtin := 0;
};

bc ::= struct
{
	type : bc_type;
};

bc_fragment ::= struct
{
	code : bc mut&;
	code_size : u64;
	code_cap : u64;

	data : bcdata mut&;
	data_size : u64;
	data_cap : u64;
};

frag_new_data ::= func(frag : bc_fragment mut&, data : bcdata) -> u64
{
	ret ::= frag->data_size;
	if((frag->data_cap) == 0)
	{
		(frag->data_cap) = 1024;
		(frag->data) = arena_push(bc_arena, __sizeof(deref (frag->data)) * (frag->data_cap));
	}
	while((frag->data_size) >= (frag->data_cap))
	{
		oldcode ::= frag->data;
		oldcap ::= frag->data_cap;
		(frag->data_cap) = (frag->data_cap) * 2;
		(frag->data) = arena_push(bc_arena, __sizeof(deref (frag->data)) * (frag->data_cap));
		__memcpy(frag->data, oldcode, __sizeof(deref (frag->data)) * oldcap);
	}

	deref((frag->data) at ret) = data;
	(frag->data_size) = (frag->data_size) + 1;
	return ret;
};

frag_add_code ::= func(frag : bc_fragment mut&, code : bc) -> v0
{
	if((frag->code) == null)
	{
		(frag->code_cap) = 1024;
		(frag->code) = arena_push(bc_arena, __sizeof(deref(frag->code)) * (frag->code_cap));
	}
	while((frag->code_size) >= (frag->code_cap))
	{
		oldcap ::= frag->code_cap;
		oldcode ::= frag->code;
		(frag->code_cap) = (frag->code_cap) * 2;
		(frag->code) = arena_push(bc_arena, __sizeof(deref(frag->code)) * (frag->code_cap));
		__memcpy(frag->code, oldcode, __sizeof(deref(frag->code)) * oldcap);
	}
	deref((frag->code) at (frag->code_size)) = code;
	(frag->code_size) = (frag->code_size) * 2;
};

bytecode_setup ::= func(a : arena mut&) -> v0
{
	bc_arena = a;
};

== build ==
{
	add_source_file("stdlib/arena.psy");
	add_source_file("sval.psy");
}
