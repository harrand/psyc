bc_arena : arena mut& mut;

bc_type ::= enum
{
	.store := 1; // d0 = dst addr, v1 = store value
	.copy := 2; // d0 = dst addr, d1 = src addr
	.load := 2; // d0 = address
};

bc ::= struct
{
	type : bc_type;
	d0 : u64;
	d1 : u64;
	d2 : u64;
	v0 : sval;
};

bc_fragment ::= struct
{
	code : bc mut&;
	code_size : u64;
	code_cap : u64;

	data : sval mut&;
	data_size : u64;
	data_cap : u64;
};

bc_store ::= func(dst_addr : u64, store_val : sval) -> bc
{
	return bc
	{
		.type := bc_type.store;
		.d0 := dst_addr;
		.v0 := store_val;
	};
};

frag_new_data ::= func(frag : bc_fragment mut&, data : sval) -> u64
{
	ret ::= frag->data_size;
	if((frag->data_cap) == 0)
	{
		(frag->data_cap) = 1024;
		(frag->data) = arena_push(bc_arena, __sizeof(deref (frag->data)) * (frag->data_cap));
	}
	while((frag->data_size) >= (frag->data_cap))
	{
		oldcode ::= frag->data;
		oldcap ::= frag->data_cap;
		(frag->data_cap) = (frag->data_cap) * 2;
		(frag->data) = arena_push(bc_arena, __sizeof(deref (frag->data)) * (frag->data_cap));
		__memcpy(frag->data, oldcode, __sizeof(deref (frag->data)) * oldcap);
	}

	deref((frag->data) at ret) = data;
	(frag->data_size) = (frag->data_size) + 1;
	return ret;
};

frag_add_code ::= func(frag : bc_fragment mut&, code : bc) -> v0
{
	if((frag->code) == null)
	{
		(frag->code_cap) = 1024;
		(frag->code) = arena_push(bc_arena, __sizeof(deref(frag->code)) * (frag->code_cap));
	}
	while((frag->code_size) >= (frag->code_cap))
	{
		oldcap ::= frag->code_cap;
		oldcode ::= frag->code;
		(frag->code_cap) = (frag->code_cap) * 2;
		(frag->code) = arena_push(bc_arena, __sizeof(deref(frag->code)) * (frag->code_cap));
		__memcpy(frag->code, oldcode, __sizeof(deref(frag->code)) * oldcap);
	}
	deref((frag->code) at (frag->code_size)) = code;
	(frag->code_size) = (frag->code_size) * 2;
};

bytecode_setup ::= func(a : arena mut&) -> v0
{
	bc_arena = a;
};

== build ==
{
	add_source_file("stdlib/arena.psy");
	add_source_file("sval.psy");
}
