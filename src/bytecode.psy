bytecode_type ::= enum
{
	.builtin := 0;
};

bytecode ::= struct
{
	type : bytecode_type;
};

bytecode_fragment ::= struct
{
	data : bytecode mut&;
	data_size : u64;
	data_cap : u64;
};

frag_add_code ::= func(frag : bytecode_fragment mut&, code : bytecode, a : arena mut&) -> v0
{
	if((frag->data) == null)
	{
		(frag->data_cap) = 1024;
		(frag->data) = arena_push(a, __sizeof(deref(frag->data)) * (frag->data_cap));
	}
	while((frag->data_size) >= (frag->data_cap))
	{
		oldcap ::= frag->data_cap;
		olddata ::= frag->data;
		(frag->data_cap) = (frag->data_cap) * 2;
		(frag->data) = arena_push(a, __sizeof(deref(frag->data)) * (frag->data_cap));
		__memcpy(frag->data, olddata, __sizeof(deref(frag->data)) * oldcap);
	}
	deref((frag->data) at (frag->data_size)) = code;
	(frag->data_size) = (frag->data_size) * 2;
};

== build ==
{
	add_source_file("stdlib/arena.psy");
}
