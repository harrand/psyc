di_cu : u64 mut := zero;

dbg_setup ::= func(-> v0)
{
	prog.db = LLVMCreateDIBuilder(prog.cg);
	dirname_len : u64 weak mut;
	dirname : u8 mut? mut;
	directory_get_cwd(ref dirname, ref dirname_len, global_arena);

	di_buildfile ::= LLVMDIBuilderCreateFile(prog.db, prog.compile_args.build_file, zstrlen(prog.compile_args.build_file), dirname, dirname_len - 1);
	LLVM_DWARF_SRC_LANG_C ::= 1;
	producer_str ::= "Psyc";
	is_optimized ::= prog.optimization != (program_optimization.o0);
	LLVMDWARFEmissionNone ::= 0;
	LLVMDWARFEmissionFull ::= 1;
	emission : s32 weak mut := LLVMDWARFEmissionNone;
	if(prog.debug_symbols)
	{
		emission = LLVMDWARFEmissionFull;
	}
	di_cu = LLVMDIBuilderCreateCompileUnit(prog.db, LLVM_DWARF_SRC_LANG_C, di_buildfile, producer_str, zstrlen(producer_str), is_optimized@s32, zero, zero, zero, zero, zero, emission, zero, true@s32, false@s32, zero, zero, zero, zero);
	program_scope()->db = di_cu;
};

dbg_create_file ::= func(scope : lexical_scope mut? -> v0)
{
	dirname_len : u64 weak mut;
	dirname : u8 mut? mut;
	directory_get_cwd(ref dirname, ref dirname_len, global_arena);
	scope->db = LLVMDIBuilderCreateFile(prog.db, scope->name, scope->name_len, dirname, dirname_len - 1);	
};

dbg_end ::= func(-> v0)
{
	if(!(prog.debug_symbols))
	{
		return;
	}
	static if(_win32)
	{
		dbg_setup_codeview();
	}
	LLVMDIBuilderFinalize(prog.db);
};

dbg_setup_codeview ::= func(-> v0)
{
	val_metadata ::= LLVMValueAsMetadata(LLVMConstInt(LLVMInt32Type(), 1, true@s32));
	codeview_str ::= "CodeView";
	LLVMAddModuleFlag(prog.cg, 0, codeview_str, zstrlen(codeview_str), val_metadata);
};

dbg_declare_struct ::= func(type : tyid -> v0)
{
	dlayout ::= LLVMGetModuleDataLayout(prog.cg);
	t ::= ty_unwrap(type);
	s ::= ref(t->strct);
	defined_at ::= s->node;
	file_scope ::= program_find_file_scope(defined_at->loc.file, zstrlen(defined_at->loc.file));
	// if one of the members is a pointer of pointee type the same struct
	// then with normal logic we recurse forever
	// if we detect one of the member pointees is ourselves we will populate recursive component and use that
	recursive_component : u64 mut := 0;

	db_mems : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (s->members_count));
	i : u64 mut;
	for(i = 0, i < (s->members_count), i = i + 1)
	{
		memty ::= deref(s->members # i);
		is_recursive_pointee : bool mut := false;
		if(ty_is_ptr(memty))
		{
			if(ty_matches_ignore_quals(ty_underlying(memty), type))
			{
				is_recursive_pointee = true;
			}
		}
		if(is_recursive_pointee)
		{
			// ah make a recursive version of ourselves
			if(recursive_component == zero)
			{
				DW_TAG_structure_type ::= 0x13;
				recursive_component = LLVMDIBuilderCreateReplaceableCompositeType(prog.db, DW_TAG_structure_type, t->name, t->name_len, file_scope->db, file_scope->db, defined_at->loc.line@_, zero, total_size * 8, total_align * 8, zero, t->name, t->name_len);
			}
			deref(db_mems # i) = recursive_component;
		}
		else
		{
			cg ::= cg_type(memty, true);
			di ::= db_type(memty, true);
			offset ::= LLVMOffsetOfElement(dlayout, s->cg, i@_);
			size ::= LLVMABISizeOfType(dlayout, cg);
			align ::= LLVMABIAlignmentOfType(dlayout, cg);
			deref(db_mems # i) = LLVMDIBuilderCreateMemberType(prog.db, file_scope->db, deref(s->member_names # i), deref(s->member_name_lens # i), file_scope->db, defined_at->loc.line@_, size * 8, align * 8, offset * 8, zero, di);
		}
	}
	total_size ::= LLVMABISizeOfType(dlayout, cg_type(type, true));
	total_align ::= LLVMABIAlignmentOfType(dlayout, cg_type(type, true));
	s->db = LLVMDIBuilderCreateStructType(prog.db, file_scope->db, t->name, t->name_len, file_scope->db, defined_at->loc.line@_, total_size * 8, total_align * 8, zero, zero, db_mems, s->members_count@_, zero, zero, t->name, t->name_len);
	if(recursive_component != zero)
	{
		// do the replacement
		//LLVMDIBuilderReplaceTemporary(prog.db, recursive_component, s->db);
		LLVMMetadataReplaceAllUsesWith(recursive_component, s->db);
	}
};

dbg_declare_enum ::= func(type : tyid -> v0)
{
	dlayout ::= LLVMGetModuleDataLayout(prog.cg);
	t ::= ty_unwrap(type);
	e ::= ref(t->enm);
	defined_at ::= e->node;
	file_scope ::= program_find_file_scope(defined_at->loc.file, zstrlen(defined_at->loc.file));

	db_entries : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (e->entries_count));
	i : u64 mut;
	for(i = 0, i < (e->entries_count), i = i + 1)
	{
		entry_intval ::= deref(e->entries # i);
		deref(db_entries # i) = LLVMDIBuilderCreateEnumerator(prog.db, deref(e->entry_names # i), deref(e->entry_name_lens # i), entry_intval@_, false@s32);
	}
	size ::= LLVMABISizeOfType(dlayout, cg_type(type, true));
	align ::= LLVMABIAlignmentOfType(dlayout, cg_type(type, true));
	
	e->db = LLVMDIBuilderCreateEnumerationType(prog.db, file_scope->db, t->name, t->name_len, file_scope->db, defined_at->loc.line@_, size * 8, align * 8, db_entries, e->entries_count@_, db_type(tyid.s64, true));
};

dbg_declare_function ::= func(fn : function mut? -> v0)
{
	if(!(prog.debug_symbols))
	{
		return;
	}
	// todo: set fn->db and fn->scope->db
	funcscope ::= (fn->scope)@lexical_scope mut?;
	filescope ::= scope_get_parent_filescope(funcscope);
	
	dity ::= db_type(fn->type, false);
	fn->db = LLVMDIBuilderCreateFunction(prog.db, filescope->db, fn->name, fn->name_len, fn->name, fn->name_len, filescope->db, fn->node->loc.line@_, dity, false@s32, true@s32, fn->node->loc.column@_, 256, false@s32);
	LLVMSetSubprogram(fn->cg, fn->db);
	funcscope->db = (fn->db);
	dbg_action(fn->node, funcscope);
};

dbg_declare_local_variable ::= func(var : variable mut?, fn : function mut? -> v0)
{
	if(!(prog.debug_symbols))
	{
		return;
	}
	
	loc ::= var->node->loc;

	fnscope ::= (fn->scope)@lexical_scope mut?;
	parent_file ::= scope_get_parent_filescope(fnscope);
	divar ::= LLVMDIBuilderCreateAutoVariable(prog.db, fnscope->db, var->node->decl.name, var->node->decl.name_len, parent_file->db, loc.line@_, db_type(var->type, true), false@s32, zero, zero);
	expr ::= LLVMDIBuilderCreateExpression(prog.db, zero, zero);
	dloc ::= LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), loc.line@_, loc.column@_, fnscope->db, zero);
	if(ty_has_qual(var->type, tyqual.qual_static))
	{
		// constexpr
		LLVMDIBuilderInsertDbgValueAtEnd(prog.db, val_dynamic(var->compile_time_storage, fnscope, var->node).runtime.cg, divar, expr, dloc, LLVMGetInsertBlock(ir));
	}
	else
	{
		// actual variable
		LLVMDIBuilderInsertDeclareAtEnd(prog.db, var->cg, divar, expr, dloc, LLVMGetInsertBlock(ir));
	}
};

dbg_declare_global_variable ::= func(var : variable mut? -> v0)
{
	defined_at ::= var->node;
	scope : lexical_scope mut? mut := zero;
	if(defined_at->loc.file != zero)
	{
		scope = program_find_file_scope(defined_at->loc.file, zstrlen(defined_at->loc.file));
	}
	else
	{
		// cant be traced to a source location. just gonna go ahead and ignore it then.
		return;
	}
	decl ::= defined_at->decl;
	loc ::= defined_at->loc;
	expr ::= LLVMDIBuilderCreateExpression(prog.db, zero, zero);
	dloc ::= LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), loc.line@_, loc.column@_, scope->db, zero);

	divar ::= LLVMDIBuilderCreateGlobalVariableExpression(prog.db, scope->db, decl.name, decl.name_len, decl.name, decl.name_len, scope->db, loc.line@_, db_type(var->type, true), false@s32, expr, zero, zero);
	if(ty_has_qual(var->type, tyqual.qual_static))
	{
		// todo: need to find a basicblock to put this into
		// because its uhhh global this doest really make any sense
		// so for now static globals arent visible :(((
		//LLVMDIBuilderInsertDbgValueAtEnd(prog.db, val_dynamic(var->compile_time_storage, scope, var->node).runtime.cg, divar, expr, dloc, LLVMGetInsertBlock(ir));
	}
	else
	{
		LLVMGlobalSetMetadata(var->cg, LLVMGetMDKindID("dbg", 3), divar);
	}
};

dbg_declare_function_param ::= func(var : variable mut?, fn : function mut?, idx : u64 -> v0)
{
	if(!(prog.debug_symbols))
	{
		return;
	}

	scope ::= fn->scope@lexical_scope mut?;
	parent_file ::= scope_get_parent_filescope(scope);
	loc ::= ast_get_child(fn->node, 1 + idx)->loc;
	divar ::= LLVMDIBuilderCreateParameterVariable(prog.db, scope->db, var->node->decl.name, var->node->decl.name_len, idx@_, parent_file->db, loc.line@_, db_type(var->type, true), zero, zero);
	LLVMDIBuilderInsertDeclareAtEnd(prog.db, var->cg, divar, LLVMDIBuilderCreateExpression(prog.db, zero, zero), LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), loc.line@_, loc.column@_, scope->db, zero), scope->cg);
};

db_type ::= func(type : tyid, should_ref_function_type : bool -> u64)
{
	u ::= ty_unwrap(type);
	// make the full name. argh.

	namelen : u64 mut := u->name_len;
	if(ty_has_qual(type, tyqual.qual_mut))
	{
		namelen = (namelen + zstrlen(qual_str_mut));
	}
	if(ty_has_qual(type, tyqual.qual_weak))
	{
		namelen = (namelen + zstrlen(qual_str_weak));
	}
	if(ty_has_qual(type, tyqual.qual_static))
	{
		namelen = (namelen + zstrlen(qual_str_static));
	}
	namebuf : u8 mut? := arena_alloc(string_arena, namelen);
	memcopy(namebuf, u->name, u->name_len);
	name_offset : u64 mut := u->name_len;
	
	if(ty_has_qual(type, tyqual.qual_mut))
	{
		memcopy(namebuf # name_offset, qual_str_mut, zstrlen(qual_str_mut));
		name_offset = (name_offset + zstrlen(qual_str_mut));
	}
	if(ty_has_qual(type, tyqual.qual_weak))
	{
		memcopy(namebuf # name_offset, qual_str_weak, zstrlen(qual_str_weak));
		name_offset = (name_offset + zstrlen(qual_str_weak));
	}
	if(ty_has_qual(type, tyqual.qual_static))
	{
		memcopy(namebuf # name_offset, qual_str_static, zstrlen(qual_str_static));
		name_offset = (name_offset + zstrlen(qual_str_static));
	}

	if(ty_matches_ignore_quals(type, tyid.v0))
	{
		return LLVMDIBuilderCreateBasicType(prog.db, namebuf, namelen, 8, DW_ATE_unsigned, zero);
	}
	integral_size ::= ty_integral_size(type);
	integral_signed ::= ty_is_signed_integral(type);
	floating_size ::= ty_floating_point_size(type);
	size : u64 mut weak := val_must_get_integer(cg_sizeof(type), zero, zero);
	align ::= val_must_get_integer(cg_alignof(type), zero, zero);

	dw_ate : s32 mut := 0;

	if(ty_is_prim(type))
	{
		if(integral_size > 0)
		{
			if(integral_signed)
			{
				if(integral_size == 8)
				{
					dw_ate = DW_ATE_signed_char;
				}
				else
				{
					dw_ate = DW_ATE_signed;
				}
			}
			else
			{
				if(integral_size == 8)
				{
					dw_ate = DW_ATE_unsigned_char;
				}
				else
				{
					dw_ate = DW_ATE_unsigned;
				}
			}
		}
		if(ty_is_bool(type))
		{
			dw_ate = DW_ATE_boolean;
		}
		if(ty_matches_ignore_quals(type, tyid.v0))
		{
			dw_ate = DW_ATE_unsigned;
			size = 8;
		}
		return LLVMDIBuilderCreateBasicType(prog.db, namebuf, namelen, size * 8, dw_ate, zero);
	}
	if(ty_is_ptr(type))
	{
		return LLVMDIBuilderCreatePointerType(prog.db, db_type(ty_underlying(type), should_ref_function_type), 64, 64, zero, zero, zero);
	}
	if(ty_is_fn(type))
	{
		paramdata : u64 mut? := arena_alloc(global_arena, __sizeof(u64) * (u->fn.params_count + 1));
		deref(paramdata # 0) = db_type(u->fn.return_type, true);
		i : u64 mut;
		for(i = 0, i < (u->fn.params_count), i = i + 1)
		{
			deref(paramdata # (1 + i)) = db_type(deref(u->fn.param_types # i), true);
		}
		db_fnty ::= LLVMDIBuilderCreateSubroutineType(prog.db, program_scope()->db, paramdata, u->fn.params_count + 1, zero);
		if(should_ref_function_type)
		{
		return LLVMDIBuilderCreatePointerType(prog.db, db_fnty, 64, 64, zero, zero, zero);
		}
		return db_fnty;
	}
	if(ty_is_struct(type))
	{
		if(u->strct.db == zero)
		{
			dbg_declare_struct(type);
		}
		return u->strct.db;
	}
	if(ty_is_enum(type))
	{
		if(u->enm.db == zero)
		{
			dbg_declare_enum(type);
		}
		return u->enm.db;
	}
	return zero;
};

dbg_inaction ::= func(-> v0)
{
	LLVMSetCurrentDebugLocation2(ir, zero);
};

dbg_action ::= func(node : ast?, scope : lexical_scope mut? -> v0)
{
	if(!(prog.debug_symbols))
	{
		return;
	}
	// assume we are file scope or function scope
	// either way ->db is perfectly fine to use
	// program scope not so much...
	loc ::= LLVMDIBuilderCreateDebugLocation(LLVMGetGlobalContext(), node->loc.line@_, node->loc.column@_, scope->db, zero);
	LLVMSetCurrentDebugLocation2(ir, loc);
};
