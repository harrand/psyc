tyqual : enum
{
	// msb set
	.qual_static := 0x8000000000000000;
	// msb-1 set
	.qual_mut := 0x4000000000000000;
	// msb-2 set
	.qual_weak := 0x2000000000000000;
};

tytag : enum
{
	.prim := 1;
	.ptr := 2;
	.arr := 3;
	.enm := 4;
	.strct := 5;
	.fn := 6;
};

enumty : struct
{
	entries : u64 mut?;
	entry_names : u8? mut?;
	entry_name_lens : u64 mut?;
	entries_count : u64;
	node : ast?;
	cg : u64;
	db : u64;
};

structty : struct
{
	members : tyid mut?;
	member_names : u8? mut?;
	member_name_lens : u64 mut?;
	members_count : u64;
	node : ast?;
	cg : u64;
	db : u64;
};

fnty : struct
{
	return_type : tyid;
	param_types : tyid mut?;
	params_count : u64;
};

ty : struct
{
	tag : tytag;
	name : u8?;
	name_len : u64;

	// if pointer: underlying. if base, id into corresponding tybox
	base : tyid;
	array_len : u64;
	strct : structty;
	enm : enumty;
	fn : fnty;
};

// this tyid enum is the magic behind it all. here you only see the primitive types.
// however anytime a tybox registers a new e.g struct/enum type they will get their
// own tyid entry dedicated to them. also pointers/arrays of stuff will also have
// their own tyid. this might seem wasteful but is necessary. type qualifiers though
// are implemented as bitflags on the top 3 most significant bits of a tyid. so for
// example. tyid.v0 is 'v0' with no quals. if this tyid had the top 3 bits set, it
// would instead be a 'v0 mut weak static'. this means that *every* single type you
// could think of has its own tyid. it also makes the type system pretty flat w.r.t
// memory.
tyid : enum
{
	.v0 := 1;
	.s64 := 2;
	.s32 := 3;
	.s16 := 4;
	.s8 := 5;
	.u64 := 6;
	.u32 := 7;
	.u16 := 8;
	.u8 := 9;
	.bool := 10;
	.f64 := 11;
	.f32 := 12;
	.custom := 13;
};

tyid_auto : func(-> tyid)
{
	return -1@tyid;
};

// integer literals e.g '5' will have this exact type
tyid_integral_literal : func(-> tyid)
{
	return ty_set_qual(tyid.s64, tyqual.qual_weak | tyqual.qual_static);
};

// float literals e.g '6.9' will have this exact type
tyid_floating_point_literal : func(-> tyid)
{
	return ty_set_qual(tyid.f64, tyqual.qual_weak | tyqual.qual_static);
};

// char literals e.g ''f'' will have this exact type
tyid_char_literal : func(-> tyid)
{
	return ty_set_qual(tyid.u8, tyqual.qual_weak | tyqual.qual_static);
};

// string literals e.g "foo" will have this exact type
tyid_string_literal : func(-> tyid)
{
	return ty_ptr(ty_set_qual(tyid.u8, tyqual.qual_static), tyqual.qual_static | tyqual.qual_weak);
};

// bool literals i.e true/false will have this exact type
tyid_bool_literal : func(-> tyid)
{
	return ty_set_qual(tyid.bool, tyqual.qual_static);
};

ty_is_bad : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == zero;
};

ty_is_char : func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return
		(idpure == (tyid.u8));
};

ty_is_string_literal : func(id : tyid -> bool)
{
	return id == tyid_string_literal();
};

ty_is_prim : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.prim);
};

ty_is_enum : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.enm);
};

ty_is_struct : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.strct);
};

ty_is_ptr : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.ptr);
};

ty_is_arr : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.arr);
};

ty_is_fn : func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.fn);
};

ty_underlying : func(id : tyid -> tyid)
{
	return ty_unwrap(id)->base;
};

ty_get_enum_entry_id : func(id : tyid, name : u8?, name_len : u64 -> u64)
{
	i : u64 mut;
	if(ty_is_enum(id))
	{
		enm ::= ty_unwrap(id)->enm;
		for(i = 0; i < (enm.entries_count); i = i + 1)
		{
			entname ::= [enm.entry_names # i];
			entname_len ::= [enm.entry_name_lens # i];
			if(entname_len == name_len)
			{
				if(streql_n(entname, name, name_len))
				{
					return i;
				}
			}
		}
	}
	return -1;
};

ty_get_struct_member_id : func(id : tyid, name : u8?, name_len : u64 -> u64)
{
	i : u64 mut;
	if(ty_is_struct(id))
	{
		strct ::= ty_unwrap(id)->strct;
		for(i = 0; i < (strct.members_count); i = i + 1)
		{
			memname ::= [strct.member_names # i];
			memlen ::= [strct.member_name_lens # i];
			if(memlen == name_len)	
			{
				if(streql_n(memname, name, memlen))
				{
					return i;
				}
			}
		}
	}
	return -1;
};

// integral size in bits. zero if not integral.
ty_integral_size : func(id : tyid -> u64)
{
	idpure ::= ty_clear_all_quals(id);
	if((idpure == (tyid.s64)) || (idpure == (tyid.u64)))
	{
		return 64;
	}
	if((idpure == (tyid.s32)) || (idpure == (tyid.u32)))
	{
		return 32;
	}
	if((idpure == (tyid.s16)) || (idpure == (tyid.u16)))
	{
		return 16;
	}
	if((idpure == (tyid.s8)) || (idpure == (tyid.u8)))
	{
		return 8;
	}
	return zero;
};

ty_is_signed_integral : func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return
		(idpure == (tyid.s64)) ||
		(idpure == (tyid.s32)) ||
		(idpure == (tyid.s16)) ||
		(idpure == (tyid.s8));
};

ty_is_unsigned_integral : func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return
		(idpure == (tyid.u64)) ||
		(idpure == (tyid.u32)) ||
		(idpure == (tyid.u16)) ||
		(idpure == (tyid.u8));
};

// is the given type any form of integer?
ty_is_integral : func(id : tyid -> bool)
{
	return ty_integral_size(id) > 0;
};

ty_floating_point_size : func(id : tyid -> u64)
{
	idpure ::= ty_clear_all_quals(id);
	if(idpure == (tyid.f64))
	{
		return 64;
	}
	if(idpure == (tyid.f32))
	{
		return 32;
	}
	return 0;
};

// is the given type any form of floating point?
ty_is_floating_point : func(id : tyid -> bool)
{
	return ty_floating_point_size(id) > 0;
};

// is the given type any form of bool?
ty_is_bool : func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return (idpure == (tyid.bool));
};

// is the given type a void type
ty_is_v0 : func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return (idpure == (tyid.v0));
};

ty_get_qual : func(id : tyid -> tyqual)
{
	ret : tyqual mut := zero;
	if(ty_has_qual(id, tyqual.qual_mut))
	{
		ret = (ret | (tyqual.qual_mut));
	}
	if(ty_has_qual(id, tyqual.qual_static))
	{
		ret = (ret | (tyqual.qual_static));
	}
	if(ty_has_qual(id, tyqual.qual_weak))
	{
		ret = (ret | (tyqual.qual_weak));
	}
	return ret;
};

// returns whether the type has the given qualifier(s)
ty_has_qual : func(id : tyid, qual : tyqual -> bool)
{
	return ((id@s64) & (qual@s64)) != 0;
};

// returns the input type but with the given qualifier(s)
ty_set_qual : func(id : tyid, qual : tyqual -> tyid)
{
	return ((id@s64) | (qual@s64))@tyid;
};

// returns the input type but without the given qualifier(s)
ty_clear_qual : func(id : tyid, qual : tyqual -> tyid)
{
    return ((id@s64) & ~(qual@s64))@tyid;
};

// returns the input type but without any qualifiers.
ty_clear_all_quals : func(id : tyid -> tyid)
{
	all_but_top_3_msb ::= 0x1FFFFFFFFFFFFFFF;
	return (id@s64 & all_but_top_3_msb)@tyid;
};

// adds staticness recursively to a type
// removes mutness but preserves weakness
// i.e ty_staticify(u64 mut? weak) => u64 static? static weak
ty_staticify : func(id : tyid -> tyid)
{
	if(id == tyid_auto())
	{
		return id;
	}
	q ::= ty_get_qual(id) | (tyqual.qual_static);
	un ::= ty_unwrap(id);
	if(ty_is_ptr(id))
	{
		// need to do the underlying bit too...
		ptr_u ::= ty_staticify(ty_underlying(id));
		return ty_ptr(ptr_u, q);
	}
	if(ty_is_arr(id))
	{
		arr_u ::= ty_staticify(ty_underlying(id));
		return ty_arr(arr_u, un->array_len, q);
	}
	if(ty_is_fn(id))
	{
		params_cpy : tyid mut? := arena_alloc(global_arena, un->fn.params_count * sizeof typeof(tyid));
		i : u64 mut;
		for(i = 0; i < (un->fn.params_count); i = i + 1)
		{
			[params_cpy # i] = ty_staticify([un->fn.param_types # i]);
		}
		return_type ::= ty_staticify(un->fn.return_type);
		// dont pass q as quals here as function types really shouldnt have static (or at least youre free to change your mind in the future if youre doing static functions and it makes sense now)
		return ty_fn(return_type, params_cpy, un->fn.params_count, ty_get_qual(id));
	}

	// otherwise its prims structs and enums which is easy
	return ty_set_qual(id, tyqual.qual_static);
};

// removes staticness recursively from a type.
// preserves mutness and weakness
// i.e ty_unstaticify(u64 static? static weak) => u64? weak
ty_unstaticify : func(id : tyid -> tyid)
{
	if(id == tyid_auto())
	{
		return id;
	}
	q ::= (ty_get_qual(id)@s64 & ~(tyqual.qual_static@s64))@tyqual;
	un ::= ty_unwrap(id);
	if(ty_is_ptr(id))
	{
		// need to do the underlying bit too...
		ptr_u ::= ty_unstaticify(ty_underlying(id));
		return ty_ptr(ptr_u, q);
	}
	if(ty_is_arr(id))
	{
		arr_u ::= ty_unstaticify(ty_underlying(id));
		return ty_arr(arr_u, un->array_len, q);
	}
	if(ty_is_fn(id))
	{
		params_cpy : tyid mut? := arena_alloc(global_arena, un->fn.params_count * sizeof typeof(tyid));
		i : u64 mut;
		for(i = 0; i < (un->fn.params_count); i = i + 1)
		{
			[params_cpy # i] = ty_unstaticify([un->fn.param_types # i]);
		}
		return_type ::= ty_unstaticify(un->fn.return_type);
		// dont pass q as quals here as function types really shouldnt have static (or at least youre free to change your mind in the future if youre doing static functions and it makes sense now)
		return ty_fn(return_type, params_cpy, un->fn.params_count, ty_get_qual(id));
	}

	// otherwise its prims structs and enums which is easy
	return ty_clear_qual(id, tyqual.qual_static);
};

quals_max_strlen ::= 7 * 3;
qual_str_mut ::= " mut";
qual_str_weak ::= " weak";
qual_str_static ::= " static";

// print out the name of a type.
putty : func(id : tyid -> v0)
{
	if(id == tyid_auto())
	{
		putzstr("auto");
		return;
	}
	is_mut ::= ty_has_qual(id, tyqual.qual_mut);
	is_weak ::= ty_has_qual(id, tyqual.qual_weak);
	is_static ::= ty_has_qual(id, tyqual.qual_static);
	tydata ::= tybox_at(ref(prog.types), ty_clear_all_quals(id));
	putbytes(tydata->name, tydata->name_len);
	if(is_mut)
	{
		putzstr(qual_str_mut);
	}
	if(is_weak)
	{
		putzstr(qual_str_weak);
	}
	if(is_static)
	{
		putzstr(qual_str_static);
	}
};

// returns whether the lhs and rhs types are the same (ignoring qualifiers)
ty_matches_ignore_quals : func(lhs : tyid, rhs : tyid -> bool)
{
	return ty_clear_all_quals(lhs) == ty_clear_all_quals(rhs);
};

ty_contains_ignore_quals : func(lhs : tyid, rhs : tyid -> bool)
{
	if(ty_matches_ignore_quals(lhs, rhs))
	{
		return true;
	}
	if(ty_is_arr(lhs))
	{
		return ty_contains_ignore_quals(ty_underlying(lhs), rhs);
	}
	if(ty_is_struct(lhs))
	{
		i : u64 mut;
		s ::= ty_unwrap(lhs)->strct;
		for(i = 0; i < (s.members_count); i = i + 1)
		{
			memty ::= [s.members # i];
			if(ty_contains_ignore_quals(memty, rhs))
			{
				return true;
			}
		}
	}
	return false;
};

ty_find_by_name : func(name : u8?, name_len : u64 -> tyid)
{
	return tybox_find(ref(prog.types), name, name_len);
};

// high-level function to convert type data to a tyid (including quals).
// assume that if this type data has not been seen before it will be dynamically added to a huge type table.
ty_wrap : func(type : ty, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add(ref(prog.types), type), quals);
};

// high-level function to retrieve the data corresponding to a type.
ty_unwrap : func(id : tyid -> ty mut?)
{
	if(id == tyid_auto())
	{
		return tybox_at(ref(prog.types), id);
	}
	return tybox_at(ref(prog.types), ty_clear_all_quals(id));
};

// describes type conversions
tyconv : enum
{
	.yes := 1;
	.yes_needs_convert := 2;
	.no := 3;
	.no_cant_add_staticness := 4;
	.no_but_yes_with_weak := 5;
};

// describe how we convert 'from' -> 'to'
ty_converts_to : func(from : tyid, to : tyid -> tyconv)
{
	if((to == tyid_auto()) || (from == tyid_auto()))
	{
		return tyconv.yes;
	}
	from_is_mut ::= ty_has_qual(from, tyqual.qual_mut);
	from_is_weak ::= ty_has_qual(from, tyqual.qual_weak);
	from_is_static ::= ty_has_qual(from, tyqual.qual_static);
	from_underlying ::= ty_underlying(from);

	to_is_mut ::= ty_has_qual(to, tyqual.qual_mut);
	to_is_weak ::= ty_has_qual(to, tyqual.qual_weak);
	to_is_static ::= ty_has_qual(to, tyqual.qual_static);
	to_underlying ::= ty_underlying(to);

	either_is_weak ::= from_is_weak || to_is_weak;
	if(ty_matches_ignore_quals(from, to))
	{
		// core of the types are the same.
		// mut doesnt matter.
		// static converts to non-static but NOT vice-versa
		// weakness doesnt matter.
		if((!from_is_static) && to_is_static)
		{
			return tyconv.no_cant_add_staticness;
		}
		return tyconv.yes;
	}
	// types dont match
	fromty ::= ty_unwrap(from);
	toty ::= ty_unwrap(to);
	fromprim ::= fromty->base;
	toprim ::= toty->base;
	if(ty_is_prim(from))
	{
		if(ty_is_prim(to))
		{
			// both are prims.
			// integral converts to integral if one is weak
			// floating point converts to floating point if one is weak
			// integral converts to floating point and vice-versa if one is weak
			// bool converts to integral and vice-versa if one is weak
			// or in other words:
			// v0 doesnt convert to/from anything
			// integral converts to/from everything else with weak
			// floating point converts to/from everything else apart from bool with weak
			if(ty_is_v0(fromprim) || ty_is_v0(toprim))
			{
				return tyconv.no;
			}
			if(ty_is_integral(fromprim))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
			if(ty_is_floating_point(fromprim))
			{
				if(ty_is_bool(to))
				{
					return tyconv.no;
				}
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
			if(ty_is_bool(fromprim))
			{
				if(ty_is_integral(to))
				{
					if(either_is_weak)
					{
						return tyconv.yes_needs_convert;
					}
					return tyconv.no_but_yes_with_weak;
				}
			}
		}
		else
		{
			// when can a prim convert to a non-prim?
			// s64 weak converts to enums
			// u64 weak converts to pointers.
			// u64 weak converts to functions.
			// nothing else.
			if(fromprim == (tyid.s64))
			{
				if(toty->tag == (tytag.enm))
				{
					if(either_is_weak)
					{
						return tyconv.yes_needs_convert;
					}
					return tyconv.no_but_yes_with_weak;
				}
			}
			if(fromprim == (tyid.u64))
			{
				if(toty->tag == (tytag.ptr))
				{
					if(either_is_weak)
					{
						return tyconv.yes_needs_convert;
					}
					return tyconv.no_but_yes_with_weak;
				}
				if(toty->tag == (tytag.fn))
				{
					if(either_is_weak)
					{
						return tyconv.yes_needs_convert;
					}
					return tyconv.no_but_yes_with_weak;
				}
			}
			return tyconv.no;
		}
	}
	// lhs is not a prim
	// enums can convert to s64
	if(ty_is_enum(from))
	{
		if(ty_is_prim(to))
		{
			if(toprim == (tyid.s64))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
		}
	}
	// ptrs can convert to u64
	if(ty_is_ptr(from))
	{
		if(ty_is_prim(to))
		{
			if(toprim == (tyid.u64))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
		}
		if(ty_is_ptr(to))
		{
			// p2p
			if((!from_is_static) && to_is_static)
			{
				return tyconv.no_cant_add_staticness;
			}
			// should we use yes_needs_convert?
			// no, because we assume our codegen treats all pointers the same.
			if(either_is_weak)
			{
				return tyconv.yes;
			}
			// ok what if we want to convert u64 mut? to u64?
			// that should be allowed
			// but not the other way around
			if(ty_matches_ignore_quals(from_underlying, to_underlying))
			{
				// underlyings are the same
				// should it be okay to add mutness? i think so.
				// not staticness though
				if((!ty_has_qual(from_underlying, tyqual.qual_static)) && ty_has_qual(to_underlying, tyqual.qual_static))
				{
					return tyconv.no_cant_add_staticness;
				}
				return tyconv.yes;
			}
			return tyconv.no_but_yes_with_weak;
		}
		if(ty_is_fn(to))
		{
			// p2fn
			if((!from_is_static) && to_is_static)
			{
				return tyconv.no_cant_add_staticness;
			}
			// should we use yes_needs_convert?
			// yes
			if(either_is_weak)
			{
				return tyconv.yes_needs_convert;
			}
			return tyconv.no_but_yes_with_weak;
		}
	}
	// ptrs can convert to u64
	if(ty_is_fn(from))
	{
		if(ty_is_prim(to))
		{
			if(toprim == (tyid.u64))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
		}
		if(ty_is_ptr(to))
		{
			// fn2p
			if((!from_is_static) && to_is_static)
			{
				return tyconv.no_cant_add_staticness;
			}
			// should we use yes_needs_convert?
			// yes
			if(either_is_weak)
			{
				return tyconv.yes_needs_convert;
			}
			return tyconv.no_but_yes_with_weak;
		}
		if(ty_is_fn(to))
		{
			// fn2fn
			if((!from_is_static) && to_is_static)
			{
				return tyconv.no_cant_add_staticness;
			}
			// should we use yes_needs_convert?
			// no, because we assume our codegen treats all pointers the same.
			if(either_is_weak)
			{
				return tyconv.yes;
			}
			return tyconv.no_but_yes_with_weak;
		}
	}
	if(ty_is_arr(from))
	{
		if(ty_is_arr(to))
		{
			// arrays but not exactly the same
			// basically same shit as with pointers here...
			if(ty_matches_ignore_quals(from_underlying, to_underlying))
			{
				// underlyings are the same
				// should it be okay to add mutness? i think so.
				// not staticness though
				if((!ty_has_qual(from_underlying, tyqual.qual_static)) && ty_has_qual(to_underlying, tyqual.qual_static))
				{
					return tyconv.no_cant_add_staticness;
				}
				return tyconv.yes;
			}
		}
	}
	return tyconv.no;
};

// make sure from can convert 'from' -> 'to'
// fail with a good error message if the conversion cannot happen
ty_ensure_convertible_to : func(from : tyid, to : tyid, source : ast? -> v0)
{
	conv ::= ty_converts_to(from, to);
	if((conv == (tyconv.yes)) || (conv == (tyconv.yes_needs_convert)))
	{
		// epic!
		if(ty_is_ptr(from) && ty_is_ptr(to))
		{
			from_underlying ::= ty_underlying(from);
			to_underlying ::= ty_underlying(to);
			//if(!ty_has_qual(from_underlying, tyqual.qual_mut) && ty_has_qual(to_underlying, tyqual.qual_mut))
			//{
			//	psyc_warning_begin(source->loc);
			//	putzstr("cast from ");
			//	putchar('"');
			//	putty(from);
			//	putchar('"');
			//	putzstr(" to ");
			//	putchar('"');
			//	putty(to);
			//	putchar('"');
			//	putzstr(" adds mutability");
			//	putchar(10);
			//	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.yellow);
			//	psyc_diag_end();
			//}
		}
		return;
	}
	if(conv == (tyconv.no))
	{
		psyc_error_begin(source->loc);
		putzstr("type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" is not convertible to a ");
		putchar('"');
		putty(to);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(conv == (tyconv.no_but_yes_with_weak))
	{
		psyc_error_begin(source->loc);
		putzstr("type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" is not convertible to a ");
		putchar('"');
		putty(to);
		putchar('"');
		putzstr(" (but it would work with a cast!)");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(conv == (tyconv.no_cant_add_staticness))
	{
		psyc_error_begin(source->loc);
		putzstr("type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" is not convertible to a ");
		putchar('"');
		putty(to);
		putchar('"');
		putzstr(" because doing so would add staticness");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	psyc_panic_begin(source->loc);
	putzstr("ty_converts_to(");
	putchar('"');
	putty(from);
	putchar('"');
	putzstr(", ");
	putchar('"');
	putty(to);
	putchar('"');
	putzstr(") yielded ");
	putzstr(enumname(conv));
	putzstr(" (");
	putsint(conv@s64);
	putzstr("). this is a compiler bug.");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
};

// return a pointer to the given type, along with qualifiers
ty_ptr : func(id : tyid, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add_ptr(ref(prog.types), id), quals);
};

ty_arr : func(id : tyid, len : u64, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add_array(ref(prog.types), id, len), quals);
};

ty_fn : func(ret_id : tyid, param_ids : tyid?, params_count : u64, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add_function(ref(prog.types), ret_id, param_ids, params_count), quals);
};

ty_makefn0 : func(ret : tyid -> tyid)
{
	return ty_fn(ret, zero, 0, zero);
};

ty_makefn1 : func(param1 : tyid, ret : tyid -> tyid)
{
	params : tyid mut? := arena_alloc(global_arena, sizeof typeof(tyid) * 1);
	[params # 0] = param1;
	return ty_fn(ret, params, 1, zero);
};

ty_typename_node : func(node : ast?, scope : lexical_scope? -> tyid)
{
	// very specifically only for nodes of ast_tag.typename;
	typename ::= node->typename;
	retty : tyid mut;
	if(typename.descriptor == (ast_typename_descriptor.base))
	{
		retty = ty_find_by_name(typename.basename, typename.basename_len);
		if(retty == zero)
		{
			psyc_error_begin(node->loc);
			putzstr("unknown typename ");
			putchar('"');
			putbytes(typename.basename, typename.basename_len);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		return ty_set_qual(retty, typename.quals);
	}
	if(typename.descriptor == (ast_typename_descriptor.array))
	{
		arrlen_node ::= ast_get_child(node, 1);
		arrlen_val ::= val_node(arrlen_node, scope, val_resolution.compile_time_only);
		arrlen ::= val_must_get_integer(arrlen_val, scope, arrlen_node);
		return ty_arr(ty_typename_node(ast_get_child(node, 0), scope), arrlen@u64, typename.quals);
	}
	if(typename.descriptor == (ast_typename_descriptor.pointer))
	{
		return ty_ptr(ty_typename_node(ast_get_child(node, 0), scope), typename.quals);
	}
	if(typename.descriptor == (ast_typename_descriptor.function))
	{
		// param nodes are 0-(n-1)
		// ret node is n-1
		retty_typename_node ::= ast_get_child(node, node->children_count - 1);
		retty = ty_typename_node(retty_typename_node, scope);
		params_count ::= node->children_count - 1;
		fn_params : tyid mut? := arena_alloc(global_arena, sizeof typeof(tyid) * params_count);
		i : u64 mut;
		for(i = 0; i < params_count; i = i + 1)
		{
			cur_param_node ::= ast_get_child(node, i);
			// remember the param is a decl
			// its first child is the typename
			cur_param_ty ::= ty_typename_node(ast_get_child(cur_param_node, 0), scope);
			if(ty_is_bad(cur_param_ty))
			{
				psyc_error_begin(node->loc);
				putzstr("parameter ");
				putuint(i);
				putzstr(" of function type yielded ");
				putty(cur_param_ty);
				putchar(10);
				ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			[fn_params # i] = cur_param_ty;
		}
		return ty_fn(retty, fn_params, params_count, typename.quals);
	}
	if(typename.descriptor == (ast_typename_descriptor.deduced))
	{
		// this is impossible. error out. this function should never be called with a deduced type
		// example might be someone using a deduced type as a struct member...
		psyc_error_begin(node->loc);
		putzstr("deduced-type declarations are not valid in the following contexts:");
		putchar(10);
		putzstr("- function parameters/return types");
		putchar(10);
		putzstr("- assembly return types");
		putchar(10);
		putzstr("- struct data members");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(typename.descriptor == (ast_typename_descriptor.inferred_from))
	{
		return ty_set_qual(val_node(ast_get_child(node, 0), scope, val_resolution.type_only).type, typename.quals);
	}
	psyc_panic_begin(node->loc);
	putzstr("failed to convert this typename node to a tyid");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

ty_discard_static_unless : func(type : tyid, cond : bool -> tyid)
{
	// if cond is true keep all quals
	// if false keep all qualifiers except static
	if(cond)
	{
		return type;
	}
	retty : tyid mut := ty_clear_all_quals(type);
	if(ty_has_qual(type, tyqual.qual_weak))
	{
		retty = ty_set_qual(retty, tyqual.qual_weak);
	}
	if(ty_has_qual(type, tyqual.qual_mut))
	{
		retty = ty_set_qual(retty, tyqual.qual_mut);
	}
	return retty;
};

// given two primitive types which we want to add/sub/mul/div/shr/etc...
// return the type that both should be converted to
// you can always assume the returned type matches one of the operands.
// return zero if arithmetic operations are not defined for this type combination
ty_of_arithmetic : func(lhs : tyid, rhs : tyid -> tyid)
{
	retty : tyid mut;
	both_are_static ::= ty_has_qual(lhs, tyqual.qual_static) && ty_has_qual(rhs, tyqual.qual_static);
	if(ty_is_bool(lhs) || ty_is_bool(rhs))
	{
		// if either of them are bools, they both must be.
		// we dont be supporting true + 5 no thank you. cast it if you absolutely must.
		if(ty_is_bool(lhs) && ty_is_bool(rhs))
		{
			return ty_discard_static_unless(ty_set_qual(tyid.bool, tyqual.qual_static), both_are_static);
		}
		return zero;
	}
	lhs_integral ::= ty_is_integral(lhs);
	rhs_integral ::= ty_is_integral(rhs);
	lhs_floating_point ::= ty_is_floating_point(lhs);
	rhs_floating_point ::= ty_is_floating_point(rhs);
	lhs_arithmetic_size ::= ty_integral_size(lhs) + ty_floating_point_size(lhs);
	rhs_arithmetic_size ::= ty_integral_size(rhs) + ty_floating_point_size(rhs);
	lhs_signed ::= ty_is_signed_integral(lhs);
	rhs_signed ::= ty_is_signed_integral(rhs);

	if(lhs_floating_point && rhs_integral)
	{
		return ty_discard_static_unless(lhs, both_are_static);
	}
	if(lhs_integral && rhs_floating_point)
	{
		return ty_discard_static_unless(rhs, both_are_static);
	}
	if((lhs_integral && rhs_integral) || (lhs_floating_point && rhs_floating_point))
	{
		if(lhs_arithmetic_size < rhs_arithmetic_size)
		{
			return ty_discard_static_unless(rhs, both_are_static);
		}
		if(lhs_arithmetic_size == rhs_arithmetic_size)
		{
			// if the sizes are the same then we prefer unsigned
			if(lhs_signed != rhs_signed)
			{
				if(lhs_signed)
				{
					// rhs is unsigned
					return ty_discard_static_unless(rhs, both_are_static);
				}
				// lhs is unsigned
				return ty_discard_static_unless(lhs, both_are_static);
			}
		}
		// well theyre just the same type excluding qualifiers.
		// if both are static then set static, otherwise remove static
		// static + nonstatic = nonstatic after all
		return ty_discard_static_unless(lhs, both_are_static);
	}
	return zero;
};
