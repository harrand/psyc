tyqual ::= enum
{
	// msb set
	.qual_static := 0x8000000000000000;
	// msb-1 set
	.qual_mut := 0x4000000000000000;
	// msb-2 set
	.qual_weak := 0x2000000000000000;
};

tytag ::= enum
{
	.prim := 1;
	.ptr := 2;
	.arr := 3;
	.enm := 4;
	.strct := 5;
	.fn := 6;
};

structty ::= struct
{
	members : tyid mut?;
	member_names : u8??;
	member_name_lens : u64?;
	members_count : u64;
};

enumty ::= struct
{
	entries : u64 mut?;
	entry_names : u8? mut?;
	entry_name_lens : u64 mut?;
	entries_count : u64;
};

ty ::= struct
{
	tag : tytag;
	name : u8?;
	name_len : u64;

	// if pointer: underlying. if base, id into corresponding tybox
	base : tyid;
	array_len : u64;
	strct : structty;
	enm : enumty;
};

// this tyid enum is the magic behind it all. here you only see the primitive types.
// however anytime a tybox registers a new e.g struct/enum type they will get their
// own tyid entry dedicated to them. also pointers/arrays of stuff will also have
// their own tyid. this might seem wasteful but is necessary. type qualifiers though
// are implemented as bitflags on the top 3 most significant bits of a tyid. so for
// example. tyid.v0 is 'v0' with no quals. if this tyid had the top 3 bits set, it
// would instead be a 'v0 mut weak static'. this means that *every* single type you
// could think of has its own tyid. it also makes the type system pretty flat w.r.t
// memory.
tyid ::= enum
{
	.v0 := 1;
	.s64 := 2;
	.s32 := 3;
	.s16 := 4;
	.s8 := 5;
	.u64 := 6;
	.u32 := 7;
	.u16 := 8;
	.u8 := 9;
	.bool := 10;
	.f64 := 11;
	.f32 := 12;
};

// integer literals e.g '5' will have this exact type
tyid_integral_literal ::= func(-> tyid)
{
	return ty_set_qual(tyid.s64, tyqual.qual_weak | tyqual.qual_static);
};

// float literals e.g '6.9' will have this exact type
tyid_floating_point_literal ::= func(-> tyid)
{
	return ty_set_qual(tyid.f64, tyqual.qual_weak | tyqual.qual_static);
};

// char literals e.g ''f'' will have this exact type
tyid_char_literal ::= func(-> tyid)
{
	return ty_set_qual(tyid.u8, tyqual.qual_weak | tyqual.qual_static);
};

// string literals e.g "foo" will have this exact type
tyid_string_literal ::= func(-> tyid)
{
	return ty_ptr(ty_set_qual(tyid.u8, tyqual.qual_static), tyqual.qual_static);
};

// bool literals i.e true/false will have this exact type
tyid_bool_literal ::= func(-> tyid)
{
	return ty_set_qual(tyid.bool, tyqual.qual_static);
};

ty_is_char ::= func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return
		(idpure == (tyid.u8));
};

ty_is_enum ::= func(id : tyid -> bool)
{
	return ty_unwrap(id)->tag == (tytag.enm);
};

// integral size in bits. zero if not integral.
ty_integral_size ::= func(id : tyid -> u64)
{
	idpure ::= ty_clear_all_quals(id);
	if((idpure == (tyid.s64)) || (idpure == (tyid.u64)))
	{
		return 64;
	}
	if((idpure == (tyid.s32)) || (idpure == (tyid.u32)))
	{
		return 32;
	}
	if((idpure == (tyid.s16)) || (idpure == (tyid.u16)))
	{
		return 16;
	}
	if((idpure == (tyid.s8)) || (idpure == (tyid.u8)))
	{
		return 8;
	}
	return zero;
};

ty_is_signed_integral ::= func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return
		(idpure == (tyid.s64)) ||
		(idpure == (tyid.s32)) ||
		(idpure == (tyid.s16)) ||
		(idpure == (tyid.s8));
};
// is the given type any form of integer?
ty_is_integral ::= func(id : tyid -> bool)
{
	return ty_integral_size(id) > 0;
};

ty_floating_point_size ::= func(id : tyid -> u64)
{
	idpure ::= ty_clear_all_quals(id);
	if(idpure == (tyid.f64))
	{
		return 64;
	}
	if(idpure == (tyid.f32))
	{
		return 32;
	}
	return 0;
};

// is the given type any form of floating point?
ty_is_floating_point ::= func(id : tyid -> bool)
{
	return ty_floating_point_size(id) > 0;
};

// is the given type any form of bool?
ty_is_bool ::= func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return (idpure == (tyid.bool));
};

// is the given type a void type
ty_is_v0 ::= func(id : tyid -> bool)
{
	idpure ::= ty_clear_all_quals(id);
	return (idpure == (tyid.v0));
};

// returns whether the type has the given qualifier(s)
ty_has_qual ::= func(id : tyid, qual : tyqual -> bool)
{
	return ((id@s64) & (qual@s64)) != 0;
};

// returns the input type but with the given qualifier(s)
ty_set_qual ::= func(id : tyid, qual : tyqual -> tyid)
{
	return ((id@s64) | (qual@s64))@tyid;
};

// returns the input type but without the given qualifier(s)
ty_clear_qual ::= func(id : tyid, qual : tyqual -> tyid)
{
    return ((id@s64) & ~(qual@s64))@tyid;
};

// returns the input type but without any qualifiers.
ty_clear_all_quals ::= func(id : tyid -> tyid)
{
	all_but_top_3_msb ::= 0x1FFFFFFFFFFFFFFF;
	return (id@s64 & all_but_top_3_msb)@tyid;
};

quals_max_strlen ::= 7 * 3;
qual_str_mut ::= " mut";
qual_str_weak ::= " weak";
qual_str_static ::= " static";

// print out the name of a type.
putty ::= func(id : tyid -> v0)
{
	is_mut ::= ty_has_qual(id, tyqual.qual_mut);
	is_weak ::= ty_has_qual(id, tyqual.qual_weak);
	is_static ::= ty_has_qual(id, tyqual.qual_static);
	tydata ::= tybox_at(ref(prog.types), ty_clear_all_quals(id));
	putbytes(tydata->name, tydata->name_len);
	if(is_mut)
	{
		putzstr(qual_str_mut);
	}
	if(is_weak)
	{
		putzstr(qual_str_weak);
	}
	if(is_static)
	{
		putzstr(qual_str_static);
	}
};

// returns whether the lhs and rhs types are the same (ignoring qualifiers)
ty_matches_ignore_quals ::= func(lhs : tyid, rhs : tyid -> bool)
{
	return ty_clear_all_quals(lhs) == ty_clear_all_quals(rhs);
};

ty_find_by_name ::= func(name : u8?, name_len : u64 -> tyid)
{
	return tybox_find(ref(prog.types), name, name_len);
};

// high-level function to convert type data to a tyid (including quals).
// assume that if this type data has not been seen before it will be dynamically added to a huge type table.
ty_wrap ::= func(type : ty, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add(ref(prog.types), type), quals);
};

// high-level function to retrieve the data corresponding to a type.
ty_unwrap ::= func(id : tyid -> ty mut?)
{
	return tybox_at(ref(prog.types), ty_clear_all_quals(id));
};

// describes type conversions
tyconv ::= enum
{
	.yes := 1;
	.yes_needs_convert := 2;
	.no := 3;
	.no_cant_add_staticness := 4;
	.no_but_yes_with_weak := 5;
};

// describe how we convert 'from' -> 'to'
ty_converts_to ::= func(from : tyid, to : tyid -> tyconv)
{
	from_is_mut ::= ty_has_qual(from, tyqual.qual_mut);
	from_is_weak ::= ty_has_qual(from, tyqual.qual_weak);
	from_is_static ::= ty_has_qual(from, tyqual.qual_static);

	to_is_mut ::= ty_has_qual(to, tyqual.qual_mut);
	to_is_weak ::= ty_has_qual(to, tyqual.qual_weak);
	to_is_static ::= ty_has_qual(to, tyqual.qual_static);

	either_is_weak ::= from_is_weak || to_is_weak;
	if(ty_matches_ignore_quals(from, to))
	{
		// core of the types are the same.
		// mut doesnt matter.
		// static converts to non-static but NOT vice-versa
		// weakness doesnt matter.
		if((!from_is_static) && to_is_static)
		{
			return tyconv.no_cant_add_staticness;
		}
		return tyconv.yes;
	}
	// types dont match
	fromty ::= ty_unwrap(from);
	toty ::= ty_unwrap(to);
	fromprim ::= fromty->base;
	toprim ::= toty->base;
	if(fromty->tag == (tytag.prim))
	{
		if(toty->tag == (tytag.prim))
		{
			// both are prims.
			// integral converts to integral if one is weak
			// floating point converts to floating point if one is weak
			// integral converts to floating point and vice-versa if one is weak
			// bool converts to integral and vice-versa if one is weak
			// or in other words:
			// v0 doesnt convert to/from anything
			// integral converts to/from everything else with weak
			// floating point converts to/from everything else apart from bool with weak
			if(ty_is_v0(fromprim) || ty_is_v0(toprim))
			{
				return tyconv.no;
			}
			if(ty_is_integral(fromprim))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
		}
		else
		{
			// when can a prim convert to a non-prim?
			// s64 weak converts to enums
			// u64 weak converts to pointers.
			// nothing else.
			if(fromprim == (tyid.s64))
			{
				if(toty->tag == (tytag.enm))
				{
					if(either_is_weak)
					{
						return tyconv.yes_needs_convert;
					}
					return tyconv.no_but_yes_with_weak;
				}
			}
			if(fromprim == (tyid.u64))
			{
				if(toty->tag == (tytag.ptr))
				{
					if(either_is_weak)
					{
						return tyconv.yes_needs_convert;
					}
					return tyconv.no_but_yes_with_weak;
				}
			}
			return tyconv.no;
		}
	}
	// lhs is not a prim
	// enums can convert to s64
	if(fromty->tag == (tytag.enm))
	{
		if(toty->tag == (tytag.prim))
		{
			if(toprim == (tyid.s64))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
		}
	}
	// ptrs can convert to u64
	if(fromty->tag == (tytag.ptr))
	{
		if(toty->tag == (tytag.prim))
		{
			if(toprim == (tyid.u64))
			{
				if(either_is_weak)
				{
					return tyconv.yes_needs_convert;
				}
				return tyconv.no_but_yes_with_weak;
			}
		}
	}
	return zero;
};

// make sure from can convert 'from' -> 'to'
// fail with a good error message if the conversion cannot happen
ty_ensure_convertible_to ::= func(from : tyid, to : tyid, source : ast? -> v0)
{
	conv ::= ty_converts_to(from, to);
	if((conv == (tyconv.yes)) || (conv == (tyconv.yes_needs_convert)))
	{
		// epic!
		return;
	}
	if(conv == (tyconv.no))
	{
		psyc_error_begin(source->loc);
		putzstr("type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" is not convertible to a ");
		putchar('"');
		putty(to);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(conv == (tyconv.no_but_yes_with_weak))
	{
		psyc_error_begin(source->loc);
		putzstr("type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" is not convertible to a ");
		putchar('"');
		putty(to);
		putchar('"');
		putzstr(" (but it would work with a cast!)");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
		psyc_diag_end();
		psyc_exit_failure();
	}
	psyc_panic_begin(source->loc);
	putzstr("ty_converts_to(");
	putchar('"');
	putty(from);
	putchar('"');
	putzstr(", ");
	putchar('"');
	putty(to);
	putchar('"');
	putzstr(") yielded ");
	putzstr(__enumname(conv));
	putzstr(" (");
	putsint(conv@s64);
	putzstr("). this is a compiler bug.");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1);
	psyc_diag_end();
	psyc_exit_failure();
};

// return a pointer to the given type, along with qualifiers
ty_ptr ::= func(id : tyid, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add_ptr(ref(prog.types), id), quals);
};

ty_arr ::= func(id : tyid, len : u64, quals : tyqual -> tyid)
{
	return ty_set_qual(tybox_add_array(ref(prog.types), id, len), quals);
};

// given two primitive types which we want to add/sub/mul/div/shr/etc...
// return the type that both should be converted to
// you can always assume the returned type matches one of the operands.
// return zero if arithmetic operations are not defined for this type combination
ty_of_arithmetic ::= func(lhs : tyid, rhs : tyid -> tyid)
{
	both_are_static ::= ty_has_qual(lhs, tyqual.qual_static) && ty_has_qual(rhs, tyqual.qual_static);
	if(ty_is_bool(lhs) || ty_is_bool(rhs))
	{
		// if either of them are bools, they both must be.
		// we dont be supporting true + 5 no thank you. cast it if you absolutely must.
		if(ty_is_bool(lhs) && ty_is_bool(rhs))
		{
			if(both_are_static)
			{
				return ty_set_qual(tyid.bool, tyqual.qual_static);
			}
			return tyid.bool;
		}
		return zero;
	}
	lhs_integral ::= ty_is_integral(lhs);
	rhs_integral ::= ty_is_integral(rhs);
	lhs_floating_point ::= ty_is_floating_point(lhs);
	rhs_floating_point ::= ty_is_floating_point(rhs);
	lhs_arithmetic_size ::= ty_integral_size(lhs) + ty_floating_point_size(lhs);
	rhs_arithmetic_size ::= ty_integral_size(rhs) + ty_floating_point_size(rhs);
	lhs_signed ::= ty_is_signed_integral(lhs);
	rhs_signed ::= ty_is_signed_integral(rhs);

	if(lhs_floating_point && rhs_integral)
	{
		return lhs;
	}
	if(lhs_integral && rhs_floating_point)
	{
		return rhs;
	}
	if((lhs_integral && rhs_integral) || (lhs_floating_point && rhs_floating_point))
	{
		if(lhs_arithmetic_size < rhs_arithmetic_size)
		{
			return rhs;
		}
		if(lhs_arithmetic_size == rhs_arithmetic_size)
		{
			// if the sizes are the same then we prefer unsigned
			if(lhs_signed != rhs_signed)
			{
				if(lhs_signed)
				{
					// rhs is unsigned
					return rhs;
				}
				// lhs is unsigned
				return lhs;
			}
		}
		// well theyre just the same type excluding qualifiers.
		// if both are static then set static, otherwise remove static
		// static + nonstatic = nonstatic after all
		if(both_are_static)
		{
			return ty_set_qual(ty_clear_all_quals(lhs), tyqual.qual_static);
		}
		return ty_clear_all_quals(lhs);
	}
	return zero;
};
