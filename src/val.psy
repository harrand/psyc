// you have entered the twilight zone.
// so the way we handle values in psyc is extremely complex
// this is because we try to do everything at the same time (otherwise the rules of the language e.g in conversions have to be copied around in different forms)

valtag ::= enum
{
	.invalid := 0;
	.type_only := 1;
	// almost certainly this is 'zero'
	.value_only := 2;
	.typed_value := 3;
};

valknown ::= enum
{
	.compile_time := 1;
	.runtime := 2;
};

// all expressions are either an lvalue or an rvalue. never both, never neither
valhand ::= enum
{
	.lvalue := 1;
	.rvalue := 2;
};

valcompile_time ::= struct
{
	// val_node will generate .is_zero = true on an ast_expr.zero_value
	// but if the value ever undergoes any conversions this will be converted to a typed value
	is_zero : bool;
	// populated if the type is a primitive
	primitive : ast_literal;
	// populated if the type is a struct or array
	// struct: members_count == ty.strct.members_count, members[i] corresponds to the i'th data member. if members[i] is invalid => means undefined value
	// array: members_count == ty.array_len, members[i] corresponds to the i'th element. members[i] cannot be invalid
	members_count : u64;
	members : v0? weak;
	// populated if the type is a function type and was created as a reference to a function
	// note: not all function type values known at compile-time will be a reference to the function
	// e.g 59@func(-> v0) will be a statically-known value of function type but its actually a primitive (int59) under-the-hood
	// if the value isnt a funcref these are guaranteed to be zero.
	funcref_name : u8?;
	funcref_name_len : u64;
	// populated if the type is a function type and was created as a reference to a builtin
	builtinref_name : u8?;
	builtinref_name_len : u64;
	// might be populated if the value is an lvalue. if this is populated then it refers to a variable in the current scope.
	// this is how variable references are expressed in vals
	varref_name : u8?;
	varref_name_len : u64;
	// populated if the type is a pointer and was created via a 'ref' unop.
	valueref : v0? weak;
};

valruntime ::= struct
{
	cg : u64;
};

val ::= struct
{
	tag : valtag;
	known : valknown;
	hand : valhand;
	type : tyid;
	compile_time : valcompile_time;
	runtime : valruntime;
};

// some functions return vals and take one of these
// resolutions describe the nature of the evaluation of the val you want to take place
val_resolution ::= enum
{
	// the val must be a type-only value and do not attempt to do any static computation/generate any runtime code.
	.type_only := 0;
	// the val must be a statically-known value and must not generate any runtime code (error if i cant do this at compile-time)
	.compile_time_only := 1;
	// the val must be a runtime value (even if the evaluation yielded a static value please convert it to a runtime value)
	.runtime_only := 2;
	// i dont really care, do what you need to do.
	.runtime_or_compile_time := 3;
};

val_is_valid ::= func(v : val -> bool)
{
	return v.tag != (valtag.invalid);
};

// this call is only valid on integers known at compile time.
val_must_get_integer ::= func(v : val, scope : lexical_scope?, source : ast? -> s64 weak)
{
	// doing a ty_is_integral check here is *not* reasonable
	// because enums for example also are integral literals under the hood, and its perfectly reasonable to request an enum value this way at compile time.
	// however, qual_static *is* a reasonable check
	if(!(ty_is_integral(v.type) || ty_is_enum(v.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be either an integral or enum type, but instead was a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(!ty_has_qual(v.type, tyqual.qual_static))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be statically known (i.e contain the 'static' qualifier), but was of type ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// these checks are for sanity reasons only
	// if the above 2 checks pass then these always should.
	if(v.tag != (valtag.typed_value))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to statically known, but the value was unable to be determined at all (it was valtag.");
		putzstr(__enumname(v.tag));
		putzstr(" (");
		putsint(v.tag@s64);
		putzstr(")");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.known != (valknown.compile_time))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to be known at compile-time as it has the static qualifier (");
		putty(v.type);
		putzstr("), but its value was not known at compile time:");
		putval(v);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.compile_time.varref_name != zero)
	{
		return val_must_get_integer(val_must_get_varref_initialiser(v, scope, source), scope, source);
	}
	return v.compile_time.primitive.integer;
};

// this call is only valid on floats known at compile time.
val_must_get_float ::= func(v : val, scope : lexical_scope?, source : ast? -> f64 weak)
{
	if(!ty_is_floating_point(v.type))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be a floating point type, but instead was a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(!ty_has_qual(v.type, tyqual.qual_static))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be statically known (i.e contain the 'static' qualifier), but was of type ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// these checks are for sanity reasons only
	// if the above 2 checks pass then these always should.
	if(v.tag != (valtag.typed_value))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to statically known, but the value was unable to be determined at all (it was valtag.");
		putzstr(__enumname(v.tag));
		putzstr(" (");
		putsint(v.tag@s64);
		putzstr(")");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.known != (valknown.compile_time))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to be known at compile-time as it has the static qualifier (");
		putty(v.type);
		putzstr("), but its value was not known at compile time:");
		putval(v);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.compile_time.varref_name != zero)
	{
		return val_must_get_float(val_must_get_varref_initialiser(v, scope, source), scope, source);
	}
	return v.compile_time.primitive.floating_point;
};

// this call is only valid on integers known at compile time.
val_must_get_boolean ::= func(v : val, scope : lexical_scope?, source : ast? -> bool)
{
	if(!ty_is_bool(v.type))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be a statically-known boolean, but instead was a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(!ty_has_qual(v.type, tyqual.qual_static))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be statically known (i.e contain the 'static' qualifier), but was of type ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// these checks are for sanity reasons only
	// if the above 2 checks pass then these always should.
	if(v.tag != (valtag.typed_value))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to statically known, but the value was unable to be determined at all (it was valtag.");
		putzstr(__enumname(v.tag));
		putzstr(" (");
		putsint(v.tag@s64);
		putzstr(")");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.known != (valknown.compile_time))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to be known at compile-time as it has the static qualifier (");
		putty(v.type);
		putzstr("), but its value was not known at compile time:");
		putval(v);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.compile_time.varref_name != zero)
	{
		return val_must_get_boolean(val_must_get_varref_initialiser(v, scope, source), scope, source);
	}
	return v.compile_time.primitive.boolean;
};

val_must_get_string ::= func(v : val, scope : lexical_scope?, source : ast?, out_str : u8 mut? mut?, out_len : u64 mut? -> v0)
{
	if(!ty_is_string_literal(v.type))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be a statically-known string literal, but instead was a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(!ty_has_qual(v.type, tyqual.qual_static))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to be statically known (i.e contain the 'static' qualifier), but was of type ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// these checks are for sanity reasons only
	// if the above 2 checks pass then these always should.
	if(v.tag != (valtag.typed_value))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to statically known, but the value was unable to be determined at all (it was valtag.");
		putzstr(__enumname(v.tag));
		putzstr(" (");
		putsint(v.tag@s64);
		putzstr(")");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.known != (valknown.compile_time))
	{
		psyc_panic_begin(source->loc);
		putzstr("expected value to be known at compile-time as it has the static qualifier (");
		putty(v.type);
		putzstr("), but its value was not known at compile time:");
		putval(v);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.compile_time.varref_name != zero)
	{
		val_must_get_string(val_must_get_varref_initialiser(v, scope, source), scope, source, out_str, out_len);
		return;
	}
	deref(out_str) = (v.compile_time.primitive.chars);
	deref(out_len) = (v.compile_time.primitive.chars_len);
};

integer_as_val ::= func(n : s64 weak -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := tyid_integral_literal();
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal{.tag := ast_literal_tag.integer; .integer := n;};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

float_as_val ::= func(n : f64 weak -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := tyid_floating_point_literal();
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal{.tag := ast_literal_tag.floating_point; .floating_point := n;};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

string_as_val ::= func(chars : u8?, chars_len : u64 -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := tyid_string_literal();
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal{.tag := ast_literal_tag.string; .chars := chars; .chars_len := chars_len;};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

char_as_val ::= func(char : u8 -> val)
{
	chardata : u8 mut? := arena_alloc(string_arena, 1);
	deref(chardata # 0) = char;
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := tyid_char_literal();
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal{.tag := ast_literal_tag.char; .chars := chardata; .chars_len := 1;};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

bool_as_val ::= func(b : bool -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := tyid_bool_literal();
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := ast_literal{.tag := ast_literal_tag.boolean; .boolean := b;};
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

literal_as_val ::= func(literal : ast_literal -> val)
{
	if(literal.tag == (ast_literal_tag.integer))
	{
		return integer_as_val(literal.integer);
	}
	if(literal.tag == (ast_literal_tag.floating_point))
	{
		return float_as_val(literal.floating_point);
	}
	if(literal.tag == (ast_literal_tag.char))
	{
		return char_as_val(deref(literal.chars # 0));
	}
	if(literal.tag == (ast_literal_tag.string))
	{
		return string_as_val(literal.chars, literal.chars_len);
	}
	if(literal.tag == (ast_literal_tag.boolean))
	{
		return bool_as_val(literal.boolean);
	}
	return zero;
};

// given a val that is a varref to some variable visible in 'scope', get the initialiser and assert that its statically known
val_must_get_varref_initialiser ::= func(varref : val, scope : lexical_scope?, source : ast? -> val)
{
	var ::= scope_find_variable(scope, varref.compile_time.varref_name, varref.compile_time.varref_name_len);
	if(!ty_has_qual(var->type, tyqual.qual_static))
	{
		psyc_panic_begin(source->loc);
		putzstr("attempt to retrieve initialiser of variable ");
		putchar('"');
		putbytes(varref.compile_time.varref_name, varref.compile_time.varref_name_len);
		putchar('"');
		putzstr(" as the value referring to it has the 'static' qualifier, but this variable itself is of a non-static type ");
		putchar('"');
		putty(var->type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(var->compile_time_storage.known != (valknown.compile_time))
	{
		psyc_panic_begin(source->loc);
		putzstr("attempt to retrieve initialiser of variable ");
		putchar('"');
		putbytes(varref.compile_time.varref_name, varref.compile_time.varref_name_len);
		putchar('"');
		putzstr(" as the value referring to it has the 'static' qualifier, and while this variable also is of static-type ");
		putchar('"');
		putty(var->type);
		putchar('"');
		putzstr(" its initialiser was not statically-known.");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return var->compile_time_storage;
};

variable_as_val ::= func(var : variable?, source : ast? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.lvalue;
		.type := var->type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := zero;
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := var->node->decl.name;
			.varref_name_len := var->node->decl.name_len;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

function_as_val ::= func(fn : function?, source : ast? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := fn->type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := zero;
			.members_count := zero;
			.members := zero;
			.funcref_name := fn->name;
			.funcref_name_len := fn->name_len;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

assembly_as_val ::= func(as : assembly?, source : ast? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := as->type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := zero;
			.members_count := zero;
			.members := zero;
			.funcref_name := as->name;
			.funcref_name_len := as->name_len;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

builtin_as_val ::= func(b : builtin_entry? -> val)
{
	return val
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := b->type;
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := zero;
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := b->name_zstr;
			.builtinref_name_len := zstrlen(b->name_zstr);
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

// get a statically-known reference to 'v'
ref_as_val ::= func(v : val, source : ast? -> val)
{
	ret ::= val mut
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := ty_ptr(v.type, zero);
		.compile_time := valcompile_time
		{
			.is_zero := false;
			.primitive := zero;
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := arena_alloc(global_arena, __sizeof(val));
		};
		.runtime := zero;
	};
	deref(ret.compile_time.valueref@val mut?) = v;
	return ret;
};

type_as_val ::= func(type : tyid -> val)
{
	ret : val mut := zero;
	ret.tag = (valtag.type_only);
	ret.type = type;
	return ret;
};

// representation of just 'zero' as a val
zero_val ::= func(-> val)
{
	return val
	{
		.tag := valtag.value_only;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := zero;
		.compile_time := valcompile_time
		{
			.is_zero := true;
			.primitive := zero;
			.members_count := zero;
			.members := zero;
			.funcref_name := zero;
			.funcref_name_len := zero;
			.builtinref_name := zero;
			.builtinref_name_len := zero;
			.varref_name := zero;
			.varref_name_len := zero;
			.valueref := zero;
		};
		.runtime := zero;
	};
};

val_is_zero_val ::= func(v : val -> bool)
{
	return (v.tag == valtag.value_only) && (v.known == (valknown.compile_time)) && (v.compile_time.is_zero);
};

// representation of zero@to
zero_as_val ::= func(to : tyid, source : ast? -> val)
{
	i : u64 mut;
	ret ::= val mut
	{
		.tag := valtag.typed_value;
		.known := valknown.compile_time;
		.hand := valhand.rvalue;
		.type := to;
		.compile_time := zero;
		.runtime := zero;
	};

	toty ::= ty_unwrap(to);
	if(ty_is_struct(to))
	{
		// create all the members as zeros
		ret.compile_time.members_count = (toty->strct.members_count);
		ret.compile_time.members = arena_alloc(global_arena, __sizeof(val) * (ret.compile_time.members_count));
		for(i = 0, i < (ret.compile_time.members_count), i = i + 1)
		{
			memty ::= deref(toty->strct.members # i);
			deref(ret.compile_time.members@val mut? # i) = zero_as_val(memty, source);
		}
	}
	if(ty_is_arr(to))
	{
		// create all the elements as zeros
		ret.compile_time.members_count = (toty->array_len);
		ret.compile_time.members = arena_alloc(global_arena, __sizeof(val) * (ret.compile_time.members_count));
		for(i = 0, i < (ret.compile_time.members_count), i = i + 1)
		{
			deref(ret.compile_time.members@val mut? # i) = zero_as_val(ty_underlying(to), source);
		}
	}
	literal : ast_literal mut := zero;
	if(ty_is_ptr(to))
	{
		// so this one is pretty mad
		// the intention is as follows:
		// - this yields a val that is of ptr type but is an integral literal under-the-hood
		// - anything that attempts to use it will understand that a pointer value known at compile_time is an integral literal under the hood
		// - all is right with the world
		literal.tag = (ast_literal_tag.integer);
		ret.compile_time = (literal_as_val(literal).compile_time);
	}
	if(ty_is_enum(to))
	{
		// same as the ptr case above.
		literal.tag = (ast_literal_tag.integer);
		ret.compile_time = (literal_as_val(literal).compile_time);
	}
	if(ty_is_fn(to))
	{
		// same as the ptr case above
		literal.tag = (ast_literal_tag.integer);
		// i know this one seems particularly mad
		// but remember this is static compile time madness
		// i.e zero@func(-> v0)
		// in terms of providence this is not anywhere near a real function
		// so most likely this codepath is only really being called on embedded with very specific magical functions existing at a specific address.
		ret.compile_time = (literal_as_val(literal).compile_time);
	}
	if(ty_is_prim(to))
	{
		if(ty_is_integral(to))
		{
			literal.tag = (ast_literal_tag.integer);
		}
		if(ty_is_floating_point(to))
		{
			literal.tag = (ast_literal_tag.floating_point);
		}
		if(ty_is_bool(to))
		{
			literal.tag = (ast_literal_tag.boolean);
		}
		// get the value
		ret.compile_time = (literal_as_val(literal).compile_time);
	}
	return ret;
};

val_node ::= func(node : ast?, scope : lexical_scope?, resolution : val_resolution -> val)
{
	retval : val mut;
	// given any node, give me a value.
	// if resolution == val_resolution.type_only, only return a type.
	// if resolution == val_resolution.compile_time_only, error out if we need to generate runtime code
	// if resolution == val.runtime_only, ensure the return value is val_dynamic'd
	if(ast_is_expr(node, ast_expr_tag.zero_value))
	{
		return zero_val();
	}
	if(ast_is_expr(node, ast_expr_tag.literal))
	{
		retval = literal_as_val(node->literal);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(retval, scope, node);
		}
		return retval;
	}
	if(ast_is_expr(node, ast_expr_tag.symbol))
	{
		return val_symbol(node, scope, resolution);
	}
	if(ast_is_expr(node, ast_expr_tag.sizeof_t))
	{
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(tyid_integral_literal());
		}
		if(resolution == (val_resolution.compile_time_only))
		{
			// note: even though cg_sizeof actually produces a compile-time value it currently relies on cg_begin having been called
			// which is not the case in a static context (currently in a build region)
			// you should pretty easily be able to fix this by just calling cg_begin earlier.
			psyc_panic_begin(node->loc);
			putzstr("support for sizeof expressions within static contexts are not yet implemented.");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(cg_sizeof(ty_typename_node(ast_get_child(node, 0), scope)), scope, node);
		}
		return cg_sizeof(ty_typename_node(ast_get_child(node, 0), scope));
	}
	if(ast_is_expr(node, ast_expr_tag.alignof_t))
	{
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(tyid_integral_literal());
		}
		if(resolution == (val_resolution.compile_time_only))
		{
			// note: even though cg_sizeof actually produces a compile-time value it currently relies on cg_begin having been called
			// which is not the case in a static context (currently in a build region)
			// you should pretty easily be able to fix this by just calling cg_begin earlier.
			psyc_panic_begin(node->loc);
			putzstr("support for alignof expressions within static contexts are not yet implemented.");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(cg_alignof(ty_typename_node(ast_get_child(node, 0), scope)), scope, node);
		}
		return cg_alignof(ty_typename_node(ast_get_child(node, 0), scope));
	}
	if(ast_is_expr(node, ast_expr_tag.countof_t))
	{
		countof_type ::= ty_typename_node(ast_get_child(node, 0), scope);
		if((!ty_is_struct(countof_type)) && (!ty_is_arr(countof_type)) && (!ty_is_enum(countof_type)) && (!ty_is_fn(countof_type)))
		{
			psyc_error_begin(node->loc);
			putzstr("'countof' expressions are only valid on struct, array, enum or function typenames. you have passed a ");
			putchar('"');
			putty(countof_type);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(tyid_integral_literal());
		}
		countof_val : val mut := zero;
		tyu ::= ty_unwrap(countof_type);
		if(ty_is_struct(countof_type))
		{
			countof_val = integer_as_val(tyu->strct.members_count);
		}
		if(ty_is_arr(countof_type))
		{
			countof_val = integer_as_val(tyu->array_len);
		}
		if(ty_is_enum(countof_type))
		{
			countof_val = integer_as_val(tyu->enm.entries_count);
		}
		if(ty_is_fn(countof_type))
		{
			countof_val = integer_as_val(tyu->fn.params_count);
		}
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(countof_val, scope, node);
		}
		return countof_val;
	}
	if(ast_is_stmt(node, ast_stmt_tag.decl))
	{
		var ::= scope_find_variable(scope, node->decl.name, node->decl.name_len);
		if(var == zero)
		{
			psyc_panic_begin(node->loc);
			putzstr("scope_find_variable on decl statement could not find the variable. it probably wasnt hoisted correctly");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(resolution == (val_resolution.compile_time_only))
		{
			return s_decl(var, scope);
		}
		return cg_decl(var, scope);
	}
	if(ast_is_expr(node, ast_expr_tag.biop))
	{
		lhs_operand ::= val_node(ast_get_child(node, 0), scope, resolution);
		rhs_operand ::= val_node(ast_get_child(node, 1), scope, resolution);
		return val_biop(node->biop.op, lhs_operand, rhs_operand, scope, resolution, node);
	}
	if(ast_is_expr(node, ast_expr_tag.unop))
	{
		unoperand ::= val_node(ast_get_child(node, 0), scope, resolution);
		return val_unop(node->unop, unoperand, scope, resolution, node);
	}
	if(ast_is_expr(node, ast_expr_tag.field))
	{
		field_lhs ::= val_node(ast_get_child(node, 0), scope, resolution);
		field_rhs_node ::= ast_get_child(node, 1);
		return val_field(field_lhs, field_rhs_node, scope, resolution);
	}
	if(ast_is_expr(node, ast_expr_tag.ptrfield))
	{
		ptr_field_lhs ::= val_node(ast_get_child(node, 0), scope, resolution);
		ptr_field_rhs_node ::= ast_get_child(node, 1);
		return val_ptr_field(ptr_field_lhs, ptr_field_rhs_node, scope, resolution);
	}
	if(ast_is_expr(node, ast_expr_tag.dereference))
	{
		deref_operand ::= val_node(ast_get_child(node, 0), scope, resolution);
		return val_deref(deref_operand, resolution, scope, node);
	}
	if(ast_is_expr(node, ast_expr_tag.cast))
	{
		cast_from : val mut := val_node(ast_get_child(node, 0), scope, resolution);
		// make cast_from weak
		cast_from.type = ty_set_qual(cast_from.type, tyqual.qual_weak);
		cast_to_node ::= ast_get_child(node, 1);
		if(ast_is_weakness_idiom(cast_to_node))
		{
			// just the weakness idiom!
			if(resolution == (val_resolution.type_only))
			{
				return type_as_val(cast_from.type);
			}
			if(resolution == (val_resolution.runtime_only))
			{
				return val_dynamic(cast_from, scope, node);
			}
			return cast_from;
		}
		cast_to ::= ty_typename_node(cast_to_node, scope);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(val_convert_to(cast_from, cast_to, scope, resolution, node), scope, node);
		}
		return val_convert_to(cast_from, cast_to, scope, resolution, node);
	}
	if(ast_is_expr(node, ast_expr_tag.blkinit))
	{
		return val_blkinit(node, scope, resolution);
	}
	if(ast_is_expr(node, ast_expr_tag.call))
	{
		return val_call(node, scope, resolution);
	}
	psyc_panic_begin(node->loc);
	putzstr("control reached end of val_node");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

// get a value from a symbol reference.
val_symbol ::= func(node : ast?, scope : lexical_scope?, resolution : val_resolution -> val)
{
	sym ::= node->symbol;
	// could be:
	// a variable name
	// a function name
	// an asm name
	// a builtin
	ret : val mut := zero;

	maybe_variable ::= scope_find_variable(scope, sym.data, sym.len);
	if(maybe_variable != zero)
	{
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(maybe_variable->type);
		}
		ret = variable_as_val(maybe_variable, node);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(ret, scope, node);
		}
		return ret;
	}
	maybe_function ::= scope_find_function(scope, sym.data, sym.len);
	if(maybe_function != zero)
	{
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(maybe_function->type);
		}
		ret = function_as_val(maybe_function, node);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(ret, scope, node);
		}
		return ret;
	}
	maybe_asm ::= scope_find_assembly(scope, sym.data, sym.len);
	if(maybe_asm != zero)
	{
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(maybe_asm->type);
		}
		ret = assembly_as_val(maybe_asm, node);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(ret, scope, node);
		}
		return ret;
	}
	maybe_builtin ::= builtin_find(sym.data, sym.len);
	if(maybe_builtin != zero)
	{
		return builtin_as_val(maybe_builtin);
	}
	maybe_enum ::= scope_find_enumeration(scope, sym.data, sym.len);
	if(maybe_enum != zero)
	{
		return type_as_val(maybe_enum->type);
	}
	psyc_error_begin(node->loc);
	putzstr("unknown symbol ");
	putchar('"');
	putbytes(sym.data, sym.len);
	putchar('"');
	putchar(10);
	ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

val_ptr_field ::= func(lhs : val, rhs_node : ast?, scope : lexical_scope mut?, resolution : val_resolution -> val)
{
	// todo: source should be the lhs node not the rhs one. any error message generated will be misleading.
	return val_field(val_deref(lhs, resolution, scope, rhs_node), rhs_node, scope, resolution);
};

val_field ::= func(lhs : val, rhs_node : ast?, scope : lexical_scope mut?, resolution : val_resolution -> val)
{
	type ::= lhs.type;
	// lhs must be a struct type
	if((!ty_is_struct(type)) && (!ty_is_enum(type)))
	{
		psyc_error_begin(rhs_node->loc);
		putzstr("lhs of field expression must be a struct or enum type. in this case it is a ");
		putchar('"');
		putty(type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(rhs_node->loc.file)->src, rhs_node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	retval : val mut := zero;
	if(ast_is_expr(rhs_node, ast_expr_tag.symbol))
	{
		memidx : u64 mut;
		if(ty_is_enum(type))
		{
			// the lhs is of enum type but it needs to be a type_only - thats what val_symbol would return on the enum typename itself
			// but if the val_symbol got a variable that was of enum type then we would want to error out on that
			if(lhs.tag != (valtag.type_only))
			{
				psyc_error_begin(rhs_node->loc);
				putzstr("lhs of field expression was a value of enum type ");
				putchar('"');
				putty(type);
				putchar('"');
				putzstr(", expected it to either be a value of struct-type or an the actual enum typename itself");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(rhs_node->loc.file)->src, rhs_node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			if(resolution == (val_resolution.type_only))
			{
				return type_as_val(type);
			}
			// enum has a much simpler codepath
			memidx = ty_get_enum_entry_id(type, rhs_node->symbol.data, rhs_node->symbol.len);
			if(memidx == -1)
			{
				psyc_error_begin(rhs_node->loc);
				putzstr("enum type ");
				putchar('"');
				putty(type);
				putchar('"');
				putzstr(" had no such member named ");
				putchar('"');
				putbytes(rhs_node->symbol.data, rhs_node->symbol.len);
				putchar('"');
				putchar(10);
				ast_print_annotated_source(program_find_source_file(rhs_node->loc.file)->src, rhs_node, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			entry_value_int ::= deref(ty_unwrap(type)->enm.entries # memidx);
			retval = integer_as_val(entry_value_int);
			retval.type = type;
			if(resolution == (val_resolution.runtime_only))
			{
				return val_dynamic(retval, scope, rhs_node);
			}
			return retval;
		}
		// it must be a struct then
		memidx = ty_get_struct_member_id(type, rhs_node->symbol.data, rhs_node->symbol.len);
		if(memidx == -1)
		{
			psyc_error_begin(rhs_node->loc);
			putzstr("struct type ");
			putchar('"');
			putty(type);
			putchar('"');
			putzstr(" had no such member named ");
			putchar('"');
			putbytes(rhs_node->symbol.data, rhs_node->symbol.len);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(rhs_node->loc.file)->src, rhs_node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		memty : tyid mut := deref(ty_unwrap(type)->strct.members # memidx);
		// let's do it at compile time!
		// remember to maintain qualifiers
		if(ty_has_qual(lhs.type, tyqual.qual_static))
		{
			memty = ty_set_qual(memty, tyqual.qual_static);
		}
		if(ty_has_qual(lhs.type, tyqual.qual_mut))
		{
			memty = ty_set_qual(memty, tyqual.qual_mut);
		}
		if(resolution == (val_resolution.type_only))
		{
			return type_as_val(memty);
		}
		
		lhs_is_static_struct_literal ::= lhs.compile_time.members != zero;
		if(lhs.known == (valknown.compile_time) && lhs_is_static_struct_literal && (resolution != (val_resolution.runtime_only)))
		{
			retval = deref(lhs.compile_time.members@val? # memidx);
			retval.type = memty;
		}
		// do it at runtime
		if(resolution == (val_resolution.compile_time_only))
		{
			psyc_error_begin(rhs_node->loc);
			putzstr("this field expression is in a context that must be evaluated at compile-time, but the operand is not statically-known");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(rhs_node->loc.file)->src, rhs_node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		return cg_field(val_dynamic(lhs, scope, rhs_node), memidx);
	}
	psyc_error_begin(rhs_node->loc);
	putzstr("rhs of field expression must be a symbol expression or a call");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(rhs_node->loc.file)->src, rhs_node, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	
	return zero;
};

val_unop ::= func(op : ast_unop, v : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	if(op == (ast_unop.reference))
	{
		return val_unop_ref(v, scope, resolution, source);
	}
	if(op == (ast_unop.minus))
	{
		return val_unop_minus(v, scope, resolution, source);
	}
	if(op == (ast_unop.bitwise_invert))
	{
		return val_unop_bitwise_invert(v, scope, resolution, source);
	}
	if(op == (ast_unop.logical_invert))
	{
		return val_unop_logical_invert(v, scope, resolution, source);
	}
	psyc_panic_begin(source->loc);
	putzstr("control reached end of val_unop for val_unop.");
	putzstr(__enumname(op));
	putzstr(" (");
	putsint(op@s64);
	putzstr(")");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();

	return zero;
};

val_unop_ref ::= func(v : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(ty_ptr(v.type, zero));
	}
	if(v.hand != (valhand.lvalue))
	{
		psyc_error_begin(source->loc);
		putzstr("can only create a reference to an lvalue");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.known == (valknown.compile_time))
	{
		// compile time
		ret ::= ref_as_val(v, source);

		if(resolution == (val_resolution.runtime_only))
		{
			// convert to runtime value
			return val_dynamic(ret, scope, source);
		}
		return ret;
	}
	if(resolution == (val_resolution.compile_time_only))
	{
		psyc_error_begin(source->loc);
		putzstr("this 'ref' unary operator is in a context that must be evaluated at compile-time, but the operand is not statically-known");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// runtime
	return cg_ref(val_dynamic(v, scope, source), source);
};

val_unop_minus ::= func(v : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	// should be a floating point or integral type
	if((!ty_is_integral(v.type)) && (!ty_is_floating_point(v.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("unary 'minus' (-) operator requires an integral or floating-point operand. you have provided a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(v.type);
	}
	retval : val mut := v;
	if(v.known == (valknown.compile_time))
	{
		// compile time
		retval = s_unop_minus(v, scope, source);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(retval, scope, source);
		}
		return retval;
	}
	// runtime
	return cg_unop_minus(v, source);
};

val_unop_bitwise_invert ::= func(v : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	// should be an integral type
	if((!ty_is_integral(v.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("unary 'bitwise invert' (~) operator requires an integral operand. you have provided a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(v.type);
	}
	retval : val mut := v;
	if(v.known == (valknown.compile_time))
	{
		// compile time
		retval = s_unop_bitwise_invert(v, scope, source);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(retval, scope, source);
		}
		return retval;
	}
	// runtime
	return cg_unop_bitwise_invert(v, source);
};

val_unop_logical_invert ::= func(v : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	// should be a boolean type
	if((!ty_is_bool(v.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("unary 'logical invert' (!) operator requires a boolean operand. you have provided a ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(v.type);
	}
	retval : val mut := v;
	if(v.known == (valknown.compile_time))
	{
		// compile time
		retval = s_unop_logical_invert(v, scope, source);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(retval, scope, source);
		}
		return retval;
	}
	// runtime
	return cg_unop_logical_invert(v, source);
};

val_biop ::= func(op : ast_biop_op, lhs : val mut, rhs : val mut, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	// in a biop, 'zero' is always handled the same way
	if(val_is_zero_val(lhs) && val_is_zero_val(rhs))
	{
		psyc_error_begin(source->loc);
		putzstr("both sides of a binary operation cannot be 'zero', as there is no way to determine the resultant type");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(val_is_zero_val(lhs))
	{
		lhs = zero_as_val(rhs.type, source);
	}
	if(val_is_zero_val(rhs))
	{
		rhs = zero_as_val(lhs.type, source);
	}
	if(op == (ast_biop_op.assign))
	{
		return val_biop_assign(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.compare_equal))
	{
		return val_biop_compare_equal(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.compare_not_equal))
	{
		return val_biop_compare_not_equal(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.compare_less))
	{
		return val_biop_compare_less(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.compare_less_equal))
	{
		return val_biop_compare_less_equal(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.compare_greater))
	{
		return val_biop_compare_greater(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.compare_greater_equal))
	{
		return val_biop_compare_greater_equal(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.add))
	{
		return val_biop_add(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.sub))
	{
		return val_biop_sub(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.mul))
	{
		return val_biop_mul(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.div))
	{
		return val_biop_div(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.bitwise_or))
	{
		return val_biop_bitwise_or(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.bitwise_and))
	{
		return val_biop_bitwise_and(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.logical_or))
	{
		return val_biop_logical_or(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.logical_and))
	{
		return val_biop_logical_and(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.xor))
	{
		return val_biop_xor(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.bitshift_left))
	{
		return val_biop_bitshift_left(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.bitshift_right))
	{
		return val_biop_bitshift_right(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.modulo))
	{
		return val_biop_modulo(lhs, rhs, scope, resolution, source);
	}
	if(op == (ast_biop_op.at))
	{
		return val_biop_at(lhs, rhs, scope, resolution, source);
	}
	psyc_panic_begin(source->loc);
	putzstr("control reached end of val_biop for val_biop.");
	putzstr(__enumname(op));
	putzstr(" (");
	putsint(op@s64);
	putzstr(")");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();

	return zero;
};

val_biop_assign ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	if(lhs.hand != (valhand.lvalue))
	{
		psyc_error_begin(source->loc);
		putzstr("lhs of assignment must always be an lvalue");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// todo: extra checks if static?
	if(!ty_has_qual(lhs.type, tyqual.qual_mut))
	{
		psyc_error_begin(source->loc);
		putzstr("cannot assign to non-mut type ");
		putchar('"');
		putty(lhs.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// rhs must convert to lhs
	rhsconv ::= val_convert_to(rhs, lhs.type, scope, resolution, source);
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(lhs.type);
	}
	need_runtime_conversion ::= (lhs.known != rhsconv.known) || (((lhs.known != (valknown.runtime)) || (rhs.known != (valknown.runtime))) && (resolution == (val_resolution.runtime_only)));
	if(need_runtime_conversion)
	{
		// one of them is runtime or we are runtime_only
		// do it runtime mode.
		return val_biop_assign(val_dynamic(lhs, scope, source), val_dynamic(rhsconv, scope, source), scope, resolution, source);
	}
	if(lhs.known == (valknown.compile_time))
	{
		lhs_is_variable ::= (lhs.compile_time.varref_name != zero);
		// at compile time we can only do an assignment to a variable directly (not e.g to an array element im afraid)
		if(!lhs_is_variable)
		{
			// do it runtime mode.
			return val_biop_assign(val_dynamic(lhs, scope, source), val_dynamic(rhsconv, scope, source), scope, resolution, source);
		}
		return s_biop_assign(lhs, rhsconv, scope, source);
	}
	// runtime
	return cg_biop_assign(val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), source);
};

val_arith_biop ::= func(op : ast_biop_op, lhs : val, rhs : val, allow_pointers : bool, scope : lexical_scope mut?, resolution : val_resolution, source : ast?, s : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val), cg : func(lhs : val, rhs : val, source : ast? -> val) -> val)
{
	type : tyid mut := ty_of_arithmetic(lhs.type, rhs.type);
	if(type == zero)
	{
		if(allow_pointers && ((ty_is_enum(lhs.type) && ty_is_enum(rhs.type)) || (ty_is_ptr(lhs.type) && ty_is_ptr(rhs.type))))
		{
			// if both are pointers or enums then just defer to lhs's type and hope they're comparable
			type = lhs.type;
		}
		else
		{
			psyc_error_begin(source->loc);
			putzstr("cannot perform the '");
			putzstr(__enumname(op));
			putzstr("' operator on a ");
			putchar('"');
			putty(lhs.type);
			putchar('"');
			putzstr(" and ");
			putchar('"');
			putty(rhs.type);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
	lhsconv ::= val_convert_to(lhs, type, scope, resolution, source);
	rhsconv ::= val_convert_to(rhs, type, scope, resolution, source);
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(type);
	}
	need_runtime_conversion ::= (lhs.known != rhsconv.known) || (((lhs.known != (valknown.runtime)) || (rhs.known != (valknown.runtime))) && (resolution == (val_resolution.runtime_only)));
	if(need_runtime_conversion)
	{
		// one of them is runtime or we are runtime_only
		// do it runtime mode.
		return val_arith_biop(op, val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), allow_pointers, scope, resolution, source, s, cg);
	}
	// guaranteed that their knowns are the same
	if(lhs.known == (valknown.compile_time))
	{
		// compile time
		return s(lhsconv, rhsconv, scope, source);
	}
	// runtime
	if(resolution == (val_resolution.compile_time_only))
	{
		psyc_error_begin(source->loc);
		putzstr("this '");
		putzstr(__enumname(op));
		putzstr("' binary operator is in a context that must be evaluated at compile-time, but both operands are not statically-known");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// runtime
	return cg(val_dynamic(lhsconv, scope, source), val_dynamic(rhsconv, scope, source), source);
};

// a bit like val_arith_biop but always returns a boolean, not ty_arithmetic_of
val_compare_biop ::= func(op : ast_biop_op, lhs : val, rhs : val, allow_pointers : bool, scope : lexical_scope mut?, resolution : val_resolution, source : ast?, s : func(lhs : val, rhs : val, scope : lexical_scope mut?, source : ast? -> val), cg : func(lhs : val, rhs : val, source : ast? -> val) -> val)
{
	type : tyid mut := ty_of_arithmetic(lhs.type, rhs.type);
	if(type == zero)
	{
		if(allow_pointers && ((ty_is_enum(lhs.type) && ty_is_enum(rhs.type)) || (ty_is_ptr(lhs.type) && ty_is_ptr(rhs.type))))
		{
			// if both are pointers or enums then just defer to lhs's type and hope they're comparable
			type = lhs.type;
		}
		else
		{
			psyc_error_begin(source->loc);
			putzstr("cannot perform the '");
			putzstr(__enumname(op));
			putzstr("' operator on a ");
			putchar('"');
			putty(lhs.type);
			putchar('"');
			putzstr(" and ");
			putchar('"');
			putty(rhs.type);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
	lhsconv ::= val_convert_to(lhs, type, scope, resolution, source);
	rhsconv ::= val_convert_to(rhs, type, scope, resolution, source);
	if(resolution == (val_resolution.type_only))
	{
		if((lhs.known == (valknown.compile_time)) && (rhs.known == (valknown.compile_time)))
		{
			return type_as_val(ty_set_qual(tyid.bool, tyqual.qual_static));
		}
		return type_as_val(tyid.bool);
	}
	need_runtime_conversion ::= (lhs.known != rhsconv.known) || (((lhs.known != (valknown.runtime)) || (rhs.known != (valknown.runtime))) && (resolution == (val_resolution.runtime_only)));
	if(need_runtime_conversion)
	{
		// one of them is runtime or we are runtime_only
		// do it runtime mode.
		return val_compare_biop(op, val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), allow_pointers, scope, resolution, source, s, cg);
	}
	// guaranteed that their knowns are the same
	if(lhs.known == (valknown.compile_time))
	{
		// compile time
		return s(lhsconv, rhsconv, scope, source);
	}
	// runtime
	if(resolution == (val_resolution.compile_time_only))
	{
		psyc_error_begin(source->loc);
		putzstr("this '");
		putzstr(__enumname(op));
		putzstr("' binary operator is in a context that must be evaluated at compile-time, but both operands are not statically-known");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// runtime
	return cg(val_dynamic(lhsconv, scope, source), val_dynamic(rhsconv, scope, source), source);
};

val_biop_add ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.add, lhs, rhs, false, scope, resolution, source, s_biop_add, cg_biop_add);
};

val_biop_sub ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.sub, lhs, rhs, false, scope, resolution, source, s_biop_sub, cg_biop_sub);
};

val_biop_mul ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.mul, lhs, rhs, false, scope, resolution, source, s_biop_mul, cg_biop_mul);
};

val_biop_div ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.div, lhs, rhs, false, scope, resolution, source, s_biop_div, cg_biop_div);
};

val_biop_bitwise_or ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.bitwise_or, lhs, rhs, true, scope, resolution, source, s_biop_bitwise_or, cg_biop_bitwise_or);
};

val_biop_bitwise_and ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.bitwise_and, lhs, rhs, true, scope, resolution, source, s_biop_bitwise_and, cg_biop_bitwise_and);
};

val_biop_logical_or ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	if(!(ty_is_bool(lhs.type) && ty_is_bool(rhs.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("both operands of a logical_or (||) operator must be booleans. you have provided a ");
		putchar('"');
		putty(lhs.type);
		putchar('"');
		putzstr(" and a ");
		putchar('"');
		putty(rhs.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		if((lhs.known == (valknown.compile_time)) && (rhs.known == (valknown.compile_time)))
		{
			return type_as_val(ty_set_qual(tyid.bool, tyqual.qual_static));
		}
		return type_as_val(tyid.bool);
	}
	need_runtime_conversion ::= (lhs.known != rhs.known) || (((lhs.known != (valknown.runtime)) || (rhs.known != (valknown.runtime))) && (resolution == (val_resolution.runtime_only)));
	if(need_runtime_conversion)
	{
		// one of them is runtime or we are runtime_only
		// do it runtime mode.
		return val_biop_logical_or(val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), scope, resolution, source);
	}
	// guaranteed that their knowns are the same
	if(lhs.known == (valknown.compile_time))
	{
		// compile time
		return s_biop_logical_or(lhs, rhs, scope, source);
	}
	// runtime
	return cg_biop_logical_or(val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), source);
};

val_biop_logical_and ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	if(!(ty_is_bool(lhs.type) && ty_is_bool(rhs.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("both operands of a logical_and (&&) operator must be booleans. you have provided a ");
		putchar('"');
		putty(lhs.type);
		putchar('"');
		putzstr(" and a ");
		putchar('"');
		putty(rhs.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		if((lhs.known == (valknown.compile_time)) && (rhs.known == (valknown.compile_time)))
		{
			return type_as_val(ty_set_qual(tyid.bool, tyqual.qual_static));
		}
		return type_as_val(tyid.bool);
	}
	need_runtime_conversion ::= (lhs.known != rhs.known) || (((lhs.known != (valknown.runtime)) || (rhs.known != (valknown.runtime))) && (resolution == (val_resolution.runtime_only)));
	if(need_runtime_conversion)
	{
		// one of them is runtime or we are runtime_only
		// do it runtime mode.
		return val_biop_logical_and(val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), scope, resolution, source);
	}
	// guaranteed that their knowns are the same
	if(lhs.known == (valknown.compile_time))
	{
		// compile time
		return s_biop_logical_and(lhs, rhs, scope, source);
	}
	// runtime
	return cg_biop_logical_and(val_dynamic(lhs, scope, source), val_dynamic(rhs, scope, source), source);
};

val_biop_xor ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.xor, lhs, rhs, false, scope, resolution, source, s_biop_xor, cg_biop_xor);
};

val_biop_bitshift_left ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.bitshift_left, lhs, rhs, false, scope, resolution, source, s_biop_bitshift_left, cg_biop_bitshift_left);
};

val_biop_bitshift_right ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_arith_biop(ast_biop_op.bitshift_right, lhs, rhs, false, scope, resolution, source, s_biop_bitshift_right, cg_biop_bitshift_right);
};

val_biop_modulo ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	if(ty_is_floating_point(ty_of_arithmetic(lhs.type, rhs.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("modulo operations are not allowed on floating-point types");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return val_arith_biop(ast_biop_op.modulo, lhs, rhs, false, scope, resolution, source, s_biop_modulo, cg_biop_modulo);
};

val_biop_at ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	// lhs must be either an array or pointer
	if((!ty_is_ptr(lhs.type)) && (!ty_is_arr(lhs.type)))
	{
		psyc_error_begin(source->loc);
		putzstr("lhs of the 'at' (#) operator must be either a pointer or array type, you have passed a ");
		putchar('"');
		putty(lhs.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// cool
	retty : tyid mut := ty_ptr(ty_underlying(lhs.type), zero);
	// what qualifiers get carried over?
	// for now, nothing
	// note: this would need to be reflected in cg_biop_at if you change retty.

	// rhs must be an integral type
	if(!ty_is_integral(rhs.type))
	{
		psyc_error_begin(source->loc);
		putzstr("rhs of the 'at' (#) operator must be an integral type, you have passed a ");
		putchar('"');
		putty(rhs.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(retty);
	}
	// if both values are known at compile-time, then we will do a compile-time transformation
	is_doable_at_compile_time : bool mut := (lhs.known == (valknown.compile_time)) && (rhs.known == (valknown.compile_time));
	// but if its a pointer value via 'ref' then we cant do it at compile time
	if(lhs.compile_time.valueref != zero)
	{
		is_doable_at_compile_time = false;
	}
	if(is_doable_at_compile_time)
	{
		rhs_index ::= val_must_get_integer(rhs, scope, source);
		if(ty_is_arr(lhs.type))
		{
			// cool just return the element.
			return val_convert_to(deref(lhs.compile_time.members@val? # rhs_index), retty, scope, resolution, source);
		}
		// todo: remove this panic when cg_sizeof is allowed to be done at compile time (requires cg_begin to be called ealier)
		psyc_panic_begin(source->loc);
		putzstr("support for 'at' expressions of pointers derived from integer literals is not properly implemented. please submit a feature request if supporting this is important to you");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
		// ok its a pointer
		// we know its not a valueref so we can assume its a literal address (pointer arithmetic)
		address ::= rhs.compile_time.primitive.integer;
		// add sizeof(lhs) * rhs_index
		sizeof_lhs ::= val_must_get_integer(cg_sizeof(lhs.type), scope, source);
		// this is a pointer compile-time value as an address (integer literal under-the-hood) whose address has been manually offsetted.
		return s_convert_to(integer_as_val(address + (rhs_index * sizeof_lhs)), retty, source);
	}
	// otherwise it must be a runtime thing.
	return cg_biop_at(lhs, rhs, source);
};

val_biop_compare_equal ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_compare_biop(ast_biop_op.compare_equal, lhs, rhs, true, scope, resolution, source, s_biop_compare_equal, cg_biop_compare_equal);
};

val_biop_compare_not_equal ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_compare_biop(ast_biop_op.compare_not_equal, lhs, rhs, true, scope, resolution, source, s_biop_compare_not_equal, cg_biop_compare_not_equal);
};

val_biop_compare_less ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_compare_biop(ast_biop_op.compare_less, lhs, rhs, true, scope, resolution, source, s_biop_compare_less, cg_biop_compare_less);
};

val_biop_compare_less_equal ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_compare_biop(ast_biop_op.compare_less_equal, lhs, rhs, true, scope, resolution, source, s_biop_compare_less_equal, cg_biop_compare_less_equal);
};

val_biop_compare_greater ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_compare_biop(ast_biop_op.compare_greater, lhs, rhs, true, scope, resolution, source, s_biop_compare_greater, cg_biop_compare_greater);
};

val_biop_compare_greater_equal ::= func(lhs : val, rhs : val, scope : lexical_scope?, resolution : val_resolution, source : ast? -> val)
{
	return val_compare_biop(ast_biop_op.compare_greater_equal, lhs, rhs, true, scope, resolution, source, s_biop_compare_greater_equal, cg_biop_compare_greater_equal);
};

val_deref ::= func(v : val, resolution : val_resolution, scope : lexical_scope mut?, source : ast? -> val)
{
	if(!ty_is_ptr(v.type))
	{
		psyc_error_begin(source->loc);
		putzstr("cannot dereference a value of non-pointer type ");
		putchar('"');
		putty(v.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(ty_underlying(v.type));
	}
	has_valueref ::= v.compile_time.valueref != zero;
	if(v.known == (valknown.compile_time) && has_valueref)
	{
		// compile time
		// we COULD have a valueref
		if(v.compile_time.valueref != zero)
		{
			// yep we have a direct match.
			ret ::= deref(v.compile_time.valueref@val?);
			if(resolution == (val_resolution.runtime_only))
			{
				return val_dynamic(ret, scope, source);
			}
			return ret;
		}
	}
	if(resolution == (val_resolution.compile_time_only) && !has_valueref)
	{
		psyc_error_begin(source->loc);
		putzstr("dereference operator exists in a context that must be evaluated at compile-time, but the dereference cannot be performed at compile-time unless it was created directly via 'ref something'");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// need to do it at runtime.
	return cg_deref(val_dynamic(v, scope, source), source);
};

val_blkinit ::= func(node : ast?, scope : lexical_scope mut?, resolution : val_resolution -> val)
{
	i : u64 mut;
	// todo: array support
	// (will also need to supprot arrays in s/cg functions called here too)
	typename_node ::= ast_get_child(node, 0);
	inittype ::= ty_typename_node(typename_node, scope);
	if(!(ty_is_struct(inittype) || (ty_is_arr(inittype))))
	{
		psyc_error_begin(node->loc);
		putzstr("block-initialiser type must be a struct (todo: or array)");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(typename_node->loc.file)->src, typename_node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	retval : val mut := zero;
	if(resolution == (val_resolution.compile_time_only))
	{
		// compile time
		retval = s_empty_blkinit(inittype);
		// how do we want to handle accessing undef values (via blkinits) at compile time?
		// error out would be ideal, but just setting them all as zero-value here would be easier
	}
	else
	{
		if(resolution == (val_resolution.type_only))
		{
			// nothing (we could just return type_as_val(inittype)) here but then we dont typecheck the desiginits...
		}
		else
		{
			// runtime
			retval = cg_empty_blkinit(inittype);
		}
	}
	// child 0 is the type
	// child 1-N are the desiginits
	init_count ::= node->children_count - 1;
	for(i = 0, i < init_count, i = i + 1)
	{
		child ::= ast_get_child(node, i + 1);
		desig ::= child->desiginit;
		init_value : val mut := val_node(ast_get_child(child, 0), scope, resolution);
		memidx : u64 mut := 0;
		if(ty_is_struct(inittype))
		{
			if(desig.descriptor != (ast_desiginit_descriptor.symbol))
			{
				psyc_error_begin(child->loc);
				putzstr("all initialisers for struct type ");
				putchar('"');
				putty(inittype);
				putchar('"');
				putzstr(" must be symbols (names), not integers");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			memidx = ty_get_struct_member_id(inittype, desig.symbol, desig.symbol_len);
			if(memidx == -1)
			{
				psyc_error_begin(child->loc);
				putzstr("type of block initialiser ");
				putchar('"');
				putty(inittype);
				putchar('"');
				putzstr(" had no such member named ");
				putchar('"');
				putbytes(desig.symbol, desig.symbol_len);
				putchar('"');
				putchar(10);
				ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
		}
		else
		{
			if(desig.descriptor != (ast_desiginit_descriptor.integer))
			{
				psyc_error_begin(child->loc);
				putzstr("all initialisers for array type ");
				putchar('"');
				putty(inittype);
				putchar('"');
				putzstr(" must be integers, not symbols (names)");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			memidx = (desig.integer@_);
			if(memidx >= (ty_unwrap(inittype)->array_len))
			{
				psyc_error_begin(child->loc);
				putzstr("initialiser index ");
				putchar('"');
				putuint(memidx);
				putchar('"');
				putzstr(" is out-of-range of array type ");
				putchar('"');
				putty(inittype);
				putchar('"');
				putchar(10);
				ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
		}
		// also we have a thing to check
		// an empty blkinit is obviously evaluable at compile time
		// a non-empty blkinit is also evluable at compile time iff every initialiser is also evaluable at compile time
		// so if we're in a compile-time context and we see an initialiser value that is not compile time
		// the whole thing needs to swap to being done at runtime.
		// (but if we are type-only then we dont care about any of this anyway)
		if(init_value.known != (valknown.compile_time) && (resolution != (val_resolution.type_only)))
		{
			if(resolution == (val_resolution.compile_time_only))
			{
				psyc_error_begin(child->loc);
				putzstr("block initialiser is in a context such that it must be evaluated at compile-time, but the initialiser cannot be evaluted at compile-time");
				putchar(10);
				ast_print_annotated_source(program_find_source_file(child->loc.file)->src, child, 1, underline_colour.red);
				psyc_diag_end();
				psyc_exit_failure();
			}
			retval = val_dynamic(retval, scope, child);
		}
		to : tyid mut;
		if(ty_is_struct(inittype))
		{
			to = deref(ty_unwrap(inittype)->strct.members # memidx);
		}
		else
		{
			to = ty_underlying(inittype);
		}
		if(val_is_zero_val(init_value))
		{
			init_value = zero_as_val(to, child);
		}
		else
		{
			init_value = val_convert_to(init_value, to, scope, resolution, child);
		}

		// add it to the blkinit
		if(resolution != (val_resolution.type_only))
		{
			if(retval.known == (valknown.compile_time))
			{
				retval = s_blkinit_add(retval, memidx, init_value);
			}
			else
			{
				retval = cg_blkinit_add(retval, memidx, val_dynamic(init_value, scope, child));
			}
		}
	}

	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(inittype);
	}
	return retval;
};

val_call ::= func(node : ast?, scope : lexical_scope mut?, resolution : val_resolution mut -> val)
{
	callee_node ::= ast_get_child(node, 0);
	callee_val ::= val_node(callee_node, scope, resolution);
	// make sure the callee is callable
	if(!ty_is_fn(callee_val.type))
	{
		psyc_error_begin(node->loc);
		putzstr("cannot call non-function type ");
		putchar('"');
		putty(callee_val.type);
		putchar('"');
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
		return zero;
	}

	fty ::= ty_unwrap(callee_val.type)->fn;
	call_param_count ::= node->children_count - 1;
	if(call_param_count != (fty.params_count))
	{
		psyc_error_begin(node->loc);
		putzstr("callable expects ");
		putuint(fty.params_count);
		putzstr(" args but you have passed ");
		putuint(call_param_count);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	
	old_resolution ::= resolution;
	is_builtin ::= callee_val.compile_time.builtinref_name != zero;
	if(is_builtin && (resolution != (val_resolution.compile_time_only)))
	{
		resolution = (val_resolution.runtime_or_compile_time);
	}
	vals : val mut? := __stack_push(__sizeof(val) * call_param_count);
	i : u64 mut;
	for(i = 0, i < call_param_count, i = i + 1)
	{
		param_node ::= ast_get_child(node, i + 1);
		param_val ::= val_convert_to(val_node(param_node, scope, resolution), deref(fty.param_types # i), scope, resolution, param_node);
		deref(vals # i) = param_val;
	}

	if(resolution == (val_resolution.type_only))
	{
		return type_as_val(fty.return_type);
	}
	if(is_builtin)
	{
		// ah this is a builtin
		the_builtin ::= builtin_find(callee_val.compile_time.builtinref_name, callee_val.compile_time.builtinref_name_len);
		if(old_resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(builtin_invoke(deref(the_builtin), vals, scope, resolution, node), scope, node);
		}
		return builtin_invoke(deref(the_builtin), vals, scope, resolution, node);
	}
	// todo: static callables?
	return cg_call(val_dynamic(callee_val, scope, node), vals, scope, node);
};

val_convert_to ::= func(v : val, to : tyid, scope : lexical_scope mut?, resolution : val_resolution, source : ast? -> val)
{
	if(resolution == (val_resolution.type_only))
	{
		if(!val_is_zero_val(v))
		{
			ty_ensure_convertible_to(v.type, to, source);
		}
		return type_as_val(to);
	}
	// check for zero-ness
	if(v.tag == (valtag.value_only))
	{
		if(val_is_zero_val(v))
		{
			if(resolution == (val_resolution.runtime_only))
			{
				return val_dynamic(zero_as_val(to, source), scope, source);
			}
			return zero_as_val(to, source);
		}
		// what? value_only but not zero?
		psyc_panic_begin(source->loc);
		putzstr("attempt to convert the following non-typed-value to type ");
		putchar('"');
		putty(to);
		putchar('"');
		putzstr(":");
		putchar(10);
		putval(v);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	ty_ensure_convertible_to(v.type, to, source);
	if(v.tag != (valtag.typed_value))
	{
		// either invalid value or type-only
		psyc_panic_begin(source->loc);
		putzstr("expected a typed-value when converting from a value to type ");
		putchar('"');
		putty(to);
		putchar('"');
		putzstr(":");
		putchar(10);
		putval(v);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	// ok at this point we definitely should have 2 perfectly valid types.
	// so we are about to split off to runtime and compile-time code paths

	// todo HH: sometimes a conversion will be requested but in a context that *only* supports compile time
	// so in that case a runtime requirement should be an error i.e "cannot perform this conversion at compile time"
	// example: a function-type static value that is a function-reference under the hood
	// e.g 'symbol expression 'foo' (where foo is a function)' but not '500@func(-> v0)'
	v_is_static_function_reference ::= (ty_is_fn(v.type)) && (v.known == (valknown.compile_time) && (v.compile_time.funcref_name != zero));
	if(v.known == (valknown.compile_time) && !v_is_static_function_reference)
	{
		// compile time transformation
		static_return ::= s_convert_to(v, to, source);
		if(resolution == (val_resolution.runtime_only))
		{
			return val_dynamic(static_return, scope, source);
		}
		return static_return;
	}
	// runtime transformation
	if(resolution == (val_resolution.compile_time_only))
	{
		psyc_error_begin(source->loc);
		putzstr("the following conversion to type ");
		putchar('"');
		putty(to);
		putchar('"');
		putzstr(" must be done at compile-time, but cannot:");
		putchar(10);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return cg_convert_to(val_dynamic(v, scope, source), to, source);
};

val_dynamic ::= func(v : val, scope : lexical_scope mut?, source : ast? -> val)
{
	// pass any val into here and the result is guaranteed to be a runtime-computed value
	if(v.known == (valknown.runtime))
	{
		return v;
	}
	// this will be a long list...
	if(val_is_zero_val(v))
	{
		psyc_panic_begin(source->loc);
		putzstr("attempt to val_dynamic 'zero'. doesnt work like that, need to call zero_as_val im afraid...");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.compile_time.funcref_name != zero)
	{
		// its a refernce to a function (or assembly)
		maybe_fn ::= scope_find_function(scope, v.compile_time.funcref_name, v.compile_time.funcref_name_len);
		if(maybe_fn != zero)
		{
			return cg_funcref(maybe_fn);
		}
		maybe_asm ::= scope_find_assembly(scope, v.compile_time.funcref_name, v.compile_time.funcref_name_len);
		if(maybe_asm != zero)
		{
			return cg_asmref(maybe_asm);
		}
		psyc_panic_begin(source->loc);
		putzstr("couldnt figure out what v.compile_time.funcref_name = ");
		putchar('"');
		putbytes(v.compile_time.funcref_name, v.compile_time.funcref_name_len);
		putchar('"');
		putzstr(" referred to, but this should've been caught earlier. please submit a compiler bug report.");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
		
	}
	if(v.compile_time.varref_name != zero)
	{
		return cg_varref(scope_find_variable(scope, v.compile_time.varref_name, v.compile_time.varref_name_len));
	}
	if(v.compile_time.valueref != zero)
	{
		return cg_ref(val_dynamic(deref(v.compile_time.valueref@val?), scope, source), source);
	}
	if(v.compile_time.members != zero)
	{
		return cg_members(v, scope, source);
	}
	if(ty_is_prim(v.type) || ty_is_enum(v.type))
	{
		// its a primitive type...
		return cg_prim(v.type, v.compile_time.primitive, source);
	}
	if(ty_is_ptr(v.type) || ty_is_fn(v.type))
	{
		// its a pointer type but a non-varref/valueref etc
		// meaning that i expect it to be a string or integer literal
		if((v.compile_time.primitive.tag != (ast_literal_tag.string)) && (v.compile_time.primitive.tag != (ast_literal_tag.integer)))
		{
			psyc_panic_begin(source->loc);
			putzstr("seemingly malformed val passed to val_dynamic - its a non valueref/varref etc. pointer value at compile-time which ought to be an integer literal (address) but is not a primitive either...");
			putchar(10);
			putval(v);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
			return zero;
		}
		return cg_prim(v.type, v.compile_time.primitive, source);
	}
	if(ty_is_struct(v.type))
	{
		return cg_members(v, scope, source);
	}

	psyc_panic_begin(source->loc);
	putzstr("dont know how to val_dynamic the following:");
	putchar(10);
	putval(v);
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

putval ::= func(v : val -> v0)
{
	// val{
	// .tag := ...
	// ...
	// }
	putzstr("val{");
	putchar(10);
	putchar(9);
	putzstr(".tag := valtag.");
	putzstr(__enumname(v.tag));
	putzstr(" (");
	putsint(v.tag@s64);
	putzstr(")");

	putchar(10);
	putchar(9);
	putzstr(".known := valknown.");
	putzstr(__enumname(v.known));
	putzstr(" (");
	putsint(v.known@s64);
	putzstr(")");

	putchar(10);
	putchar(9);
	putzstr(".hand := valhand.");
	putzstr(__enumname(v.hand));
	putzstr(" (");
	putsint(v.hand@s64);
	putzstr(")");

	putchar(10);
	putchar(9);
	putzstr(".type := ");
	putty(v.type);
	putzstr(" (");
	putsint(v.type@s64);
	putzstr(")");

	putchar(10);
	putchar(9);
	putzstr(".compile_time := {");

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".is_zero := ");
	if(v.compile_time.is_zero)
	{
		putzstr("true");
	}
	else
	{
		putzstr("false");
	}
	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".primitive := ");
	if(v.compile_time.primitive.tag == zero)
	{
		putzstr("<invalid>");
	}
	if(v.compile_time.primitive.tag == (ast_literal_tag.integer))
	{
		putsint(v.compile_time.primitive.integer);
	}
	if(v.compile_time.primitive.tag == (ast_literal_tag.floating_point))
	{
		putfloat(v.compile_time.primitive.floating_point);
	}
	if(v.compile_time.primitive.tag == (ast_literal_tag.char))
	{
		putzstr("'");
		putbytes(v.compile_time.primitive.chars, v.compile_time.primitive.chars_len);
		putzstr("'");
	}
	if(v.compile_time.primitive.tag == (ast_literal_tag.string))
	{
		putchar('"');
		putbytes(v.compile_time.primitive.chars, v.compile_time.primitive.chars_len);
		putchar('"');
	}
	if(v.compile_time.primitive.tag == (ast_literal_tag.boolean))
	{
		if(v.compile_time.primitive.boolean)
		{
			putzstr("true");
		}
		else
		{
			putzstr("false");
		}
	}
	putzstr(" (");
	putzstr(__enumname(v.compile_time.primitive.tag));
	putzstr(" (");
	putsint(v.compile_time.primitive.tag@s64);
	putzstr("))");
	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".members_count := ");
	putuint(v.compile_time.members_count);

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".members := {");
	if(v.compile_time.members_count > 0)
	{
		putuint(v.compile_time.members_count);
		putzstr(" subvalues...");
		putchar(10);
		putchar(9);
	}

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".funcref_name := ");
	if(v.compile_time.funcref_name == zero)
	{
		putzstr("zero");
	}
	else
	{
		putbytes(v.compile_time.funcref_name, v.compile_time.funcref_name_len);
	}

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".funcref_name_len := ");
	putuint(v.compile_time.funcref_name_len);

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".builtinref_name := ");
	if(v.compile_time.builtinref_name == zero)
	{
		putzstr("zero");
	}
	else
	{
		putbytes(v.compile_time.builtinref_name, v.compile_time.builtinref_name_len);
	}

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".builtinref_name_len := ");
	putuint(v.compile_time.builtinref_name_len);

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr(".valueref := ");
	if(v.compile_time.valueref == zero)
	{
		putzstr("zero");
	}
	else
	{
		putzstr("<some other val>");
	}

	putchar(10);
	putchar(9);
	putchar(9);
	putzstr("}");
	
	putchar(10);
	putchar(9);
	putzstr(".runtime := LLVMValueRef(");
	putuint(v.runtime.cg);
	putzstr(")");

	putchar(10);
	putzstr("}");
	putchar(10);
};
