valtag ::= enum
{
	.s := 1;
	.d := 2;
};

sval_tag ::= enum
{
	.zero_value := 1;
	.primitive := 2;
	.pointer := 3;
	.array := 4;
	//.structure := 4;
};

sval ::= struct
{
	tag : sval_tag;
	primitive : ast_literal;
	// note: actually a val mut?
	underlying : v0? weak;
};

val ::= struct
{
	tag : valtag;
	type : tyid;
	s : sval;
	cg : u64;
};

val_is_valid ::= func(v : val -> bool)
{
	return v.tag != zero;
};

val_node ::= func(node : ast? -> val)
{
	if(ast_is_expr(node, ast_expr_tag.literal))
	{
		return literal_as(node->literal);
	}
	if(ast_is_expr(node, ast_expr_tag.unop))
	{
		operand ::= val_node(ast_get_child(node, 0));
		return val_unop(node->unop, ref operand, node);
	}
	if(ast_is_expr(node, ast_expr_tag.biop))
	{
		lhs ::= val_node(ast_get_child(node, 0));
		rhs ::= val_node(ast_get_child(node, 1));
		return val_biop(node->biop, ref lhs, ref rhs, node);
	}
	if(ast_is_expr(node, ast_expr_tag.cast))
	{
		cast_from_val : val mut := val_node(ast_get_child(node, 0));
		cast_from_val.type = ty_set_qual(cast_from_val.type, tyqual.qual_weak);
		cast_to_node ::= ast_get_child(node, 1);
		if(ast_is_weakness_idiom(cast_to_node))
		{
			// its the weakness idiom! i.e foo@_
			// no need to do a conversion.
			return cast_from_val;
		}
		return val_convert_to(cast_from_val, ty_node(cast_to_node), node);
	}
	if(ast_is_expr(node, ast_expr_tag.call))
	{
		psyc_nyi(node->loc);
	}
	if(ast_is_expr(node, ast_expr_tag.field))
	{
		psyc_nyi(node->loc);
	}
	psyc_panic_begin(node->loc);
	putzstr("control reached end of val_node");
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

val_unop ::= func(op : ast_unop, v : val mut?, source : ast? -> val)
{
	s ::= v->tag == (valtag.s);
	// check for 'ref' as this one has special functionality
	if(op == (ast_unop.reference))
	{
		if(s)
		{
			return s_ref(v, source);
		}
		else
		{
			return cg_ref(v, source);
		}
	}
	if(ty_is_integral(v->type))
	{
		if(s)
		{
			return s_integral_unop(op, v, source);
		}
		else
		{
			return cg_integral_unop(op, v, source);
		}
	}
	if(ty_is_floating_point(v->type))
	{
		if(s)
		{
			return s_floating_point_unop(op, v, source);
		}
		else
		{
			return cg_floating_point_unop(op, v, source);
		}
	}
	if(ty_is_bool(v->type))
	{
		if(s)
		{
			return s_bool_unop(op, v, source);
		}
		else
		{
			return cg_bool_unop(op, v, source);
		}
	}
	psyc_error_begin(source->loc);
	putzstr("cannot perform unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a ");
	putty(v->type);
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

val_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, source : ast? -> val)
{
	lhs_s ::= lhs->tag == (valtag.s);
	rhs_s ::= rhs->tag == (valtag.s);
	s ::= lhs_s && rhs_s;
	if(lhs_s && (!rhs_s))
	{
		// lhs->cg needs to exist as we're doing runtime stuff now.
		val_static2dynamic(lhs, source);
	}
	if((!lhs_s) && (rhs_s))
	{
		val_static2dynamic(rhs, source);
	}
	if(!s)
	{
		// better have 2 valid cg's
		if((lhs->cg == 0) || (rhs->cg == 0))
		{
			psyc_panic_begin(source->loc);
			putzstr("the following biop is not calculable at compile-time, but runtime codegen data has not been generated for both rhs and lhs. this is a compiler bug.");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
	// so this one is a little more complicated as we need to deal with zero-value.
	// these types are immediately wrong if these are zero values so lets check that now.
	lhs_type : tyid mut := lhs->type;
	rhs_type : tyid mut := rhs->type;
	lhs_is_zero ::= (lhs->tag == (valtag.s)) && (lhs->s.tag == (sval_tag.zero_value));
	rhs_is_zero ::= (rhs->tag == (valtag.s)) && (rhs->s.tag == (sval_tag.zero_value));
	if(lhs_is_zero && (!rhs_is_zero))
	{
		lhs_type = rhs_type;
	}
	if((!lhs_is_zero) && rhs_is_zero)
	{
		rhs_type = lhs_type;
	}
	if(lhs_is_zero && rhs_is_zero)
	{
		psyc_error_begin(source->loc);
		putzstr("binary operator ");
		putzstr(__enumname(op));
		putzstr(" cannot be provided 'zero' on both sides as there is no way to decipher the type of the result.");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}

	arith_ty ::= ty_of_arithmetic(lhs_type, rhs_type);
	// list all the ops that ty_of_arithmetic will help with
	if(
		(op == (ast_biop.add)) ||
		(op == (ast_biop.sub)) ||
		(op == (ast_biop.mul)) ||
		(op == (ast_biop.div)) ||
		(op == (ast_biop.bitwise_or)) ||
		(op == (ast_biop.bitwise_and)) ||
		(op == (ast_biop.xor)) ||
		(op == (ast_biop.bitshift_left)) ||
		(op == (ast_biop.bitshift_right)) ||
		(op == (ast_biop).modulo)
	)
	{
		if(arith_ty == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("binary ");
			putzstr(__enumname(op));
			putzstr(" operation is not valid on a ");
			putty(lhs_type);
			putzstr(" and a ");
			putty(rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// okay great
		deref(lhs) = val_convert_to(deref lhs, arith_ty, source);
		deref(rhs) = val_convert_to(deref rhs, arith_ty, source);
		if(ty_is_integral(arith_ty))
		{
			if(s)
			{
				return s_integral_arith_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_integral_arith_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_floating_point(arith_ty))
		{
			if(s)
			{
				return s_floating_point_arith_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_floating_point_arith_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_bool(arith_ty))
		{
			if(s)
			{
				return s_bool_arith_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_bool_arith_biop(op, lhs, rhs, source);
			}
		}
	}
	// list all the comparison ops that return bool
	if(
		(op == (ast_biop.compare_equal)) ||
		(op == (ast_biop.compare_not_equal)) ||
		(op == (ast_biop.compare_less)) ||
		(op == (ast_biop.compare_less_equal)) ||
		(op == (ast_biop.compare_greater)) ||
		(op == (ast_biop.compare_greater_equal))
	)
	{
		// still use arithmetic type
		if(arith_ty == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("binary ");
			putzstr(__enumname(op));
			putzstr(" operation is not valid on a ");
			putty(lhs_type);
			putzstr(" and a ");
			putty(rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// okay great
		deref(lhs) = val_convert_to(deref lhs, arith_ty, source);
		deref(rhs) = val_convert_to(deref rhs, arith_ty, source);
		if(ty_is_integral(arith_ty))
		{
			if(s)
			{
				return s_integral_cmp_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_integral_cmp_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_floating_point(arith_ty))
		{
			if(s)
			{
				return s_floating_point_cmp_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_floating_point_cmp_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_bool(arith_ty))
		{
			if(s)
			{
				return s_bool_cmp_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_bool_cmp_biop(op, lhs, rhs, source);
			}
		}
	}
	// logical_or and logical_and are still missing i think. need to confirm theyre both bools and then return the sval comparison result.
	// also havent done biop.at but i basically dont expect that to really be used in svals (todo: sval arrays)
	psyc_panic_begin(source->loc);
	putzstr("control reached end of val_biop. either your code is wrong or mine havent figured it out yet.");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

zero_as ::= func(to : tyid, source : ast? -> val)
{
	ret : val mut := zero;
	ret.tag = (valtag.s);
	ret.type = to;
	ret.s.tag = (sval_tag.primitive);
	ret.s.primitive = zero;
	// tag needs to match tho
	if(ty_is_integral(to))
	{
		ret.s.primitive.tag = (ast_literal_tag.integer);
		return ret;
	}
	if(ty_is_floating_point(to))
	{
		ret.s.primitive.tag = (ast_literal_tag.floating_point);
		return ret;
	}
	psyc_panic_begin(source->loc);
	putzstr("missing codepath in zero_as for a zero_value converting to ");
	putchar('"');
	putty(to);
	putchar('"');
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return ret;
};

integer_as ::= func(n : s64 weak, to : tyid -> val)
{
	return val
	{
		.tag := valtag.s;
		.type := to;
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.integer;
				.integer := n;
			};
		};
	};
};

float_as ::= func(n : f64 weak, to : tyid -> val)
{
	return val
	{
		.tag := valtag.s;
		.type := to;
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.floating_point;
				.floating_point := n;
			};
		};
	};
};

string_as ::= func(chars : u8?, chars_len : u64 -> val)
{
	return val
	{
		.tag := valtag.s;
		.type := tyid_string_literal();
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.string;
				.chars := chars;
				.chars_len := chars_len;
			};
		};
	};
};

char_as ::= func(char : u8 -> val)
{
	chardata ::= arena_alloc(global_arena, 1)@u8 mut?;
	deref(chardata # 0) = char;
	return val
	{
		.tag := valtag.s;
		.type := tyid_char_literal();
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.char;
				.chars := chardata;
				.chars_len := 1;
			};
		};
	};
};

bool_as ::= func(b : bool -> val)
{
	return val
	{
		.tag := valtag.s;
		.type := tyid_bool_literal();
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.boolean;
				.boolean := b;
			};
		};
	};
};

literal_as ::= func(literal : ast_literal -> val)
{
	if(literal.tag == (ast_literal_tag.integer))
	{
		return integer_as(literal.integer, tyid_integral_literal());
	}
	if(literal.tag == (ast_literal_tag.floating_point))
	{
		return float_as(literal.floating_point, tyid_floating_point_literal());
	}
	if(literal.tag == (ast_literal_tag.char))
	{
		return char_as(deref(literal.chars # 0));
	}
	if(literal.tag == (ast_literal_tag.string))
	{
		return string_as(literal.chars, literal.chars_len);
	}
	if(literal.tag == (ast_literal_tag.boolean))
	{
		return bool_as(literal.boolean);
	}
	return zero;
};

val_convert_to ::= func(v : val, to : tyid, source : ast? -> val)
{
	ret : val mut := v;
	if(ret.tag == (valtag.s))
	{
		toty ::= ty_unwrap(to);
		if(ret.s.tag == (sval_tag.zero_value))
		{
			return zero_as(to, source);
		}
		// not a zero value but still is statically known.
		from ::= ret.type;
		ty_ensure_convertible_to(from, to, source);
		ret.type = to;

		toprim ::= toty->base;
		// integer 2 x
		if(ty_is_integral(from))
		{
			if(ty_is_integral(to))
			{
				// no work necessary
				return ret;
			}
			if(ty_is_floating_point(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.floating_point);
				ret.s.primitive.floating_point = (ret.s.primitive.integer@_);
				return ret;
			}
			if(ty_is_bool(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.boolean);
				ret.s.primitive.boolean = (ret.s.primitive.integer != 0);
				return ret;
			}
			if(ty_is_char(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.char);
				ret.s.primitive.chars = arena_alloc(global_arena, 1);
				ret.s.primitive.chars_len = 1;
				deref(ret.s.primitive.chars) = (ret.s.primitive.integer@_);
				return ret;
			}
			// special checks:
			// s64 to enum
			if(ty_matches_ignore_quals(from, tyid.s64) && ty_is_enum(to))
			{
				// nothing needs to be done
				return ret;
			}
			// u64 to ptr
			if(ty_matches_ignore_quals(from, tyid.u64) && ty_is_ptr(to))
			{
				// so how do we convert a u64 literal to a pointer
				// you cant really.
				return ret;
			}
		}
		// floating point 2 x
		if(ty_is_floating_point(from))
		{
			if(ty_is_integral(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.integer);
				ret.s.primitive.integer = (ret.s.primitive.floating_point@_);
			}
			if(ty_is_floating_point(to))
			{
				// already done.
				return ret;
			}
			if(ty_is_char(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.char);
				ret.s.primitive.chars = arena_alloc(global_arena, 1);
				ret.s.primitive.chars_len = 1;
				deref(ret.s.primitive.chars) = (ret.s.primitive.floating_point@_);
			}
		}
		// char 2 x
		if(ty_is_char(from))
		{
			ch ::= deref(ret.s.primitive.chars # 0);
			if(ty_is_integral(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.integer);
				ret.s.primitive.integer = (ch@_);
				return ret;
			}
			if(ty_is_floating_point(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.floating_point);
				ret.s.primitive.floating_point = (ch@_);
				return ret;
			}
			if(ty_is_char(to))
			{
				// already done.
				return ret;
			}
			if(ty_is_bool(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.boolean);
				ret.s.primitive.boolean = (ch != 0);
				return ret;
			}
		}
		// boolean 2 x
		if(ty_is_bool(from))
		{
			if(ty_is_integral(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.integer);
				if(ret.s.primitive.boolean)
				{
					ret.s.primitive.integer = 1;
				}
				else
				{
					ret.s.primitive.integer = 0;
				}
				return ret;
			}
			if(ty_is_char(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.char);
				ret.s.primitive.chars = arena_alloc(global_arena, 1);
				ret.s.primitive.chars_len = 1;
				if(ret.s.primitive.boolean)
				{
					deref(ret.s.primitive.chars) = 1;
				}
				else
				{
					deref(ret.s.primitive.chars) = 0;
				}
				return ret;
			}
			if(ty_is_bool(to))
			{
				// already done.
				return ret;
			}
		}
		if(ty_is_ptr(from))
		{
			if(ty_is_ptr(to))
			{
				// how do we convert between pointers at compile time?
				// we cant really...
				return ret;
			}
			if(ty_matches_ignore_quals(to, tyid.u64))
			{
				return ret;
			}
		}
		if(ty_is_enum(from))
		{
			// enums dont convert to each other unless they're the same exact enum. if we havent errored out by this point then we assume this is the case and just convert trivially.
			if(ty_is_enum(to))
			{
				return ret;
			}
			if(ty_matches_ignore_quals(to, tyid.s64))
			{
				return ret;
			}
		}
		psyc_panic_begin(source->loc);
		putzstr("missing codepath in val_convert_to from type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" converting to ");
		putchar('"');
		putty(to);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
		return zero;
	}
	ret.cg = cg_convert_to(ref v, to, source);
	ret.type = to;
	return ret;
};

val_static2dynamic ::= func(v : val mut?, source : ast? -> v0)
{
	// v->cg needs to exist
	if(v->tag == (valtag.s))
	{
		if(v->cg == zero)
		{
			// make it happen.
			v->cg = cg_sval(v, source);
		}
	}
};

val_must_get_integer_literal ::= func(v : val, source : ast? -> s64 weak)
{
	if(v.tag != (valtag.s))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known integer literal, but it was instead a runtime ");
		putty(v.type);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.tag != (sval_tag.primitive))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known integer literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.tag));
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.primitive.tag != (ast_literal_tag.integer))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known integer literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.primitive.tag));
		putzstr(" literal");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return v.s.primitive.integer;
};

val_must_get_boolean_literal ::= func(v : val, source : ast? -> bool)
{
	if(v.tag != (valtag.s))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known boolean literal, but it was instead a runtime ");
		putty(v.type);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.tag != (sval_tag.primitive))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known boolean literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.tag));
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.primitive.tag != (ast_literal_tag.boolean))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known boolean literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.primitive.tag));
		putzstr(" literal");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return v.s.primitive.boolean;
};
