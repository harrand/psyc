valtag ::= enum
{
	.s_rvalue := 1;
	.s_lvalue := 2;
	.d_rvalue := 3;
	.d_lvalue := 4;
	.ty := 5;
};

sval_tag ::= enum
{
	.zero_value := 1;
	.primitive := 2;
	.pointer := 3;
	.array := 4;
	.structure := 4;
};

sval ::= struct
{
	tag : sval_tag;
	primitive : ast_literal;
	// note: actually a val mut?
};

val ::= struct
{
	tag : valtag;
	type : tyid;
	s : sval;
	cg : u64;
	underlying : v0? weak;
	struct_initialisers_count : u64;
	struct_initialisers : v0? weak;
};

val_is_valid ::= func(v : val -> bool)
{
	return (v.tag != zero) && (v.tag != (valtag.ty));
};

val_is_type_only ::= func(v : val -> bool)
{
	return v.tag == (valtag.ty);
};

val_is_static ::= func(v : val -> bool)
{
	return (v.tag == (valtag.s_lvalue)) || (v.tag == (valtag.s_rvalue));
};

val_is_dynamic ::= func(v : val -> bool)
{
	return (v.tag == (valtag.d_lvalue)) || (v.tag == (valtag.d_rvalue));
};

val_is_lvalue ::= func(v : val -> bool)
{
	return (v.tag == (valtag.s_lvalue)) || (v.tag == (valtag.d_lvalue));
};

val_is_rvalue ::= func(v : val -> bool)
{
	return (v.tag == (valtag.s_rvalue)) || (v.tag == (valtag.d_rvalue));
};

val_runtime_from_variable ::= func(var : variable mut? -> val)
{
	v ::= val mut
	{
		.tag := valtag.d_lvalue;
		.type := var->type;
		.cg := var->cg;
		.underlying := zero;
	};
	val_static2dynamic(ref v, var->node);
	return v;
};

val_node ::= func(node : ast?, scope : lexical_scope mut?, type_only : bool -> val)
{
	if(ast_is_expr(node, ast_expr_tag.literal))
	{
		return literal_as(node->literal);
	}
	if(ast_is_expr(node, ast_expr_tag.unop))
	{
		operand ::= val_node(ast_get_child(node, 0), scope, type_only);
		return val_unop(node->unop, ref operand, type_only, node);
	}
	if(ast_is_expr(node, ast_expr_tag.biop))
	{
		lhs ::= val_node(ast_get_child(node, 0), scope, type_only);
		rhs ::= val_node(ast_get_child(node, 1), scope, type_only);
		return val_biop(node->biop, ref lhs, ref rhs, type_only, node);
	}
	if(ast_is_expr(node, ast_expr_tag.cast))
	{
		cast_to_node ::= ast_get_child(node, 1);
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := ty_typename_node(cast_to_node);};
		}
		cast_from_val : val mut := val_node(ast_get_child(node, 0), scope, false);
		cast_from_val.type = ty_set_qual(cast_from_val.type, tyqual.qual_weak);
		if(ast_is_weakness_idiom(cast_to_node))
		{
			// its the weakness idiom! i.e foo@_
			// no need to do a conversion.
			return cast_from_val;
		}
		return val_convert_to(cast_from_val, ty_typename_node(cast_to_node), node);
	}
	if(ast_is_expr(node, ast_expr_tag.symbol))
	{
		if(scope == zero)
		{
			psyc_panic_begin(node->loc);
			putzstr("call to val_node on a symbol but no scope was provided. must provide a scope so i have somewhere to search for the variable you're trying to reference.");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		sym ::= node->symbol;
		var ::= scope_find_variable(scope, sym.data, sym.len);
		if(var == zero)
		{
			psyc_error_begin(node->loc);
			putzstr("unrecognised variable name ");
			putchar('"');
			putbytes(sym.data, sym.len);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := var->type;};
		}
		if(ty_has_qual(var->type, tyqual.qual_static) && !ty_has_qual(var->type, tyqual.qual_mut))
		{
			// its a static variable
			// let's just get its initialiser now
			// we get its initialiser
			// but as an lvalue because we are the variable
			retval : val mut := var->init;
			retval.tag = (valtag.s_lvalue);
			return retval;
		}
		// not a static variable
		// must do some cg now.
		return val_runtime_from_variable(var);
	}
	if(ast_is_expr(node, ast_expr_tag.dereference))
	{
		deref_operand ::= val_node(ast_get_child(node, 0), scope, type_only);
		// this must be a pointer type
		if(!ty_is_ptr(deref_operand.type))
		{
			psyc_error_begin(node->loc);
			putzstr("cannot dereference non-pointer type ");
			putchar('"');
			putty(deref_operand.type);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := ty_unwrap(deref_operand.type)->base;};
		}
		if(ir == zero)
		{
			psyc_panic_begin(node->loc);
			putzstr("deref expressions that are analysed at compile-time must only be done through a call to val_node with type_only = true");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		return cg_deref(ref deref_operand, true, node);
	}
	if(ast_is_expr(node, ast_expr_tag.call))
	{
		if(scope == zero)
		{
			psyc_panic_begin(node->loc);
			putzstr("call to val_node on a call but no scope was provided. must provide a scope so i have somewhere to search for the function you're trying to call.");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		psyc_nyi(node->loc);
	}
	if(ast_is_expr(node, ast_expr_tag.blkinit))
	{
		structinit_type ::= ty_typename_node(ast_get_child(node, 0));
		if(!ty_is_struct(structinit_type))
		{
			psyc_error_begin(node->loc);
			putzstr("blkinit was expected to be of struct-type, but instead was of type ");
			putchar('"');
			putty(structinit_type);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := structinit_type;};
		}
		return val_blkinit(node, scope);
	}
	if(ast_is_expr(node, ast_expr_tag.field))
	{
		psyc_nyi(node->loc);
	}
	psyc_panic_begin(node->loc);
	putzstr("control reached end of val_node");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

val_unop ::= func(op : ast_unop, v : val mut?, type_only : bool, source : ast? -> val)
{
	s ::= val_is_static(deref v);
	// check for 'ref' as this one has special functionality
	if(op == (ast_unop.reference))
	{
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := ty_ptr(v->type, zero);};
		}
		if(!val_is_lvalue(deref v))
		{
			psyc_error_begin(source->loc);
			putzstr("ref keyword is invalid because you can only ref an lvalue");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(s)
		{
			return s_ref(v, source);
		}
		else
		{
			return cg_ref(v, source);
		}
	}
	if(type_only)
	{
		return val{.tag := valtag.ty; .type := v->type;};
	}
	if(ty_is_integral(v->type))
	{
		if(s)
		{
			return s_integral_unop(op, v, source);
		}
		else
		{
			return cg_integral_unop(op, v, source);
		}
	}
	if(ty_is_floating_point(v->type))
	{
		if(s)
		{
			return s_floating_point_unop(op, v, source);
		}
		else
		{
			return cg_floating_point_unop(op, v, source);
		}
	}
	if(ty_is_bool(v->type))
	{
		if(s)
		{
			return s_bool_unop(op, v, source);
		}
		else
		{
			return cg_bool_unop(op, v, source);
		}
	}
	psyc_error_begin(source->loc);
	putzstr("cannot perform unary ");
	putzstr(__enumname(op));
	putzstr(" operation on a ");
	putty(v->type);
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

val_biop ::= func(op : ast_biop, lhs : val mut?, rhs : val mut?, type_only : bool, source : ast? -> val)
{
	lhs_s ::= val_is_static(deref lhs);
	rhs_s ::= val_is_static(deref rhs);
	s ::= lhs_s && rhs_s;
	if(lhs_s && (!rhs_s))
	{
		// lhs->cg needs to exist as we're doing runtime stuff now.
		val_static2dynamic(lhs, source);
	}
	if((!lhs_s) && (rhs_s))
	{
		val_static2dynamic(rhs, source);
	}
	if(!s && !type_only)
	{
		// better have 2 valid cg's
		if((lhs->cg == 0) || (rhs->cg == 0))
		{
			psyc_panic_begin(source->loc);
			putzstr("the following biop is not calculable at compile-time, but runtime codegen data has not been generated for both rhs and lhs. this is a compiler bug.");
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
	}
	// so this one is a little more complicated as we need to deal with zero-value.
	// these types are immediately wrong if these are zero values so lets check that now.
	lhs_type ::= ref(lhs->type);
	rhs_type ::= ref(rhs->type);
	lhs_is_zero ::= lhs_s && (lhs->s.tag == (sval_tag.zero_value));
	rhs_is_zero ::= rhs_s && (rhs->s.tag == (sval_tag.zero_value));
	if(lhs_is_zero && (!rhs_is_zero))
	{
		deref(lhs_type) = deref(rhs_type);
	}
	if((!lhs_is_zero) && rhs_is_zero)
	{
		deref(rhs_type) = deref(lhs_type);
	}
	if(lhs_is_zero && rhs_is_zero)
	{
		psyc_error_begin(source->loc);
		putzstr("binary operator ");
		putzstr(__enumname(op));
		putzstr(" cannot be provided 'zero' on both sides as there is no way to decipher the type of the result.");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}

	arith_ty ::= ty_of_arithmetic(deref lhs_type, deref rhs_type);
	// list all the ops that ty_of_arithmetic will help with
	if(
		(op == (ast_biop.add)) ||
		(op == (ast_biop.sub)) ||
		(op == (ast_biop.mul)) ||
		(op == (ast_biop.div)) ||
		(op == (ast_biop.bitwise_or)) ||
		(op == (ast_biop.bitwise_and)) ||
		(op == (ast_biop.xor)) ||
		(op == (ast_biop.bitshift_left)) ||
		(op == (ast_biop.bitshift_right)) ||
		(op == (ast_biop).modulo)
	)
	{
		if(arith_ty == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("binary ");
			putzstr(__enumname(op));
			putzstr(" operation is not valid on a ");
			putty(deref lhs_type);
			putzstr(" and a ");
			putty(deref rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := arith_ty;};
		}
		// okay great
		deref(lhs) = val_convert_to(deref lhs, arith_ty, source);
		deref(rhs) = val_convert_to(deref rhs, arith_ty, source);
		if(ty_is_integral(arith_ty))
		{
			if(s)
			{
				return s_integral_arith_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_integral_arith_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_floating_point(arith_ty))
		{
			if(s)
			{
				return s_floating_point_arith_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_floating_point_arith_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_bool(arith_ty))
		{
			if(s)
			{
				return s_bool_arith_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_bool_arith_biop(op, lhs, rhs, source);
			}
		}
	}
	// list all the comparison ops that return bool
	if(
		(op == (ast_biop.compare_equal)) ||
		(op == (ast_biop.compare_not_equal)) ||
		(op == (ast_biop.compare_less)) ||
		(op == (ast_biop.compare_less_equal)) ||
		(op == (ast_biop.compare_greater)) ||
		(op == (ast_biop.compare_greater_equal))
	)
	{
		if(type_only)
		{
			return val{.tag := valtag.ty; .type := tyid.bool;};
		}
		// still use arithmetic type
		if(arith_ty == zero)
		{
			psyc_error_begin(source->loc);
			putzstr("binary ");
			putzstr(__enumname(op));
			putzstr(" operation is not valid on a ");
			putty(deref lhs_type);
			putzstr(" and a ");
			putty(deref rhs_type);
			putchar(10);
			ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		// okay great
		deref(lhs) = val_convert_to(deref lhs, arith_ty, source);
		deref(rhs) = val_convert_to(deref rhs, arith_ty, source);
		if(ty_is_integral(arith_ty))
		{
			if(s)
			{
				return s_integral_cmp_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_integral_cmp_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_floating_point(arith_ty))
		{
			if(s)
			{
				return s_floating_point_cmp_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_floating_point_cmp_biop(op, lhs, rhs, source);
			}
		}
		if(ty_is_bool(arith_ty))
		{
			if(s)
			{
				return s_bool_cmp_biop(op, lhs, rhs, source);
			}
			else
			{
				return cg_bool_cmp_biop(op, lhs, rhs, source);
			}
		}
	}
	// logical_or and logical_and are still missing i think. need to confirm theyre both bools and then return the sval comparison result.
	// also havent done biop.at but i basically dont expect that to really be used in svals (todo: sval arrays)
	psyc_panic_begin(source->loc);
	putzstr("control reached end of val_biop. either your code is wrong or mine havent figured it out yet.");
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return zero;
};

zero_as ::= func(to : tyid, source : ast? -> val)
{
	ret : val mut := zero;
	ret.tag = (valtag.s_rvalue);
	ret.type = to;
	ret.s.tag = (sval_tag.primitive);
	ret.s.primitive = zero;
	// tag needs to match tho
	if(ty_is_integral(to))
	{
		ret.s.primitive.tag = (ast_literal_tag.integer);
		return ret;
	}
	if(ty_is_floating_point(to))
	{
		ret.s.primitive.tag = (ast_literal_tag.floating_point);
		return ret;
	}
	psyc_panic_begin(source->loc);
	putzstr("missing codepath in zero_as for a zero_value converting to ");
	putchar('"');
	putty(to);
	putchar('"');
	putchar(10);
	ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
	psyc_diag_end();
	psyc_exit_failure();
	return ret;
};

integer_as ::= func(n : s64 weak, to : tyid -> val)
{
	return val
	{
		.tag := valtag.s_rvalue;
		.type := to;
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.integer;
				.integer := n;
			};
		};
		.cg := zero;
		.underlying := zero;
	};
};

float_as ::= func(n : f64 weak, to : tyid -> val)
{
	return val
	{
		.tag := valtag.s_rvalue;
		.type := to;
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.floating_point;
				.floating_point := n;
			};
		};
		.cg := zero;
		.underlying := zero;
	};
};

string_as ::= func(chars : u8?, chars_len : u64 -> val)
{
	return val
	{
		.tag := valtag.s_rvalue;
		.type := tyid_string_literal();
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.string;
				.chars := chars;
				.chars_len := chars_len;
			};
		};
		.cg := zero;
		.underlying := zero;
	};
};

char_as ::= func(char : u8 -> val)
{
	chardata ::= arena_alloc(global_arena, 1)@u8 mut?;
	deref(chardata # 0) = char;
	return val
	{
		.tag := valtag.s_rvalue;
		.type := tyid_char_literal();
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.char;
				.chars := chardata;
				.chars_len := 1;
			};
		};
		.cg := zero;
		.underlying := zero;
	};
};

bool_as ::= func(b : bool -> val)
{
	return val
	{
		.tag := valtag.s_rvalue;
		.type := tyid_bool_literal();
		.s := sval
		{
			.tag := sval_tag.primitive;
			.primitive := ast_literal
			{
				.tag := ast_literal_tag.boolean;
				.boolean := b;
			};
		};
		.cg := zero;
		.underlying := zero;
	};
};

literal_as ::= func(literal : ast_literal -> val)
{
	if(literal.tag == (ast_literal_tag.integer))
	{
		return integer_as(literal.integer, tyid_integral_literal());
	}
	if(literal.tag == (ast_literal_tag.floating_point))
	{
		return float_as(literal.floating_point, tyid_floating_point_literal());
	}
	if(literal.tag == (ast_literal_tag.char))
	{
		return char_as(deref(literal.chars # 0));
	}
	if(literal.tag == (ast_literal_tag.string))
	{
		return string_as(literal.chars, literal.chars_len);
	}
	if(literal.tag == (ast_literal_tag.boolean))
	{
		return bool_as(literal.boolean);
	}
	return zero;
};

val_convert_to ::= func(v : val, to : tyid, source : ast? -> val)
{
	ret : val mut := v;
	if(val_is_static(ret))
	{
		toty ::= ty_unwrap(to);
		if(ret.s.tag == (sval_tag.zero_value))
		{
			return zero_as(to, source);
		}
		// not a zero value but still is statically known.
		from ::= ret.type;
		ty_ensure_convertible_to(from, to, source);
		ret.type = to;

		toprim ::= toty->base;
		// integer 2 x
		if(ty_is_integral(from))
		{
			if(ty_is_integral(to))
			{
				// no work necessary
				return ret;
			}
			if(ty_is_floating_point(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.floating_point);
				ret.s.primitive.floating_point = (ret.s.primitive.integer@_);
				return ret;
			}
			if(ty_is_bool(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.boolean);
				ret.s.primitive.boolean = (ret.s.primitive.integer != 0);
				return ret;
			}
			if(ty_is_char(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.char);
				ret.s.primitive.chars = arena_alloc(global_arena, 1);
				ret.s.primitive.chars_len = 1;
				deref(ret.s.primitive.chars) = (ret.s.primitive.integer@_);
				return ret;
			}
			// special checks:
			// s64 to enum
			if(ty_matches_ignore_quals(from, tyid.s64) && ty_is_enum(to))
			{
				// nothing needs to be done
				return ret;
			}
			// u64 to ptr
			if(ty_matches_ignore_quals(from, tyid.u64) && ty_is_ptr(to))
			{
				// so how do we convert a u64 literal to a pointer
				// you cant really.
				return ret;
			}
		}
		// floating point 2 x
		if(ty_is_floating_point(from))
		{
			if(ty_is_integral(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.integer);
				ret.s.primitive.integer = (ret.s.primitive.floating_point@_);
			}
			if(ty_is_floating_point(to))
			{
				// already done.
				return ret;
			}
			if(ty_is_char(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.char);
				ret.s.primitive.chars = arena_alloc(global_arena, 1);
				ret.s.primitive.chars_len = 1;
				deref(ret.s.primitive.chars) = (ret.s.primitive.floating_point@_);
			}
		}
		// char 2 x
		if(ty_is_char(from))
		{
			ch ::= deref(ret.s.primitive.chars # 0);
			if(ty_is_integral(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.integer);
				ret.s.primitive.integer = (ch@_);
				return ret;
			}
			if(ty_is_floating_point(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.floating_point);
				ret.s.primitive.floating_point = (ch@_);
				return ret;
			}
			if(ty_is_char(to))
			{
				// already done.
				return ret;
			}
			if(ty_is_bool(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.boolean);
				ret.s.primitive.boolean = (ch != 0);
				return ret;
			}
		}
		// boolean 2 x
		if(ty_is_bool(from))
		{
			if(ty_is_integral(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.integer);
				if(ret.s.primitive.boolean)
				{
					ret.s.primitive.integer = 1;
				}
				else
				{
					ret.s.primitive.integer = 0;
				}
				return ret;
			}
			if(ty_is_char(to))
			{
				ret.s.primitive.tag = (ast_literal_tag.char);
				ret.s.primitive.chars = arena_alloc(global_arena, 1);
				ret.s.primitive.chars_len = 1;
				if(ret.s.primitive.boolean)
				{
					deref(ret.s.primitive.chars) = 1;
				}
				else
				{
					deref(ret.s.primitive.chars) = 0;
				}
				return ret;
			}
			if(ty_is_bool(to))
			{
				// already done.
				return ret;
			}
		}
		if(ty_is_ptr(from))
		{
			if(ty_is_ptr(to))
			{
				// how do we convert between pointers at compile time?
				// we cant really...
				return ret;
			}
			if(ty_matches_ignore_quals(to, tyid.u64))
			{
				return ret;
			}
		}
		if(ty_is_enum(from))
		{
			// enums dont convert to each other unless they're the same exact enum. if we havent errored out by this point then we assume this is the case and just convert trivially.
			if(ty_is_enum(to))
			{
				return ret;
			}
			if(ty_matches_ignore_quals(to, tyid.s64))
			{
				return ret;
			}
		}
		psyc_panic_begin(source->loc);
		putzstr("missing codepath in val_convert_to from type ");
		putchar('"');
		putty(from);
		putchar('"');
		putzstr(" converting to ");
		putchar('"');
		putty(to);
		putchar('"');
		psyc_diag_end();
		psyc_exit_failure();
		return zero;
	}
	ret.cg = cg_convert_to(ref v, to, source);
	ret.type = to;
	return ret;
};

val_static2dynamic ::= func(v : val mut?, source : ast? -> v0)
{
	// v->cg needs to exist
	if(val_is_static(deref v))
	{
		if(v->cg == zero)
		{
			// make it happen.
			v->cg = cg_sval(v, source);
		}
		// make it an rvalue even if its s_lvalue
		v->tag = (valtag.d_rvalue);
	}
};

val_must_get_integer_literal ::= func(v : val, source : ast? -> s64 weak)
{
	if(!val_is_static(v))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known integer literal, but it was instead a runtime ");
		putty(v.type);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.tag != (sval_tag.primitive))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known integer literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.tag));
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.primitive.tag != (ast_literal_tag.integer))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known integer literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.primitive.tag));
		putzstr(" literal");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return v.s.primitive.integer;
};

val_must_get_boolean_literal ::= func(v : val, source : ast? -> bool)
{
	if(!val_is_static(v))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known boolean literal, but it was instead a runtime ");
		putty(v.type);
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.tag != (sval_tag.primitive))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known boolean literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.tag));
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	if(v.s.primitive.tag != (ast_literal_tag.boolean))
	{
		psyc_error_begin(source->loc);
		putzstr("expected value to yield a statically-known boolean literal, but it was instead a statically-known ");
		putzstr(__enumname(v.s.primitive.tag));
		putzstr(" literal");
		putchar(10);
		ast_print_annotated_source(program_find_source_file(source->loc.file)->src, source, 1, underline_colour.red);
		psyc_diag_end();
		psyc_exit_failure();
	}
	return v.s.primitive.boolean;
};

val_blkinit ::= func(node : ast mut?, scope : lexical_scope mut? -> val)
{
	structinit_type ::= ty_typename_node(ast_get_child(node, 0));
	memcount ::= ty_unwrap(structinit_type)->strct.members_count;
	structdata ::= val mut
	{
		.tag := valtag.s_lvalue;
		.type := structinit_type;
		.s := sval
		{
			.tag := sval_tag.structure;
		};
		.cg := zero;
		.underlying := zero;
		.struct_initialisers_count := memcount;
		.struct_initialisers := arena_alloc(global_arena, __sizeof(val) * memcount);
	};
	init_ptr ::= structdata.struct_initialisers@val mut?;
	i : u64 mut;
	for(i = 1, i < (node->children_count), i = i + 1)
	{
		desiginit_node ::= ast_get_child(node, i);
		desiginit ::= desiginit_node->desiginit;
		maybe_member_idx ::= ty_get_struct_member_id(structinit_type, desiginit.name, desiginit.name_len);
		if(maybe_member_idx == -1)
		{
			putzstr("desiginit is invalid because type ");
			putchar('"');
			putty(structinit_type);
			putchar('"');
			putzstr(" has no member named ");
			putchar('"');
			putbytes(desiginit.name, desiginit.name_len);
			putchar('"');
			putchar(10);
			ast_print_annotated_source(program_find_source_file(node->loc.file)->src, node, 1, underline_colour.red);
			psyc_diag_end();
			psyc_exit_failure();
		}
		member_ty ::= deref(ty_unwrap(structinit_type)->strct.members # maybe_member_idx);
		deref(init_ptr # maybe_member_idx) = val_convert_to(val_node(ast_get_child(desiginit_node, 0), scope, false), member_ty, node);
	}
	return structdata;
};
