psyir_inst_tag : enum
{
	.stack := 1; // stack
	.off := 2; // offset
	.jmpif := 3; // jump if cond
	.jmp := 4; // jump
	.load := 5; // load
	.store := 9; // store
	.call := 13; // call
	.rcall := 14; // call
	.retnone := 15; // return
	.ret := 16; // return

	.cmp_eq := 19; // ==
	.cmp_ne := 23; // !=
	.cmp_lt := 27; // <
	.cmp_le := 31; // <=
	.cmp_gt := 35; // >
	.cmp_ge := 39; // >=
	.or := 43; // |
	.and := 47; // &
	.xor := 51; // ^
	.add := 55; // +
	.sub := 59; // -
	.mul := 63; // *
	.div := 67; // /
	.sex16 := 71; // sign extend up to 16 bits (also HAHAHAHAHHA)
	.sex32 := 72; // sign extend up to 32 bits (also HAHAHAHAHHA)
	.sex64 := 73; // sign extend up to 64 bits (also HAHAHAHAHHA)
	.zex16 := 74; // zero extend up to 16 bits
	.zex32 := 75; // zero extend up to 32 bits
	.zex64 := 76; // zero extend up to 64 bits
	.trunc8 := 77; // truncate down to 8 bits
	.trunc16 := 78; // truncate down to 16 bits
	.trunc32 := 79; // truncate down to 32 bits
};

psyir_reg_size : enum
{
	.q := 8;
	.d := 4;
	.w := 2;
	.b := 1;
};

psyir_val_tag : enum
{
	.imm := 1;
	.r := 2;
	.blk := 3;
	.fn := 4;
};

psyir_val : struct
{
	tag : psyir_val_tag;
	size : psyir_reg_size;
	val : s64;
};

psyir_inst : struct
{
	tag : psyir_inst_tag;
	operands : psyir_val mut[4];
	extra_operands_count : u64;
	extra_operands : psyir_val mut?;
};

psyir_blk : struct
{
	inst : psyir_inst mut?;
	inst_count : u64;
	inst_cap : u64;
};

psyir_func : struct
{
	name : u8?;
	name_len : u64;
	blk : psyir_blk mut?;
	blk_count : u64;
	blk_cap : u64;

	params_count : u64;
	regcur : u64;
};

psyir_val_dump : func(op : psyir_val -> v0)
{
	if(op.tag == psyir_val_tag.r)
	{
		if(op.val < 0)
		{
			putchar('i');
			putsint(-op.val);
			return;
		}
		putzstr(enumname(op.size));
	}
	if(op.tag == psyir_val_tag.blk)
	{
		putchar('_');
	}
	if(op.tag == psyir_val_tag.fn)
	{
		fn ::= [psyir.prog.fn # op.val];
		putbytes(fn.name, fn.name_len);
	}
	else
	{
		putsint(op.val);
	}
};

psyir_inst_get_operand : func(inst : psyir_inst, i : u64 -> psyir_val)
{
	if(i >= countof typeof(inst.operands))
	{
		return [inst.extra_operands # (i - countof typeof(inst.operands))];
	}
	return [inst.operands # i];
};

psyir_inst_operand_count : func(inst : psyir_inst -> u64)
{
	if(inst.extra_operands != zero)
	{
		return countof typeof(inst.operands) + inst.extra_operands_count;
	}
	i : u64 mut;
	for(i = 0; i < countof typeof(inst.operands); i = i + 1)
	{
		cur_op ::= [inst.operands # i];
		if(cur_op.tag == zero)
		{
			return i;
		}
	}
	return i;
};

psyir_inst_dump : func(inst : psyir_inst -> v0)
{
	putzstr(enumname(inst.tag));
	putzstr(" ");
	i : u64 mut;
	count ::= psyir_inst_operand_count(inst);
	for(i = 0; i < count; i = i + 1)
	{
		psyir_val_dump(psyir_inst_get_operand(inst, i));
		if(i != (count - 1))
		{
			putzstr(", ");
		}
	}
};

psyir_blk_dump : func(blk : psyir_blk -> v0)
{
	i : u64 mut;
	for(i = 0; i < blk.inst_count; i = i + 1)
	{
		//putchar(9);
		putzstr("  ");
		psyir_inst_dump([blk.inst # i]);
		putchar(10);
	}
};

psyir_func_dump : func(fn : psyir_func -> v0)
{
	putzstr("(");
	j : u64 mut;
	for(j = 0; j < fn.params_count; j = j + 1)
	{
		psyir_val_dump(ir_qreg(j@_));
		if(j != (fn.params_count - 1))
		{
			putzstr(", ");
		}
	}
	putzstr(")");
	putzstr(":");
	putchar(10);

	i : u64 mut;
	for(i = 0; i < fn.blk_count; i = i + 1)
	{
		putzstr(" ");
		psyir_val_dump(ir_blk(i));
		putzstr(": ");
		putchar(10);
		psyir_blk_dump([fn.blk # i]);
	}
};

psyir_program : struct
{
	fn : psyir_func mut?;
	fn_count : u64;
	fn_cap : u64;	
};

psyir_position : struct
{
	func_cursor : u64;
	blk_cursor : u64;
};

psyir_api : struct
{
	prog : psyir_program;
	position : psyir_position;
};

psyir : psyir_api mut := zero;

ir_create_function : func(name : u8?, name_len : u64, params_count : u64 -> psyir_position)
{
	if(psyir.prog.fn == zero)
	{
		psyir.prog.fn_cap = 1024;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof psyir_func);
	}
	while(psyir.prog.fn_count >= psyir.prog.fn_cap)
	{
		old ::= psyir.prog.fn;
		oldcap ::= psyir.prog.fn_cap;
		psyir.prog.fn_cap = oldcap * 2;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof psyir_func);
		memcopy(psyir.prog.fn, old, oldcap * sizeof psyir_func);
	}
	[psyir.prog.fn # (psyir.prog.fn_count)] = psyir_func
	{
		.name := name;
		.name_len := name_len;
		.params_count := params_count;
		.regcur := params_count;	
		... := zero;
	};
	psyir.position = psyir_position
	{
		.func_cursor := psyir.prog.fn_count;
		.blk_cursor := zero;
	};
	psyir.prog.fn_count = (psyir.prog.fn_count + 1);
	return ir_create_block();
};

ir_current_function : func(-> psyir_func mut?)
{
	return psyir.prog.fn # (psyir.position.func_cursor);
};

ir_current_block : func(-> psyir_blk mut?)
{
	return ir_current_function()->blk # (psyir.position.blk_cursor);
};

ir_create_block : func(-> psyir_position)
{
	fn ::= ir_current_function();
	if(fn->blk == zero)
	{
		fn->blk_cap = 8;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof psyir_blk);
	}
	while(fn->blk_count >= fn->blk_cap)
	{
		old ::= fn->blk;
		oldcap ::= fn->blk_cap;
		fn->blk_cap = oldcap * 2;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof psyir_blk);
		memcopy(fn->blk, old, oldcap * sizeof psyir_blk);
	}
	ret ::= psyir_position
	{
		.func_cursor := psyir.position.func_cursor;
		.blk_cursor := fn->blk_count;
	};
	[fn->blk # (fn->blk_count)] = zero;
	fn->blk_count = (fn->blk_count + 1);
	psyir.position = ret;
	return ret;
};

ir_add_instruction : func(inst : psyir_inst -> v0)
{
	blk ::= ir_current_block();
	if(blk->inst == zero)
	{
		blk->inst_cap = 64;
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof psyir_inst);
	}
	while(blk->inst_count >= blk->inst_cap)
	{
		old ::= blk->inst;
		oldcap ::= blk->inst_cap;
		blk->inst_cap = (blk->inst_cap * 2);
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof psyir_inst);
		memcopy(blk->inst, old, oldcap * sizeof psyir_inst);
	}
	[blk->inst # (blk->inst_count)] = inst;
	blk->inst_count = (blk->inst_count + 1);
};

ir_reposition : func(pos : psyir_position -> v0)
{
	psyir.position = pos;
};

ir_dump : func(-> v0)
{
	i : u64 mut;
	for(i = 0; i < psyir.prog.fn_count; i = i + 1)
	{
		psyir_val_dump(ir_fn(i));
		psyir_func_dump([psyir.prog.fn # i]);
		putchar(10);
	}
};

ir_qreg : func(i : s64 -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.r;
		.size := psyir_reg_size.q;
		.val := i;
	};
};

ir_dreg : func(i : s64 -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.r;
		.size := psyir_reg_size.d;
		.val := i;
	};
};

ir_wreg : func(i : s64 -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.r;
		.size := psyir_reg_size.w;
		.val := i;
	};
};

ir_breg : func(i : s64 -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.r;
		.size := psyir_reg_size.w;
		.val := i;
	};
};

ir_regsize : func(r : psyir_val -> psyir_reg_size)
{
	if(r.tag == psyir_val_tag.r)
	{
		return r.size;
	}
	return psyir_reg_size.q;
};

ir_imm : func(i : s64 weak -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.imm;
		.val := i;
	};
};

ir_blk : func(i : s64 weak -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.blk;
		.val := i;
	};
};

ir_fn : func(i : s64 weak -> psyir_val)
{
	return psyir_val
	{
		.tag := psyir_val_tag.fn;
		.val := i;
	};
};

ir_new_reg : func(size : psyir_reg_size -> psyir_val)
{
	fn ::= ir_current_function();
	num ::= fn->regcur;
	fn->regcur = (fn->regcur + 1);
	return psyir_val
	{
		.tag := psyir_val_tag.r;
		.size := size;
		.val := num@_;
	};
};

ir_new_qreg : func(-> psyir_val)
{
	return ir_new_reg(psyir_reg_size.q);
};

// instruction api
ir_stack : func(sz : psyir_val -> psyir_val)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.stack;
		.operands := psyir_val[4]
		{
			.0 := out;
			.1 := sz;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_off : func(ptr : psyir_val, offset : psyir_val -> psyir_val)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.off;
		.operands := psyir_val[4]
		{
			.0 := out;
			.1 := ptr;
			.2 := offset;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_load : func(k : psyir_val -> psyir_val)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.load;
		.operands := psyir_val[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_store : func(k : psyir_val, v : psyir_val -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.store;
		.operands := psyir_val[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
		... := zero;
	});
};

ir_arith : func(type : psyir_inst_tag, lhs : psyir_val, rhs : psyir_val -> psyir_val)
{
	out ::= ir_new_reg(ir_regsize(lhs));
	ir_add_instruction(psyir_inst
	{
		.tag := type;
		.operands := psyir_val[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_add : func(lhs : psyir_val, rhs : psyir_val -> psyir_val)
{
	return ir_arith(psyir_inst_tag.add, lhs, rhs);
};

ir_sub : func(lhs : psyir_val, rhs : psyir_val -> psyir_val)
{
	return ir_arith(psyir_inst_tag.sub, lhs, rhs);
};

ir_mul : func(lhs : psyir_val, rhs : psyir_val -> psyir_val)
{
	return ir_arith(psyir_inst_tag.mul, lhs, rhs);
};

ir_div : func(lhs : psyir_val, rhs : psyir_val -> psyir_val)
{
	return ir_arith(psyir_inst_tag.div, lhs, rhs);
};

ir_sized_unary : func(type : psyir_inst_tag, sz : psyir_reg_size, op : psyir_val -> psyir_val)
{
	out ::= ir_new_reg(sz);
	ir_add_instruction(psyir_inst
	{
		.tag := type;
		.operands := psyir_val[4]
		{
			.0 := out;
			.1 := op;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_sex16 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.sex16, psyir_reg_size.w, op);
};

ir_sex32 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.sex32, psyir_reg_size.d, op);
};

ir_sex64 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.sex64, psyir_reg_size.q, op);
};

ir_zex16 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.zex16, psyir_reg_size.w, op);
};

ir_zex32 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.zex32, psyir_reg_size.d, op);
};

ir_zex64 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.zex64, psyir_reg_size.q, op);
};

ir_trunc8 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.trunc8, psyir_reg_size.b, op);
};

ir_trunc16 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.trunc16, psyir_reg_size.w, op);
};

ir_trunc32 : func(op : psyir_val -> psyir_val)
{
	return ir_sized_unary(psyir_inst_tag.trunc32, psyir_reg_size.d, op);
};
ir_jmp : func(label : psyir_position -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.jmp;
		.operands := psyir_val[4]
		{
			.0 := ir_blk(label.blk_cursor);
			... := zero;
		};
		... := zero;
	});
};

ir_jmpif : func(cond : psyir_val, blk_true : psyir_position, blk_false : psyir_position-> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.jmpif;
		.operands := psyir_val[4]
		{
			.0 := cond;
			.1 := ir_blk(blk_true.blk_cursor);
			.2 := ir_blk(blk_false.blk_cursor);
			... := zero;
		};
		... := zero;
	});
};

ir_call : func(fn : psyir_position, params : psyir_val?, params_count : u64 -> v0)
{
	// -1 because fn is also an operand
	base_operands_count ::= (countof typeof(psyir_inst{}.operands)) - 1;
	extras : psyir_val mut? mut := zero;
	extras_count : u64 mut := 0;
	i : u64 mut;
	if(params_count > (base_operands_count))
	{
		extras_count = (params_count - base_operands_count);
		extras = arena_alloc(global_arena, extras_count * sizeof psyir_val);
		for(i = 0; i < extras_count; i = i + 1)
		{
			[extras # i] = [params # (i + base_operands_count)];
		}
	}
	inst ::= psyir_inst mut
	{
		.tag := psyir_inst_tag.call;
		.operands := psyir_val[4]
		{
			.0 := ir_fn(fn.func_cursor);
			... := zero;
		};
		.extra_operands_count := extras_count;
		.extra_operands := extras;
	};
	min : u64 mut := params_count;
	if(base_operands_count < min)
	{
		min = base_operands_count;
	}
	memcopy(inst.operands # 1, params, min * sizeof psyir_val);
	ir_add_instruction(inst);
};

ir_rcall : func(fn : psyir_position, params : psyir_val?, params_count : u64 -> psyir_val)
{
	out ::= ir_new_qreg();
	// -2 because fn is also an operand aswell as the output register
	base_operands_count ::= (countof typeof(psyir_inst{}.operands)) - 2;
	extras : psyir_val mut? mut := zero;
	extras_count : u64 mut := 0;
	i : u64 mut;
	if(params_count > (base_operands_count))
	{
		extras_count = (params_count - base_operands_count);
		extras = arena_alloc(global_arena, extras_count * sizeof psyir_val);
		for(i = 0; i < extras_count; i = i + 1)
		{
			[extras # i] = [params # (i + base_operands_count)];
		}
	}
	inst ::= psyir_inst mut
	{
		.tag := psyir_inst_tag.rcall;
		.operands := psyir_val[4]
		{
			.0 := out;
			.1 := ir_fn(fn.func_cursor);
			... := zero;
		};
		.extra_operands_count := extras_count;
		.extra_operands := extras;
	};
	min : u64 mut := params_count;
	if(base_operands_count < min)
	{
		min = base_operands_count;
	}
	memcopy(inst.operands # 2, params, min * sizeof psyir_val);
	ir_add_instruction(inst);
	return out;
};

ir_retnone : func(-> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.retnone;
		.operands := zero;
		... := zero;
	});
};

ir_ret : func(v : psyir_val -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret;
		.operands := psyir_val[4]
		{
			.0 := v;
			... := zero;
		};
		... := zero;
	});
};
