irtag : enum
{
	.stack := 1; // stack
	.off := 2; // offset
	.jmpif := 3; // jump if cond
	.jmp := 4; // jump
	.load := 5; // load
	.store := 9; // store
	.call := 13; // call
	.rcall := 14; // call
	.retnone := 15; // return
	.ret := 16; // return

	.cmp_eq := 19; // ==
	.cmp_ne := 23; // !=
	.cmp_lt := 27; // <
	.cmp_le := 31; // <=
	.cmp_gt := 35; // >
	.cmp_ge := 39; // >=
	.or := 43; // |
	.and := 47; // &
	.xor := 51; // ^
	.add := 55; // +
	.sub := 59; // -
	.mul := 63; // *
	.div := 67; // /
	.sex16 := 71; // sign extend up to 16 bits (also HAHAHAHAHHA)
	.sex32 := 72; // sign extend up to 32 bits (also HAHAHAHAHHA)
	.sex64 := 73; // sign extend up to 64 bits (also HAHAHAHAHHA)
	.zex16 := 74; // zero extend up to 16 bits
	.zex32 := 75; // zero extend up to 32 bits
	.zex64 := 76; // zero extend up to 64 bits
	.trunc8 := 77; // truncate down to 8 bits
	.trunc16 := 78; // truncate down to 16 bits
	.trunc32 := 79; // truncate down to 32 bits
};

irsz : enum
{
	.q := 1; // 64 bit (qword)
	.d := 2; // 32 bit (dword)
	.w := 3; // 16 bit (word)
	.b := 4; // 8 bit (byte)
	.x := 5; // 32 bit fp (float)
	.y := 6; // 64 bit fp (double)
};

ir_valtag : enum
{
	.imm := 1;
	.r := 2;
	.blk := 3;
	.fn := 4;
	.globref := 5;
};

ir_val : struct
{
	tag : ir_valtag;
	size : irsz;
	val : s64;
};

ir : struct
{
	tag : irtag;
	operands : ir_val mut[4];
	extra_operands_count : u64;
	extra_operands : ir_val mut?;
};

ir_blk : struct
{
	inst : ir mut?;
	inst_count : u64;
	inst_cap : u64;
};

ir_func : struct
{
	name : u8?;
	name_len : u64;
	ret : irsz;
	blk : ir_blk mut?;
	blk_count : u64;
	blk_cap : u64;

	params : irsz mut?;
	params_count : u64;
	params_cap : u64;
	regcur : u64;
};

ir_val_dump : func(op : ir_val -> v0)
{
	if(op.tag == ir_valtag.r)
	{
		if(op.val < 0)
		{
			putchar('i');
			putsint(-op.val);
			return;
		}
		putzstr(enumname(op.size));
	}
	if(op.tag == ir_valtag.blk)
	{
		putchar('_');
	}
	if(op.tag == ir_valtag.fn)
	{
		fn ::= [psyir.prog.fn # op.val];
		putbytes(fn.name, fn.name_len);
	}
	else
	{
		if(op.tag == (ir_valtag.globref))
		{
			putzstr(".");
			glob ::= [psyir.prog.globals # op.val];
			putbytes(glob.name, glob.name_len);
		}
		putsint(op.val);
	}
};

ir_get_operand : func(inst : ir, i : u64 -> ir_val)
{
	if(i >= countof typeof(inst.operands))
	{
		return [inst.extra_operands # (i - countof typeof(inst.operands))];
	}
	return [inst.operands # i];
};

ir_operand_count : func(inst : ir -> u64)
{
	if(inst.extra_operands != zero)
	{
		return countof typeof(inst.operands) + inst.extra_operands_count;
	}
	i : u64 mut;
	for(i = 0; i < countof typeof(inst.operands); i = i + 1)
	{
		cur_op ::= [inst.operands # i];
		if(cur_op.tag == zero)
		{
			return i;
		}
	}
	return i;
};

ir_dump : func(inst : ir -> v0)
{
	putzstr(enumname(inst.tag));
	putzstr(" ");
	i : u64 mut;
	count ::= ir_operand_count(inst);
	for(i = 0; i < count; i = i + 1)
	{
		ir_val_dump(ir_get_operand(inst, i));
		if(i != (count - 1))
		{
			putzstr(", ");
		}
	}
};

ir_blk_dump : func(blk : ir_blk -> v0)
{
	i : u64 mut;
	for(i = 0; i < blk.inst_count; i = i + 1)
	{
		//putchar(9);
		putzstr("  ");
		ir_dump([blk.inst # i]);
		putchar(10);
	}
};

psyir_glob_dump : func(glob : psyir_glob -> v0)
{
	putzstr(".");
	putbytes(glob.name, glob.name_len);
	putzstr(" ");
	if(glob.mutable)
	{
		putzstr("mutable");
	}
	else
	{
		putzstr("const");
	}
	putzstr("(");
	putuint(glob.data_len);
	putzstr("): ");
	if(glob.data == zero)
	{
		putzstr("zero");
	}
	else
	{
		putchar('"');
		putbytes(glob.data, glob.data_len);
		putchar('"');
	}
	putchar(10);
};

ir_func_dump : func(fn : ir_func -> v0)
{
	putzstr("(");
	j : u64 mut;
	for(j = 0; j < fn.params_count; j = j + 1)
	{
		ir_val_dump(ir_val{.tag := ir_valtag.r; .size := [fn.params # j]; .val := j@_;});
		if(j != (fn.params_count - 1))
		{
			putzstr(", ");
		}
	}
	putzstr(" -> ");
	if(fn.ret == zero)
	{
		putzstr("none");
	}
	else
	{
		putzstr(enumname(fn.ret));
	}
	putzstr(")");
	putzstr(":");
	putchar(10);

	i : u64 mut;
	for(i = 0; i < fn.blk_count; i = i + 1)
	{
		putzstr(" ");
		ir_val_dump(ir_blk(i));
		putzstr(": ");
		putchar(10);
		ir_blk_dump([fn.blk # i]);
	}
};

psyir_glob : struct
{
	name : u8?;
	name_len : u64;
	data : u8?;
	data_len : u64;
	mutable : bool;
};

psyir_program : struct
{
	fn : ir_func mut?;
	fn_count : u64;
	fn_cap : u64;	

	globals : psyir_glob mut?;
	globals_count : u64;
	globals_cap : u64;
};

psyir_position : struct
{
	func_cursor : u64;
	blk_cursor : u64;
};

psyir_api : struct
{
	prog : psyir_program;
	position : psyir_position;
};

psyir : psyir_api mut := zero;

ir_add_func_generic : func(name : u8?, name_len : u64, ret : irsz -> psyir_position)
{
	if(psyir.prog.fn == zero)
	{
		psyir.prog.fn_cap = 1024;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof ir_func);
	}
	while(psyir.prog.fn_count >= psyir.prog.fn_cap)
	{
		old ::= psyir.prog.fn;
		oldcap ::= psyir.prog.fn_cap;
		psyir.prog.fn_cap = oldcap * 2;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof ir_func);
		memcopy(psyir.prog.fn, old, oldcap * sizeof ir_func);
	}
	[psyir.prog.fn # (psyir.prog.fn_count)] = ir_func
	{
		.name := name;
		.name_len := name_len;
		.ret := ret;
		... := zero;
	};
	psyir.position = psyir_position
	{
		.func_cursor := psyir.prog.fn_count;
		.blk_cursor := zero;
	};
	psyir.prog.fn_count = (psyir.prog.fn_count + 1);
	return ir_create_block();
};

ir_add_func : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, zero);
};

ir_add_qfunc : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, irsz.q);
};

ir_add_dfunc : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, irsz.d);
};

ir_add_wfunc : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, irsz.w);
};

ir_add_bfunc : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, irsz.b);
};

ir_add_xfunc : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, irsz.x);
};

ir_add_yfunc : func(name : u8?, name_len : u64 -> psyir_position)
{
	return ir_add_func_generic(name, name_len, irsz.y);
};

ir_param : func(sz : irsz -> ir_val)
{
	fn ::= ir_current_function();
	parsz ::= sizeof typeof([fn->params # 0]);
	if(fn->params == zero)
	{
		fn->params_cap = 8;
		fn->params = arena_alloc(global_arena, fn->params_cap * parsz);
	}
	while(fn->params_count >= fn->params_cap)
	{
		oldcap ::= fn->params_cap;
		old ::= fn->params;
		fn->params_cap = (fn->params_cap * 2);
		fn->params = arena_alloc(global_arena, fn->params_cap * parsz);
		memcopy(fn->params, old, oldcap * parsz);
	}
	idx ::= fn->params_count;
	[fn->params # idx] = sz;
	fn->regcur = (fn->regcur + 1);
	fn->params_count = (fn->params_count + 1);
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := sz;
		.val := idx@_;
	};
};

ir_qparam : func(-> ir_val)
{
	return ir_param(irsz.q);
};

ir_dparam : func(-> ir_val)
{
	return ir_param(irsz.d);
};

ir_wparam : func(-> ir_val)
{
	return ir_param(irsz.w);
};

ir_bparam : func(-> ir_val)
{
	return ir_param(irsz.b);
};

ir_xparam : func(-> ir_val)
{
	return ir_param(irsz.x);
};

ir_yparam : func(-> ir_val)
{
	return ir_param(irsz.y);
};

ir_current_function : func(-> ir_func mut?)
{
	return psyir.prog.fn # (psyir.position.func_cursor);
};

ir_current_block : func(-> ir_blk mut?)
{
	return ir_current_function()->blk # (psyir.position.blk_cursor);
};

ir_create_block : func(-> psyir_position)
{
	fn ::= ir_current_function();
	if(fn->blk == zero)
	{
		fn->blk_cap = 8;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof ir_blk);
	}
	while(fn->blk_count >= fn->blk_cap)
	{
		old ::= fn->blk;
		oldcap ::= fn->blk_cap;
		fn->blk_cap = oldcap * 2;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof ir_blk);
		memcopy(fn->blk, old, oldcap * sizeof ir_blk);
	}
	ret ::= psyir_position
	{
		.func_cursor := psyir.position.func_cursor;
		.blk_cursor := fn->blk_count;
	};
	[fn->blk # (fn->blk_count)] = zero;
	fn->blk_count = (fn->blk_count + 1);
	psyir.position = ret;
	return ret;
};

ir_add_global : func(g : psyir_glob -> ir_val)
{
	if(psyir.prog.globals == zero)
	{
		psyir.prog.globals_cap = 64;
		psyir.prog.globals = arena_alloc(global_arena, psyir.prog.globals_cap * sizeof psyir_glob);
	}
	while(psyir.prog.globals_count >= psyir.prog.globals_cap)
	{
		oldcap ::= psyir.prog.globals_cap;
		old ::= psyir.prog.globals;
		psyir.prog.globals_cap = (psyir.prog.globals_cap * 2);
		psyir.prog.globals = arena_alloc(global_arena, psyir.prog.globals_cap * sizeof psyir_glob);
		memcopy(psyir.prog.globals, old, oldcap * sizeof psyir_glob);
	}
	idx ::= psyir.prog.globals_count;
	[psyir.prog.globals # idx] = g;
	psyir.prog.globals_count = (psyir.prog.globals_count + 1);
	return ir_globref(idx);
};

ir_add_instruction : func(inst : ir -> v0)
{
	blk ::= ir_current_block();
	if(blk->inst == zero)
	{
		blk->inst_cap = 64;
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof ir);
	}
	while(blk->inst_count >= blk->inst_cap)
	{
		old ::= blk->inst;
		oldcap ::= blk->inst_cap;
		blk->inst_cap = (blk->inst_cap * 2);
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof ir);
		memcopy(blk->inst, old, oldcap * sizeof ir);
	}
	[blk->inst # (blk->inst_count)] = inst;
	blk->inst_count = (blk->inst_count + 1);
};

ir_reposition : func(pos : psyir_position -> v0)
{
	psyir.position = pos;
};

ir_program_dump : func(-> v0)
{
	i : u64 mut;
	for(i = 0; i < psyir.prog.globals_count; i = i + 1)
	{
		psyir_glob_dump([psyir.prog.globals # i]);
	}
	for(i = 0; i < psyir.prog.fn_count; i = i + 1)
	{
		ir_val_dump(ir_fn(i));
		ir_func_dump([psyir.prog.fn # i]);
		putchar(10);
	}
};

ir_globref : func(i : u64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.globref;
		.val := i@_;
	};
};

ir_qreg : func(i : s64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := irsz.q;
		.val := i;
	};
};

ir_dreg : func(i : s64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := irsz.d;
		.val := i;
	};
};

ir_wreg : func(i : s64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := irsz.w;
		.val := i;
	};
};

ir_breg : func(i : s64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := irsz.w;
		.val := i;
	};
};

ir_xreg : func(i : s64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := irsz.x;
		.val := i;
	};
};

ir_yreg : func(i : s64 -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := irsz.y;
		.val := i;
	};
};

ir_regsize : func(r : ir_val -> irsz)
{
	if(r.tag == ir_valtag.r)
	{
		return r.size;
	}
	return irsz.q;
};

ir_imm : func(i : s64 weak -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.imm;
		.val := i;
	};
};

ir_blk : func(i : s64 weak -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.blk;
		.val := i;
	};
};

ir_fn : func(i : s64 weak -> ir_val)
{
	return ir_val
	{
		.tag := ir_valtag.fn;
		.val := i;
	};
};

ir_new_reg : func(size : irsz -> ir_val)
{
	fn ::= ir_current_function();
	num ::= fn->regcur;
	fn->regcur = (fn->regcur + 1);
	return ir_val
	{
		.tag := ir_valtag.r;
		.size := size;
		.val := num@_;
	};
};

ir_new_qreg : func(-> ir_val)
{
	return ir_new_reg(irsz.q);
};

ir_new_breg : func(-> ir_val)
{
	return ir_new_reg(irsz.b);
};

// instruction api
ir_stack : func(sz : ir_val -> ir_val)
{
	out ::= ir_new_qreg();
	ir_add_instruction(ir
	{
		.tag := irtag.stack;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := sz;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_off : func(ptr : ir_val, offset : ir_val -> ir_val)
{
	out ::= ir_new_qreg();
	ir_add_instruction(ir
	{
		.tag := irtag.off;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := ptr;
			.2 := offset;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_load : func(k : ir_val -> ir_val)
{
	out ::= ir_new_qreg();
	ir_add_instruction(ir
	{
		.tag := irtag.load;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_store : func(k : ir_val, v : ir_val -> v0)
{
	ir_add_instruction(ir
	{
		.tag := irtag.store;
		.operands := ir_val[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
		... := zero;
	});
};

ir_arith : func(type : irtag, lhs : ir_val, rhs : ir_val -> ir_val)
{
	out ::= ir_new_reg(ir_regsize(lhs));
	ir_add_instruction(ir
	{
		.tag := type;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_add : func(lhs : ir_val, rhs : ir_val -> ir_val)
{
	return ir_arith(irtag.add, lhs, rhs);
};

ir_sub : func(lhs : ir_val, rhs : ir_val -> ir_val)
{
	return ir_arith(irtag.sub, lhs, rhs);
};

ir_mul : func(lhs : ir_val, rhs : ir_val -> ir_val)
{
	return ir_arith(irtag.mul, lhs, rhs);
};

ir_div : func(lhs : ir_val, rhs : ir_val -> ir_val)
{
	return ir_arith(irtag.div, lhs, rhs);
};

ir_sized_unary : func(type : irtag, sz : irsz, op : ir_val -> ir_val)
{
	out ::= ir_new_reg(sz);
	ir_add_instruction(ir
	{
		.tag := type;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := op;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_sex16 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.sex16, irsz.w, op);
};

ir_sex32 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.sex32, irsz.d, op);
};

ir_sex64 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.sex64, irsz.q, op);
};

ir_zex16 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.zex16, irsz.w, op);
};

ir_zex32 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.zex32, irsz.d, op);
};

ir_zex64 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.zex64, irsz.q, op);
};

ir_trunc8 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.trunc8, irsz.b, op);
};

ir_trunc16 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.trunc16, irsz.w, op);
};

ir_trunc32 : func(op : ir_val -> ir_val)
{
	return ir_sized_unary(irtag.trunc32, irsz.d, op);
};

ir_cmp_eq : func(lhs : ir_val, rhs : ir_val -> ir_val)
{
	out ::= ir_new_breg();
	ir_add_instruction(ir
	{
		.tag := irtag.cmp_eq;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_jmp : func(label : psyir_position -> v0)
{
	ir_add_instruction(ir
	{
		.tag := irtag.jmp;
		.operands := ir_val[4]
		{
			.0 := ir_blk(label.blk_cursor);
			... := zero;
		};
		... := zero;
	});
};

ir_jmpif : func(cond : ir_val, blk_true : psyir_position, blk_false : psyir_position-> v0)
{
	ir_add_instruction(ir
	{
		.tag := irtag.jmpif;
		.operands := ir_val[4]
		{
			.0 := cond;
			.1 := ir_blk(blk_true.blk_cursor);
			.2 := ir_blk(blk_false.blk_cursor);
			... := zero;
		};
		... := zero;
	});
};

ir_call : func(fn : psyir_position, params : ir_val?, params_count : u64 -> ir)
{
	// -1 because fn is also an operand
	base_operands_count ::= (countof typeof(ir{}.operands)) - 1;
	extras : ir_val mut? mut := zero;
	extras_count : u64 mut := 0;
	i : u64 mut;
	if(params_count > (base_operands_count))
	{
		extras_count = (params_count - base_operands_count);
		extras = arena_alloc(global_arena, extras_count * sizeof ir_val);
		for(i = 0; i < extras_count; i = i + 1)
		{
			[extras # i] = [params # (i + base_operands_count)];
		}
	}
	inst ::= ir mut
	{
		.tag := irtag.call;
		.operands := ir_val[4]
		{
			.0 := ir_fn(fn.func_cursor);
			... := zero;
		};
		.extra_operands_count := extras_count;
		.extra_operands := extras;
	};
	min : u64 mut := params_count;
	if(base_operands_count < min)
	{
		min = base_operands_count;
	}
	memcopy(inst.operands # 1, params, min * sizeof ir_val);
	ir_add_instruction(inst);
	return inst;
};

ir_rcall : func(fn : psyir_position, params : ir_val?, params_count : u64 -> ir_val)
{
	callfn ::= [psyir.prog.fn # (fn.func_cursor)];
	out ::= ir_new_reg(callfn.ret);
	// -2 because fn is also an operand aswell as the output register
	base_operands_count ::= (countof typeof(ir{}.operands)) - 2;
	extras : ir_val mut? mut := zero;
	extras_count : u64 mut := 0;
	i : u64 mut;
	if(params_count > (base_operands_count))
	{
		extras_count = (params_count - base_operands_count);
		extras = arena_alloc(global_arena, extras_count * sizeof ir_val);
		for(i = 0; i < extras_count; i = i + 1)
		{
			[extras # i] = [params # (i + base_operands_count)];
		}
	}
	inst ::= ir mut
	{
		.tag := irtag.rcall;
		.operands := ir_val[4]
		{
			.0 := out;
			.1 := ir_fn(fn.func_cursor);
			... := zero;
		};
		.extra_operands_count := extras_count;
		.extra_operands := extras;
	};
	min : u64 mut := params_count;
	if(base_operands_count < min)
	{
		min = base_operands_count;
	}
	memcopy(inst.operands # 2, params, min * sizeof ir_val);
	ir_add_instruction(inst);
	return out;
};

ir_retnone : func(-> v0)
{
	ir_add_instruction(ir
	{
		.tag := irtag.retnone;
		.operands := zero;
		... := zero;
	});
};

ir_ret : func(v : ir_val -> v0)
{
	ir_add_instruction(ir
	{
		.tag := irtag.ret;
		.operands := ir_val[4]
		{
			.0 := v;
			... := zero;
		};
		... := zero;
	});
};
