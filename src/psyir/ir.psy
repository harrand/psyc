psyir_inst_tag : enum
{
	.stack := 1; // stack
	.cp := 2; // copy
	.jmpif := 3; // jump if cond
	.jmp := 4; // jump
	.load8 := 5; // load
	.load16 := 6; // load
	.load32 := 7; // load
	.load64 := 8; // load
	.store8 := 9; // store
	.store16 := 10; // store
	.store32 := 11; // store
	.store64 := 12; // store
	.call := 13; // call
	.ret := 14; // return
	.ret8 := 15; // return
	.ret16 := 16; // return
	.ret32 := 17; // return
	.ret64 := 18; // return

	.cmp_eq8 := 19; // ==
	.cmp_eq16 := 20; // ==
	.cmp_eq32 := 21; // ==
	.cmp_eq64 := 22; // ==
	.cmp_ne8 := 23; // !=
	.cmp_ne16 := 24; // !=
	.cmp_ne32 := 25; // !=
	.cmp_ne64 := 26; // !=
	.cmp_lt8 := 27; // <
	.cmp_lt16 := 28; // <
	.cmp_lt32 := 29; // <
	.cmp_lt64 := 30; // <
	.cmp_le8 := 31; // <=
	.cmp_le16 := 32; // <=
	.cmp_le32 := 33; // <=
	.cmp_le64 := 34; // <=
	.cmp_gt8 := 35; // >
	.cmp_gt16 := 36; // >
	.cmp_gt32 := 37; // >
	.cmp_gt64 := 38; // >
	.cmp_ge8 := 39; // >=
	.cmp_ge16 := 40; // >=
	.cmp_ge32 := 41; // >=
	.cmp_ge64 := 42; // >=
	.or8 := 43; // |
	.or16 := 44; // |
	.or32 := 45; // |
	.or64 := 46; // |
	.and8 := 47; // &
	.and16 := 48; // &
	.and32 := 49; // &
	.and64 := 50; // &
	.xor8 := 51; // ^
	.xor16 := 52; // ^
	.xor32 := 53; // ^
	.xor64 := 54; // ^
	.add8 := 55; // +
	.add16 := 56; // +
	.add32 := 57; // +
	.add64 := 58; // +
	.sub8 := 59; // -
	.sub16 := 60; // -
	.sub32 := 61; // -
	.sub64 := 62; // -
	.mul8 := 63; // *
	.mul16 := 64; // *
	.mul32 := 65; // *
	.mul64 := 66; // *
	.div8 := 67; // /
	.div16 := 68; // /
	.div32 := 69; // /
	.div64 := 70; // /
	.sex := 71; // sign extend (also HAHAHAHAHHA)
	.zex := 72; // zero extend
	.trunc := 73; // truncate
	.syscall := 69420; // syscall
};

psyir_reg : enum
{
	// arguments go in their own special registers
	// -1 is the first argument, -2 is the 2nd etc...
	// general purpose registers go from 0->infinity
};

psyir_operand_tag : enum
{
	.imm := 1;
	.r := 2;
	.blk := 3;
	.fn := 4;
};

psyir_operand : struct
{
	tag : psyir_operand_tag;
	val : s64;
};

psyir_inst : struct
{
	tag : psyir_inst_tag;
	operands : psyir_operand mut[4];
};

psyir_blk : struct
{
	inst : psyir_inst mut?;
	inst_count : u64;
	inst_cap : u64;
};

psyir_func : struct
{
	name : u8?;
	name_len : u64;
	blk : psyir_blk mut?;
	blk_count : u64;
	blk_cap : u64;

	regcur : u64;
};

psyir_operand_dump : func(op : psyir_operand -> v0)
{
	if(op.tag == psyir_operand_tag.r)
	{
		putchar('r');
	}
	if(op.tag == psyir_operand_tag.blk)
	{
		putchar('b');
	}
	if(op.tag == psyir_operand_tag.fn)
	{
		fn ::= [psyir.prog.fn # op.val];
		putbytes(fn.name, fn.name_len);
	}
	else
	{
		putsint(op.val);
	}
};

psyir_inst_dump : func(inst : psyir_inst -> v0)
{
	putzstr(enumname(inst.tag));
	putzstr(" ");
	i : u64 mut := 0;
	keep_going : bool mut := [inst.operands # i].tag != zero;
	while(keep_going)
	{
		psyir_operand_dump([inst.operands # i]);
		if(i != (countof typeof(inst.operands)) - 1)
		{
			if([inst.operands # (i + 1)].tag == zero)
			{
				keep_going = false;
			}
			else
			{
				putzstr(", ");
			}
		}
		else
		{
			keep_going = false;
		}
		i = i + 1;
	}
};

psyir_blk_dump : func(blk : psyir_blk -> v0)
{
	i : u64 mut;
	for(i = 0; i < blk.inst_count; i = i + 1)
	{
		//putchar(9);
		putzstr("  ");
		psyir_inst_dump([blk.inst # i]);
		putchar(10);
	}
};

psyir_func_dump : func(fn : psyir_func -> v0)
{
	putzstr(":");
	putchar(10);

	i : u64 mut;
	for(i = 0; i < fn.blk_count; i = i + 1)
	{
		putzstr(" ");
		psyir_operand_dump(ir_blk(i));
		putzstr(": ");
		putchar(10);
		psyir_blk_dump([fn.blk # i]);
	}
};

psyir_program : struct
{
	fn : psyir_func mut?;
	fn_count : u64;
	fn_cap : u64;	
};

psyir_position : struct
{
	func_cursor : u64;
	blk_cursor : u64;
};

psyir_api : struct
{
	prog : psyir_program;
	position : psyir_position;
};

psyir : psyir_api mut := zero;

ir_create_function : func(name : u8?, name_len : u64 -> psyir_position)
{
	if(psyir.prog.fn == zero)
	{
		psyir.prog.fn_cap = 1024;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof psyir_func);
	}
	while(psyir.prog.fn_count >= psyir.prog.fn_cap)
	{
		old ::= psyir.prog.fn;
		oldcap ::= psyir.prog.fn_cap;
		psyir.prog.fn_cap = oldcap * 2;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof psyir_func);
		memcopy(psyir.prog.fn, old, oldcap * sizeof psyir_func);
	}
	[psyir.prog.fn # (psyir.prog.fn_count)] = psyir_func
	{
		.name := name;
		.name_len := name_len;
		.regcur := 1;	
		... := zero;
	};
	psyir.position = psyir_position
	{
		.func_cursor := psyir.prog.fn_count;
		.blk_cursor := zero;
	};
	psyir.prog.fn_count = (psyir.prog.fn_count + 1);
	return ir_create_block();
};

ir_current_function : func(-> psyir_func mut?)
{
	return psyir.prog.fn # (psyir.position.func_cursor);
};

ir_current_block : func(-> psyir_blk mut?)
{
	return ir_current_function()->blk # (psyir.position.blk_cursor);
};

ir_create_block : func(-> psyir_position)
{
	fn ::= ir_current_function();
	if(fn->blk == zero)
	{
		fn->blk_cap = 8;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof psyir_blk);
	}
	while(fn->blk_count >= fn->blk_cap)
	{
		old ::= fn->blk;
		oldcap ::= fn->blk_cap;
		fn->blk_cap = oldcap * 2;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof psyir_blk);
		memcopy(fn->blk, old, oldcap * sizeof psyir_blk);
	}
	ret ::= psyir_position
	{
		.func_cursor := psyir.position.func_cursor;
		.blk_cursor := fn->blk_count;
	};
	[fn->blk # (fn->blk_count)] = zero;
	fn->blk_count = (fn->blk_count + 1);
	psyir.position = ret;
	return ret;
};

ir_add_instruction : func(inst : psyir_inst -> v0)
{
	blk ::= ir_current_block();
	if(blk->inst == zero)
	{
		blk->inst_cap = 64;
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof psyir_inst);
	}
	while(blk->inst_count >= blk->inst_cap)
	{
		old ::= blk->inst;
		oldcap ::= blk->inst_cap;
		blk->inst_cap = (blk->inst_cap * 2);
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof psyir_inst);
		memcopy(blk->inst, old, oldcap * sizeof psyir_inst);
	}
	[blk->inst # (blk->inst_count)] = inst;
	blk->inst_count = (blk->inst_count + 1);
};

ir_reposition : func(pos : psyir_position -> v0)
{
	psyir.position = pos;
};

ir_dump : func(-> v0)
{
	i : u64 mut;
	for(i = 0; i < psyir.prog.fn_count; i = i + 1)
	{
		psyir_operand_dump(ir_fn(i));
		psyir_func_dump([psyir.prog.fn # i]);
		putchar(10);
	}
};

ir_reg : func(i : s64 -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.val := i;
	};
};

ir_input_reg : func(i : s64 -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.val := -i;
	};
};

ir_imm : func(i : s64 weak -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.imm;
		.val := i;
	};
};

ir_blk : func(i : s64 weak -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.blk;
		.val := i;
	};
};

ir_fn : func(i : s64 weak -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.fn;
		.val := i;
	};
};

ir_new_reg : func(-> psyir_operand)
{
	fn ::= ir_current_function();
	num ::= fn->regcur;
	fn->regcur = (fn->regcur + 1);
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.val := num@_;
	};
};

// instruction api
ir_stack : func(sz : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.stack;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := sz;
			... := zero;
		};
	});
	return out;
};

ir_cpy : func(dst : psyir_operand, src : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.cp;
		.operands := psyir_operand[4]
		{
			.0 := dst;
			.1 := src;
			... := zero;
		};
	});
};

ir_load8 : func(k : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.load8;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
	});
	return out;
};

ir_load16 : func(k : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.load16;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
	});
	return out;
};

ir_load32 : func(k : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.load32;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
	});
	return out;
};

ir_load64 : func(k : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.load64;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
	});
	return out;
};

ir_store8 : func(k : psyir_operand, v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.store8;
		.operands := psyir_operand[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
	});
};

ir_store16 : func(k : psyir_operand, v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.store16;
		.operands := psyir_operand[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
	});
};

ir_store32 : func(k : psyir_operand, v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.store32;
		.operands := psyir_operand[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
	});
};

ir_store64 : func(k : psyir_operand, v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.store64;
		.operands := psyir_operand[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
	});
};

ir_add8 : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.add8;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_add16 : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.add16;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_add32 : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.add32;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_add64 : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_reg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.add64;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_jmp : func(label : psyir_position -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.jmp;
		.operands := psyir_operand[4]
		{
			.0 := ir_blk(label.blk_cursor);
			... := zero;
		};
	});
};

ir_jmpif : func(cond : psyir_operand, blk_true : psyir_position, blk_false : psyir_position-> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.jmpif;
		.operands := psyir_operand[4]
		{
			.0 := cond;
			.1 := ir_blk(blk_true.blk_cursor);
			.2 := ir_blk(blk_false.blk_cursor);
			... := zero;
		};
	});
};

ir_call : func(fn : psyir_position -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.call;
		.operands := psyir_operand[4]
		{
			.0 := ir_fn(fn.func_cursor);
			... := zero;
		};
	});
};

ir_ret : func(-> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret;
		.operands := zero;
	});
};

ir_ret8 : func(v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret8;
		.operands := psyir_operand[4]
		{
			.0 := v;
			... := zero;
		};
	});
};

ir_ret16 : func(v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret16;
		.operands := psyir_operand[4]
		{
			.0 := v;
			... := zero;
		};
	});
};

ir_ret32 : func(v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret32;
		.operands := psyir_operand[4]
		{
			.0 := v;
			... := zero;
		};
	});
};

ir_ret64 : func(v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret64;
		.operands := psyir_operand[4]
		{
			.0 := v;
			... := zero;
		};
	});
};
