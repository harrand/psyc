psyir_inst_tag : enum
{
	.stack := 1; // stack
	.let := 2; // copy
	.jmpif := 3; // jump if cond
	.jmp := 4; // jump
	.load := 5; // load
	.store := 9; // store
	.call := 13; // call
	.retnone := 14; // return
	.ret := 15; // return

	.cmp_eq := 19; // ==
	.cmp_ne := 23; // !=
	.cmp_lt := 27; // <
	.cmp_le := 31; // <=
	.cmp_gt := 35; // >
	.cmp_ge := 39; // >=
	.or := 43; // |
	.and := 47; // &
	.xor := 51; // ^
	.add := 55; // +
	.sub := 59; // -
	.mul := 63; // *
	.div := 67; // /
	.sex := 71; // sign extend (also HAHAHAHAHHA)
	.zex := 72; // zero extend
	.trunc := 73; // truncate
};

psyir_reg : enum
{
	// arguments go in their own special registers
	// -1 is the first argument, -2 is the 2nd etc...
	// general purpose registers go from 0->infinity
};

psyir_reg_size : enum
{
	.q := 8;
	.d := 4;
	.w := 2;
	.b := 1;
};

psyir_operand_tag : enum
{
	.imm := 1;
	.r := 2;
	.blk := 3;
	.fn := 4;
};

psyir_operand : struct
{
	tag : psyir_operand_tag;
	size : psyir_reg_size;
	val : s64;
};

psyir_inst : struct
{
	tag : psyir_inst_tag;
	operands : psyir_operand mut[4];
};

psyir_blk : struct
{
	inst : psyir_inst mut?;
	inst_count : u64;
	inst_cap : u64;
};

psyir_func : struct
{
	name : u8?;
	name_len : u64;
	blk : psyir_blk mut?;
	blk_count : u64;
	blk_cap : u64;

	regcur : u64;
};

psyir_operand_dump : func(op : psyir_operand -> v0)
{
	if(op.tag == psyir_operand_tag.r)
	{
		if(op.val < 0)
		{
			putchar('i');
			putsint(-op.val);
			return;
		}
		putzstr(enumname(op.size));
	}
	if(op.tag == psyir_operand_tag.blk)
	{
		putchar('_');
	}
	if(op.tag == psyir_operand_tag.fn)
	{
		fn ::= [psyir.prog.fn # op.val];
		putbytes(fn.name, fn.name_len);
	}
	else
	{
		putsint(op.val);
	}
};

psyir_inst_dump : func(inst : psyir_inst -> v0)
{
	putzstr(enumname(inst.tag));
	putzstr(" ");
	i : u64 mut := 0;
	keep_going : bool mut := [inst.operands # i].tag != zero;
	while(keep_going)
	{
		psyir_operand_dump([inst.operands # i]);
		if(i != (countof typeof(inst.operands)) - 1)
		{
			if([inst.operands # (i + 1)].tag == zero)
			{
				keep_going = false;
			}
			else
			{
				putzstr(", ");
			}
		}
		else
		{
			keep_going = false;
		}
		i = i + 1;
	}
};

psyir_blk_dump : func(blk : psyir_blk -> v0)
{
	i : u64 mut;
	for(i = 0; i < blk.inst_count; i = i + 1)
	{
		//putchar(9);
		putzstr("  ");
		psyir_inst_dump([blk.inst # i]);
		putchar(10);
	}
};

psyir_func_dump : func(fn : psyir_func -> v0)
{
	putzstr(":");
	putchar(10);

	i : u64 mut;
	for(i = 0; i < fn.blk_count; i = i + 1)
	{
		putzstr(" ");
		psyir_operand_dump(ir_blk(i));
		putzstr(": ");
		putchar(10);
		psyir_blk_dump([fn.blk # i]);
	}
};

psyir_program : struct
{
	fn : psyir_func mut?;
	fn_count : u64;
	fn_cap : u64;	
};

psyir_position : struct
{
	func_cursor : u64;
	blk_cursor : u64;
};

psyir_api : struct
{
	prog : psyir_program;
	position : psyir_position;
};

psyir : psyir_api mut := zero;

ir_create_function : func(name : u8?, name_len : u64 -> psyir_position)
{
	if(psyir.prog.fn == zero)
	{
		psyir.prog.fn_cap = 1024;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof psyir_func);
	}
	while(psyir.prog.fn_count >= psyir.prog.fn_cap)
	{
		old ::= psyir.prog.fn;
		oldcap ::= psyir.prog.fn_cap;
		psyir.prog.fn_cap = oldcap * 2;
		psyir.prog.fn = arena_alloc(global_arena, psyir.prog.fn_cap * sizeof psyir_func);
		memcopy(psyir.prog.fn, old, oldcap * sizeof psyir_func);
	}
	[psyir.prog.fn # (psyir.prog.fn_count)] = psyir_func
	{
		.name := name;
		.name_len := name_len;
		.regcur := 1;	
		... := zero;
	};
	psyir.position = psyir_position
	{
		.func_cursor := psyir.prog.fn_count;
		.blk_cursor := zero;
	};
	psyir.prog.fn_count = (psyir.prog.fn_count + 1);
	return ir_create_block();
};

ir_current_function : func(-> psyir_func mut?)
{
	return psyir.prog.fn # (psyir.position.func_cursor);
};

ir_current_block : func(-> psyir_blk mut?)
{
	return ir_current_function()->blk # (psyir.position.blk_cursor);
};

ir_create_block : func(-> psyir_position)
{
	fn ::= ir_current_function();
	if(fn->blk == zero)
	{
		fn->blk_cap = 8;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof psyir_blk);
	}
	while(fn->blk_count >= fn->blk_cap)
	{
		old ::= fn->blk;
		oldcap ::= fn->blk_cap;
		fn->blk_cap = oldcap * 2;
		fn->blk = arena_alloc(global_arena, fn->blk_cap * sizeof psyir_blk);
		memcopy(fn->blk, old, oldcap * sizeof psyir_blk);
	}
	ret ::= psyir_position
	{
		.func_cursor := psyir.position.func_cursor;
		.blk_cursor := fn->blk_count;
	};
	[fn->blk # (fn->blk_count)] = zero;
	fn->blk_count = (fn->blk_count + 1);
	psyir.position = ret;
	return ret;
};

ir_add_instruction : func(inst : psyir_inst -> v0)
{
	blk ::= ir_current_block();
	if(blk->inst == zero)
	{
		blk->inst_cap = 64;
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof psyir_inst);
	}
	while(blk->inst_count >= blk->inst_cap)
	{
		old ::= blk->inst;
		oldcap ::= blk->inst_cap;
		blk->inst_cap = (blk->inst_cap * 2);
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof psyir_inst);
		memcopy(blk->inst, old, oldcap * sizeof psyir_inst);
	}
	[blk->inst # (blk->inst_count)] = inst;
	blk->inst_count = (blk->inst_count + 1);
};

ir_reposition : func(pos : psyir_position -> v0)
{
	psyir.position = pos;
};

ir_dump : func(-> v0)
{
	i : u64 mut;
	for(i = 0; i < psyir.prog.fn_count; i = i + 1)
	{
		psyir_operand_dump(ir_fn(i));
		psyir_func_dump([psyir.prog.fn # i]);
		putchar(10);
	}
};

ir_inreg : func(i : s64 -> psyir_operand)
{
	return ir_qreg(-i);
};

ir_qreg : func(i : s64 -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.size := psyir_reg_size.q;
		.val := i;
	};
};

ir_dreg : func(i : s64 -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.size := psyir_reg_size.d;
		.val := i;
	};
};

ir_wreg : func(i : s64 -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.size := psyir_reg_size.w;
		.val := i;
	};
};

ir_breg : func(i : s64 -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.size := psyir_reg_size.w;
		.val := i;
	};
};

ir_imm : func(i : s64 weak -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.imm;
		.val := i;
	};
};

ir_blk : func(i : s64 weak -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.blk;
		.val := i;
	};
};

ir_fn : func(i : s64 weak -> psyir_operand)
{
	return psyir_operand
	{
		.tag := psyir_operand_tag.fn;
		.val := i;
	};
};

ir_new_qreg : func(-> psyir_operand)
{
	fn ::= ir_current_function();
	num ::= fn->regcur;
	fn->regcur = (fn->regcur + 1);
	return psyir_operand
	{
		.tag := psyir_operand_tag.r;
		.size := psyir_reg_size.q;
		.val := num@_;
	};
};

// instruction api
ir_stack : func(sz : psyir_operand -> psyir_operand)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.stack;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := sz;
			... := zero;
		};
	});
	return out;
};

ir_let : func(dst : psyir_operand, src : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.let;
		.operands := psyir_operand[4]
		{
			.0 := dst;
			.1 := src;
			... := zero;
		};
	});
};

ir_load : func(k : psyir_operand -> psyir_operand)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.load;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := k;
			... := zero;
		};
	});
	return out;
};

ir_store : func(k : psyir_operand, v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.store;
		.operands := psyir_operand[4]
		{
			.0 := k;
			.1 := v;
			... := zero;
		};
	});
};

ir_add : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.add;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_sub : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.sub;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_mul : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.mul;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_div : func(lhs : psyir_operand, rhs : psyir_operand -> psyir_operand)
{
	out ::= ir_new_qreg();
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.div;
		.operands := psyir_operand[4]
		{
			.0 := out;
			.1 := lhs;
			.2 := rhs;
			... := zero;
		};
	});
	return out;
};

ir_jmp : func(label : psyir_position -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.jmp;
		.operands := psyir_operand[4]
		{
			.0 := ir_blk(label.blk_cursor);
			... := zero;
		};
	});
};

ir_jmpif : func(cond : psyir_operand, blk_true : psyir_position, blk_false : psyir_position-> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.jmpif;
		.operands := psyir_operand[4]
		{
			.0 := cond;
			.1 := ir_blk(blk_true.blk_cursor);
			.2 := ir_blk(blk_false.blk_cursor);
			... := zero;
		};
	});
};

ir_call : func(fn : psyir_position -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.call;
		.operands := psyir_operand[4]
		{
			.0 := ir_fn(fn.func_cursor);
			... := zero;
		};
	});
};

ir_retnone : func(-> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.retnone;
		.operands := zero;
	});
};

ir_ret : func(v : psyir_operand -> v0)
{
	ir_add_instruction(psyir_inst
	{
		.tag := psyir_inst_tag.ret;
		.operands := psyir_operand[4]
		{
			.0 := v;
			... := zero;
		};
	});
};
