irapi_t : struct
{
	prog : irp mut;
	pos : irpos;
};

irapi : irapi_t mut := zero;

ir_add_func : func(name : u8?, name_len : u64, conv : irf_callconv -> irpos)
{
	if(irapi.prog.funcs == zero)
	{
		irapi.prog.funcs_cap = 8;
		irapi.prog.funcs = arena_alloc(global_arena, irapi.prog.funcs_cap * sizeof irf);
	}
	while(irapi.prog.funcs_count >= irapi.prog.funcs_cap)
	{
		oldcap ::= irapi.prog.funcs_cap;
		old ::= irapi.prog.funcs;
		irapi.prog.funcs_cap = (irapi.prog.funcs_cap * 2);
		irapi.prog.funcs = arena_alloc(global_arena, irapi.prog.funcs_cap * sizeof irf);
		memcopy(irapi.prog.funcs, old, oldcap * sizeof irf);
	}
	idx ::= irapi.prog.funcs_count;
	irapi.prog.funcs_count = (irapi.prog.funcs_count + 1);
	[irapi.prog.funcs # idx] = irf
	{
		.name := name;
		.name_len := name_len;
		.conv := conv;
		... := zero;
	};
	irapi.pos = irpos
	{
		.func_cursor := idx;
		.blk_cursor := 0;
	};
	// make an entry block
	return ir_add_blk();
};

ir_current_fn : func(-> irf mut?)
{
	return irapi.prog.funcs # (irapi.pos.func_cursor);
};

ir_add_blk : func(-> irpos)
{
	fn ::= ir_current_fn();
	if(fn->blks == zero)
	{
		fn->blks_cap = 8;
		fn->blks = arena_alloc(global_arena, fn->blks_cap * sizeof irb);
	}
	while(fn->blks_count >= fn->blks_cap)
	{
		oldcap ::= fn->blks_cap;
		old ::= fn->blks;
		fn->blks_cap = (fn->blks_cap * 2);
		fn->blks = arena_alloc(global_arena, fn->blks_cap * sizeof irb);
		memcopy(fn->blks, old, oldcap * sizeof irf);
	}
	idx ::= fn->blks_count;
	fn->blks_count = (fn->blks_count + 1);
	[fn->blks # idx] = zero;
	irapi.pos.blk_cursor = idx;
	return irapi.pos;
};

ir_getpos : func(-> irpos)
{
	return irapi.pos;
};

ir_setpos : func(pos : irpos -> v0)
{
	irapi.pos = pos;
};

ir_current_blk : func(-> irb mut?)
{
	return ir_current_fn()->blks # (irapi.pos.blk_cursor);
};

ir_add_instruction : func(inst : iri -> u64)
{
	blk ::= ir_current_blk();
	if(blk->inst == zero)
	{
		blk->inst_cap = 8;
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof iri);
	}
	while(blk->inst_count >= blk->inst_cap)
	{
		oldcap ::= blk->inst_cap;
		old ::= blk->inst;
		blk->inst_cap = (blk->inst_cap * 2);
		blk->inst = arena_alloc(global_arena, blk->inst_cap * sizeof iri);
		memcopy(blk->inst, old, oldcap * sizeof x64i);
	}
	idx ::= blk->inst_count;
	blk->inst_count = (blk->inst_count + 1);
	[blk->inst # idx] = inst;
	return idx;
};

ir_dump_disasm_to : func(w : bwriter mut? -> v0)
{
	bwrite_irp_disasm(w, irapi.prog);
};

ir_new_reg : func(type : ir_reg -> irv)
{
	fn ::= ir_current_fn();
	ret ::= irv_reg(type, fn->regcur);
	fn->regcur = (fn->regcur + 1);
	return ret;
};

// instructions api

ir_stack : func(alloc_size_bytes : u64 -> irv)
{
	out ::= ir_new_reg(ir_reg.q);
	ir_add_instruction(iri
	{
		.tag := iri_tag.stack;
		.operands := irv[4]
		{
			.0 := out;
			.1 := irv_imm(alloc_size_bytes, ir_reg.q);
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_load : func(v : irv, sz : ir_reg -> irv)
{
	out ::= ir_new_reg(sz);
	ir_add_instruction(iri
	{
		.tag := iri_tag.load;
		.operands := irv[4]
		{
			.0 := out;
			.1 := v;
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_store : func(dst : irv, to : irv -> v0)
{
	ir_add_instruction(iri
	{
		.tag := iri_tag.store;
		.operands := irv[4]
		{
			.0 := dst;
			.1 := to;
			... := zero;
		};
		... := zero;
	});
};

ir_off : func(v : irv, off : u64 -> irv)
{
	out ::= ir_new_reg(irv_size(v));
	ir_add_instruction(iri
	{
		.tag := iri_tag.off;
		.operands := irv[4]
		{
			.0 := out;
			.1 := v;
			.2 := irv_imm(off, ir_reg.q);
			... := zero;
		};
		... := zero;
	});
	return out;
};

ir_jmp : func(l : irv -> v0)
{
	ir_add_instruction(iri
	{
		.tag := iri_tag.jmp;
		.operands := irv[4]
		{
			.0 := l;
			... := zero;
		};
		... := zero;
	});
};

ir_jmpif : func(cond : irv, yes : irpos, no : irpos -> v0)
{
	ir_add_instruction(iri
	{
		.tag := iri_tag.jmpif;
		.operands := irv[4]
		{
			.0 := cond;
			.1 := irv_blkref(yes);
			.2 := irv_blkref(no);
			... := zero;
		};
		... := zero;
	});
};

ir_ret : func(v : irv -> v0)
{
	ir_add_instruction(iri
	{
		.tag := iri_tag.ret;
		.operands := irv[4]
		{
			.0 := v;
			... := zero;
		};
		... := zero;
	});
};

ir_retnone : func(-> v0)
{
	ir_add_instruction(iri
	{
		.tag := iri_tag.retnone;
		... := zero;
	});
};
