// builtins are blessed function-like things whose implementations live in the compiler
// they can be invoked at either runtime or compile time or both, depending on the builtin

builtin_entry : struct
{
	name_zstr : u8?;
	type : tyid;
	invoke_compile_time : func(params : val?, scope : lexical_scope?, source : ast? -> val);
	invoke_runtime : func(params : val?, scope : lexical_scope?, source : ast? -> val);
};

builtins : builtin_entry mut? mut := zero;
builtins_count : u64 mut := zero;
builtins_cap : u64 mut := zero;

add_builtin : func(b : builtin_entry -> v0)
{
	if(builtins == zero)
	{
		builtins_cap = 8;
		builtins = arena_alloc(global_arena, sizeof builtin_entry * builtins_cap);
	}
	while(builtins_count >= builtins_cap)
	{
		oldcap ::= builtins_cap;
		olddata ::= builtins;
		builtins_cap = (builtins_cap * 2);
		builtins = arena_alloc(global_arena, sizeof builtin_entry * builtins_cap);
		memcopy(builtins, olddata, sizeof builtin_entry * oldcap);
	}
	[builtins # builtins_count] = b;
	builtins_count = (builtins_count + 1);
};

builtin_setup : func(-> v0)
{
	add_builtin(builtin_entry
	{
		.name_zstr := "command";
		.type := ty_makefn1(tyid_string_literal(), tyid_integral_literal());
		.invoke_compile_time := s_builtin_command;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "postbuild_command";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_postbuild_command;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "assert";
		.type := ty_makefn1(tyid_bool_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_assert;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "add_source_file";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_add_source_file;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "error";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_error;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "warning";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_warning;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "message";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_message;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "add_build_file";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_add_build_file;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "output";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_output;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "executable";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_executable;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "optimization";
		.type := ty_makefn1(tyid_integral_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_optimization;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "debug_symbols";
		.type := ty_makefn1(tyid_bool_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_debug_symbols;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "add_source_directory";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_add_source_directory;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "add_link_library";
		.type := ty_makefn1(tyid_string_literal(), tyid.v0);
		.invoke_compile_time := s_builtin_add_link_library;
		.invoke_runtime := zero;
	});

	embed_return_typename ::= "embed_data";
	add_builtin(builtin_entry
	{
		.name_zstr := "embed";
		.type := ty_makefn1(tyid_string_literal(), ty_find_by_name(embed_return_typename, zstrlen(embed_return_typename)));
		.invoke_compile_time := s_builtin_embed;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "enumname";
		.type := ty_makefn1(tyid_auto(), tyid_string_literal());
		.invoke_compile_time := s_builtin_enumname;
		.invoke_runtime := cg_builtin_enumname;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "debugbreak";
		.type := ty_makefn0(tyid.v0);
		.invoke_compile_time := zero;
		.invoke_runtime := cg_builtin_debugbreak;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "alloca";
		.type := ty_makefn1(tyid.u64, ty_ptr(ty_set_qual(tyid.u8, tyqual.qual_mut), tyqual.qual_weak));
		.invoke_compile_time := zero;
		.invoke_runtime := cg_builtin_alloca;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "buildid";
		.type := ty_makefn0(tyid_integral_literal());
		.invoke_compile_time := s_builtin_buildid;
		.invoke_runtime := zero;
	});

	add_builtin(builtin_entry
	{
		.name_zstr := "thisid";
		.type := ty_makefn0(tyid_integral_literal());
		.invoke_compile_time := s_builtin_thisid;
		.invoke_runtime := zero;
	});
};

builtin_find : func(name : u8?, name_len : u64 -> builtin_entry?)
{
	i : u64 mut;
	for(i = 0; i < builtins_count; i = i + 1)
	{
		cur ::= builtins # i;
		if(zstrlen(cur->name_zstr) == name_len)
		{
			if(streql_n(cur->name_zstr, name, name_len))
			{
				return cur;
			}
		}
	}
	return zero;
};
