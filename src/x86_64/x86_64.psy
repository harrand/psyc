x64_reg : enum
{
	.rax := 1;
		.eax := 2;
			.ax := 3;
				.ah := 4;
				.al := 5;
	.rbx := 6;
		.ebx := 7;
			.bx := 8;
				.bh := 9;
				.bl := 10;
	.rcx := 11;
		.ecx := 12;
			.cx := 13;
				.ch := 14;
				.cl := 15;
	.rdx := 16;
		.edx := 17;
			.dx := 18;
				.dh := 19;
				.dl := 20;
	.rsi := 21;
		.esi := 22;
			.si := 23;
				.sih_doesnt_exist := 24;
				.sil := 25;
	.rbp := 26;
		.ebp := 27;
			.bp := 28;
				.bph_doesnt_exist := 29;
				.bpl := 30;
	.rsp := 31;
		.esp := 32;
			.sp := 33;
				.sph_doesnt_exist := 34;
				.spl := 35;
	.r8 := 36;
		.r8d := 37;
			.r8w := 38;
				.r8b_hi_doesnt_exist := 39;
				.r8b := 40;
	.r9 := 41;
		.r9d := 42;
			.r9w := 43;
				.r9b_hi_doesnt_exist := 44;
				.r9b := 45;
	.r10 := 46;
		.r10d := 47;
			.r10w := 48;
				.r10b_hi_doesnt_exist := 49;
				.r10b := 50;
	.r11 := 51;
		.r11d := 52;
			.r11w := 53;
				.r11b_hi_doesnt_exist := 54;
				.r11b := 55;
	.r12 := 56;
		.r12d := 57;
			.r12w := 58;
				.r12b_hi_doesnt_exist := 59;
				.r12b := 60;
	.r13 := 61;
		.r13d := 62;
			.r13w := 63;
				.r13b_hi_doesnt_exist := 64;
				.r13b := 65;
	.r14 := 66;
		.r14d := 67;
			.r14w := 68;
				.r14b_hi_doesnt_exist := 69;
				.r14b := 70;
	.r15 := 71;
		.r15d := 72;
			.r15w := 73;
				.r15b_hi_doesnt_exist := 74;
				.r15b := 75;
	.xmm0 := 76;
	.xmm1 := 77;
	.xmm2 := 78;
	.xmm3 := 79;
	.xmm4 := 80;
	.xmm5 := 81;
	.xmm6 := 82;
	.xmm7 := 83;
	.xmm8 := 84;
	.xmm9 := 85;
	.xmm10 := 86;
	.xmm11 := 87;
	.xmm12 := 88;
	.xmm13 := 89;
	.xmm14 := 90;
	.xmm15 := 91;
};

x64_val_tag : enum
{
	.imm := 1; // immediate value (i.e numeric literal)
	.reg := 2; // register
	.vreg := 3; // virtual register (a lowering intermediate that doesnt exist in finalised x64)
	.regval := 4; // value stored in a register
	.memval := 5; // value stored in address
};

x64_val : struct
{
	tag : x64_val_tag;
	reg : x64_reg;
	addr : u64;
};

x64_inst_tag : enum
{
	.mov := 1;
	.push := 2;
	.pop := 3;
	.cwtl := 4;
	.cltq := 5;
	.cqto := 6;
	.inc := 7;
	.dec := 8;
	.neg := 9;
	.not := 10;

	.leaq := 11;
	.add := 12;
	.sub := 13;
	.mul := 14;
	.imul := 15;
	.div := 16;
	.idiv := 17;
	.xor := 18;
	.or := 19;
	.and := 20;

	.shl := 21;
	.sar := 22;
	.shr := 23;
	
	.movss := 24;
};

x64_inst : struct
{
	tag : x64_inst_tag;
	operands : x64_val mut[4];
};

x64_func : struct
{
	ret_register : x64_val;
	inst : x64_inst mut?;
	inst_count : u64;
	inst_cap : u64;
	virtual_registers : bool;
};

x64_callconv : enum
{
	.sysv := 1;
};

x64_virtual_reg : func(psy_reg : ir_val -> x64_val)
{
	// a virtual register is not a real x64 register
	// but a intermediate conversion between psyir and x64
	// basically a representation of the psyir register in a format that fits in a x64 instruction
	reg : x64_reg mut := zero;
	if(psy_reg.size == irsz.q)
	{
		reg = x64_reg.rax;
	}
	if(psy_reg.size == irsz.d)
	{
		reg = x64_reg.eax;
	}
	if(psy_reg.size == irsz.w)
	{
		reg = x64_reg.ax;
	}
	if(psy_reg.size == irsz.b)
	{
		reg = x64_reg.al;
	}
	if(psy_reg.size == irsz.x)
	{
		reg = x64_reg.xmm4;
	}
	if(psy_reg.size == irsz.y)
	{
		reg = x64_reg.xmm8;
	}
	return x64_val
	{
		.tag := x64_val_tag.vreg;
		.reg := reg;
		.addr := psy_reg.val@_;
	};
};

x64_regval : func(reg : x64_reg -> x64_val)
{
	return x64_val
	{
		.tag := x64_val_tag.reg;
		.reg := reg;
	};
};

x64_imm : func(imm : s64 weak -> x64_val)
{
	return x64_val
	{
		.tag := x64_val_tag.imm;
		.addr := imm;
	};
};

x64_ir_val : func(v : ir_val -> x64_val)
{
	if(v.tag == ir_valtag.imm)
	{
		return x64_imm(v.val);
	}
	if(v.tag == ir_valtag.r)
	{
		return x64_virtual_reg(v);
	}
	return zero;
};

x64_ir_stack : func(stack : ir -> x64_inst[2])
{
	// ir looks like this:
	// stack q0, 8

	// x64 looks like this:
	// sub rsp, 8
	// mov q0, rsp
	return x64_inst[2]
	{
		.0 := x64_inst
		{
			.tag := x64_inst_tag.sub;
			.operands := x64_val[4]
			{
				.0 := x64_regval(x64_reg.rsp);
				.1 := x64_ir_val([stack.operands # 1]);
				... := zero;
			};
		};
		.1 := x64_inst
		{
			.tag := x64_inst_tag.mov;
			.operands := x64_val[4]
			{
				.0 := x64_virtual_reg([stack.operands # 0]);
				.1 := x64_regval(x64_reg.rsp);
				... := zero;
			};
		};
	};
};

x64_ir_off : func(off : ir -> x64_inst[2])
{
	// probably ought to be a lea with a memory operand but an add+mov is simple enough for now
	return x64_inst[2]
	{
		.0 := x64_inst
		{
			.tag := x64_inst_tag.add;
			.operands := x64_val[4]
			{
				.0 := x64_ir_val([off.operands # 1]);
				.1 := x64_ir_val([off.operands # 2]);
				... := zero;
			};
		};
		.1 := x64_inst
		{
			.tag := x64_inst_tag.mov;
			.operands := x64_val[4]
			{
				.0 := x64_ir_val([off.operands # 0]);
				.1 := x64_ir_val([off.operands # 1]);
				... := zero;
			};
		};
	};
};

x64_func_ir : func(fn : ir_func, conv : x64_callconv -> x64_func)
{
	return zero;
};
