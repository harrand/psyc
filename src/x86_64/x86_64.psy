x64_reg : enum
{
	.rax := 1;
		.eax := 2;
			.ax := 3;
				.ah := 4;
				.al := 5;
	.rbx := 6;
		.ebx := 7;
			.bx := 8;
				.bh := 9;
				.bl := 10;
	.rcx := 11;
		.ecx := 12;
			.cx := 13;
				.ch := 14;
				.cl := 15;
	.rdx := 16;
		.edx := 17;
			.dx := 18;
				.dh := 19;
				.dl := 20;
	.rsi := 21;
		.esi := 22;
			.si := 23;
				.sih_doesnt_exist := 24;
				.sil := 25;
	.rbp := 26;
		.ebp := 27;
			.bp := 28;
				.bph_doesnt_exist := 29;
				.bpl := 30;
	.rsp := 31;
		.esp := 32;
			.sp := 33;
				.sph_doesnt_exist := 34;
				.spl := 35;
	.r8 := 36;
		.r8d := 37;
			.r8w := 38;
				.r8b_hi_doesnt_exist := 39;
				.r8b := 40;
	.r9 := 41;
		.r9d := 42;
			.r9w := 43;
				.r9b_hi_doesnt_exist := 44;
				.r9b := 45;
	.r10 := 46;
		.r10d := 47;
			.r10w := 48;
				.r10b_hi_doesnt_exist := 49;
				.r10b := 50;
	.r11 := 51;
		.r11d := 52;
			.r11w := 53;
				.r11b_hi_doesnt_exist := 54;
				.r11b := 55;
	.r12 := 56;
		.r12d := 57;
			.r12w := 58;
				.r12b_hi_doesnt_exist := 59;
				.r12b := 60;
	.r13 := 61;
		.r13d := 62;
			.r13w := 63;
				.r13b_hi_doesnt_exist := 64;
				.r13b := 65;
	.r14 := 66;
		.r14d := 67;
			.r14w := 68;
				.r14b_hi_doesnt_exist := 69;
				.r14b := 70;
	.r15 := 71;
		.r15d := 72;
			.r15w := 73;
				.r15b_hi_doesnt_exist := 74;
				.r15b := 75;
	.xmm0 := 76;
	.xmm1 := 77;
	.xmm2 := 78;
	.xmm3 := 79;
	.xmm4 := 80;
	.xmm5 := 81;
	.xmm6 := 82;
	.xmm7 := 83;
	.xmm8 := 84;
	.xmm9 := 85;
	.xmm10 := 86;
	.xmm11 := 87;
	.xmm12 := 88;
	.xmm13 := 89;
	.xmm14 := 90;
	.xmm15 := 91;
};

x64_val_tag : enum
{
	.imm := 1; // immediate value (i.e numeric literal)
	.reg := 2; // register
	.vreg := 3; // virtual register (a lowering intermediate that doesnt exist in finalised x64. this gets resolved during register allocation)
	.memreg := 4; // memory location computed from a register (plus an offset which can be 0) i.e [rax + 32]
	.vmemreg := 5; // memory location computed from a virtual register (plus an offset which can be 0) i.e [rax + 32]
	.memaddr := 6; // absolute memory address
	.vfn := 7; // virtual function (a lowering intermediate that doesnt exist in finalised x64. this gets resolved at link time)
	.instptr := 8; // instruction pointer (a lowering intermediate that doesnt exist in finalised x64. this gets resolved at link time)
};

x64_val : struct
{
	tag : x64_val_tag;
	// ignored unless tag is reg, vreg, memreg, vmemreg
	reg : x64_reg;
	// the meaning of this depends on the tag
	// imm => the actual numeric literal
	// memreg => the offset, in bytes
	// vmemreg => the offset, in bytes
	// memaddr => the absolute value of the address
	// vfn => depends on what is being lowered to x64.
	//		for psyir, the index of the psyir function being referred to (i.e psyir_program.fn[addr])
	// instptr => the index of the already-encoded instruction in this function (i.e x64_func.inst[addr])
	addr : u64;
};

x64_inst_tag : enum
{
	.mov := 1;
	.push := 2;
	.pop := 3;
	.cwtl := 4;
	.cltq := 5;
	.cqto := 6;
	.inc := 7;
	.dec := 8;
	.neg := 9;
	.not := 10;

	.leaq := 11;
	.add := 12;
	.sub := 13;
	.mul := 14;
	.imul := 15;
	.div := 16;
	.idiv := 17;
	.xor := 18;
	.or := 19;
	.and := 20;

	.shl := 21;
	.sar := 22;
	.shr := 23;
	
	.call := 24;
	.movss := 25;
};

x64_inst : struct
{
	tag : x64_inst_tag;
	operands : x64_val mut[4];
};

x64_func : struct
{
	ret_register : x64_val;
	inst : x64_inst mut?;
	inst_count : u64;
	inst_cap : u64;
	virtual_registers : bool;
};

x64_callconv : enum
{
	.sysv := 1;
	.win64 := 2;
};

x64_program : struct
{
	fn : x64_func mut?;
	fn_count : u64;
	fn_cap : u64;
};

x64_register : func(reg : x64_reg -> x64_val)
{
	return x64_val
	{
		.tag := x64_val_tag.reg;
		.reg := reg;
	};
};

x64_imm : func(imm : s64 weak -> x64_val)
{
	return x64_val
	{
		.tag := x64_val_tag.imm;
		.addr := imm;
	};
};

x64_copy_8bytes_to_stack : func(rsp_offset : u64, src : x64_val -> x64_inst)
{
	// mov qword[rsp], src
	return x64_inst
	{
		.tag := x64_inst_tag.mov;
		.operands := x64_val[4]
		{
			.0 := x64_val
			{
				.tag := x64_val_tag.memreg;
				.reg := x64_reg.rsp;
				.addr := rsp_offset;
			};
			.1 := src;
		};
	};
};

x86_64 : x64_program mut := zero;

x64_add_func : func(fn : x64_func -> u64)
{
	if(x86_64.fn == zero)
	{
		x86_64.fn_cap = 1024;
		x86_64.fn = arena_alloc(global_arena, x86_64.fn_cap * sizeof x64_func);
	}
	while(x86_64.fn_count >= x86_64.fn_cap)
	{
		old ::= x86_64.fn;
		oldcap ::= x86_64.fn_cap;
		x86_64.fn_cap = oldcap * 2;
		x86_64.fn = arena_alloc(global_arena, x86_64.fn_cap * sizeof x64_func);
		memcopy(x86_64.fn, old, oldcap * sizeof x64_func);
	}
	idx ::= x86_64.fn_count;
	[x86_64.fn # idx] = fn;
	x86_64.fn_count = (x86_64.fn_count + 1);
	return idx;
};

x64_val_dump : func(v : x64_val -> v0)
{
	if(v.tag == x64_val_tag.imm)
	{
		putsint(v.addr);
	}
	if(v.tag == x64_val_tag.reg)
	{
		putzstr(enumname(v.reg));
	}
	if(v.tag == x64_val_tag.vreg)
	{
		psyc_colour_blue();
		putzstr(enumname(v.reg));
		psyc_colour_reset();
	}
	if(v.tag == x64_val_tag.memreg)
	{
		putzstr("[");
		putzstr(enumname(v.reg));
		putzstr(" + ");
		putuint(v.addr);
		putzstr("]");
	}
	if(v.tag == x64_val_tag.vmemreg)
	{
		putzstr("[");
		psyc_colour_blue();
		putzstr(enumname(v.reg));
		psyc_colour_reset();
		putzstr(" + ");
		putuint(v.addr);
		putzstr("]");
	}
	if(v.tag == x64_val_tag.memaddr)
	{
		putzstr("[");
		putuint(v.addr);
		putzstr("]");
	}
	if(v.tag == x64_val_tag.vfn)
	{
		psyc_colour_blue();
		irfn ::= [psyir.prog.fn # (v.addr)];
		putbytes(irfn.name, irfn.name_len);
		psyc_colour_reset();
	}
	if(v.tag == x64_val_tag.instptr)
	{
		psyc_colour_blue();
		putzstr("inst");
		putuint(v.addr);
		psyc_colour_reset();
	}
};

x64_operand_count : func(inst : x64_inst -> u64)
{
	i : u64 mut;
	for(i = 0; i < countof typeof(inst.operands); i = i + 1)
	{
		if([inst.operands # i].tag == zero)
		{
			return i;
		}
	}
	return i;
};

x64_dump : func(inst : x64_inst -> v0)
{
	if(inst.tag == zero)
	{
		putzstr("nop");
		putchar(10);
		return;
	}
	putzstr(enumname(inst.tag));	
	putzstr(" ");
	i : u64 mut;
	count ::= x64_operand_count(inst);
	for(i = 0; i < count; i = i + 1)
	{
		x64_val_dump([inst.operands # i]);
		if(i != (count - 1))
		{
			putzstr(", ");
		}
	}
	putchar(10);
};

x64_func_dump : func(fn : x64_func -> v0)
{
	putzstr(":");
	putchar(10);
	i : u64 mut;
	for(i = 0; i < fn.inst_count; i = i + 1)
	{
		putzstr("  ");
		x64_dump([fn.inst # i]);
		putchar(10);
	}
};

x64_program_dump : func( -> v0)
{
	i : u64 mut;
	for(i = 0; i < x86_64.fn_count; i = i + 1)
	{
		putzstr("func_");
		putuint(i);
		x64_func_dump([x86_64.fn # i]);
		putchar(10);
	}
};
