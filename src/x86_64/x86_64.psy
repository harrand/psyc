x64_reg : enum
{
	.rax := 0;
	.rcx := 1;
	.rdx := 2;
	.rbx := 3;
	.rsp := 4;
	.rbp := 5;
	.rsi := 6;
	.rdi := 7;
	.r8 := 8;
	.r9 := 9;
	.r10 := 10;
	.r11 := 11;
	.r12 := 12;
	.r13 := 13;
	.r14 := 14;
	.r15 := 15;
};

x64v_tag : enum
{
	// immediate value
	//	v1: size 8/16/32/64
	//	v2: the actual immediate value
	.imm := 0;
	// register
	//	r1: which register to use (cannot be null)
	//	v1: size 8/16/32/64/128/256/512 (e.g x64v_tag.rax, v1 = 32 means eax, v1 = 128 means xmm0)
	.reg := 1;
	// memory operand of the form 'v1 PTR [r1v2 + r2v3 * immv4 + v5immv6]'
	//	r1: base register (ignored if v2 is 0)
	//	r2: index register (ignored if v3 is 0)
	//	v1: memory operand size 8/16/32/64/128/256/512 (e.g 8 is BYTE PTR, 64 is QWORD PTR, 256 is YWORD PTR)
	//	v2: base register size 0/8/16/32/64 (see .reg|v1 above, 0 means no base register)
	//	v3: index register size 0/8/16/32/64 (0 means no index register)
	//	v4: scale 1/2/4/8 (*must* be one of these)
	//	v5: size of the displacement immediate 8/32 only (ignored if v6 is 0)
	//	v6: value of displacement (0 means no displacement)
	.memreg := 2;
	// absolute memory address
	//	v1: the address
	.addr := 3;
	//	v1: a displacement from the rip register
	//	v2: size of the displacement immediate 8/32 only
	.ripreladdr := 4;
};

x64v : struct
{
	tag : x64v_tag;
	r1 : x64_reg;
	r2 : x64_reg;
	v1 : u64;
	v2 : u64;
	v3 : u64;
	v4 : u64;
	v5 : u64;
	v6 : u64;
};
