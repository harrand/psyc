// the following functions dont care which table we're in, we're just getting the offset into the table depending on what the operands are
x64i_encoding_table_base_offset_1op : func(inst : x64i -> u64)
{
	// one operand r/m
	op ::= [inst.operands # 0];
	sz ::= x64v_size(op);

	// r8 => 0
	// ...
	// r64 => 3
	idx : u64 mut := log2(sz) - 3;
	return idx;
};

x64i_encoding_table_base_offset_2op : func(inst : x64i -> u64)
{
	// two operands
	// assume both are the same size
	dst ::= [inst.operands # 0];
	src ::= [inst.operands # 1];
	sz ::= x64v_size(dst);
	//x64_require_same_size(dst, src);

	// r8 => 0
	// ...
	// r64 => 3
	idx : u64 mut := log2(sz) - 3;

	// if we are rm/r, add 0
	// if we are r/rm, add 4
	// if we are rm/imm, add 8
	if(x64v_is_reg(dst) && x64v_is_mem(src))
	{
		idx = idx + 4;
	}
	if(x64v_is_imm(src))
	{
		idx = idx + 8;
	}
	return idx;
};

// lea is a special case
x64i_encoding_table_base_offset_lea : func(inst : x64i -> u64)
{
	r ::= [inst.operands # 0];
	sz ::= x64v_size(r);
	// sz can never be 8
	// r16 => 0
	// ...
	// r64 => 2
	idx : u64 mut := log2(sz) - 4;
	return idx;
};

x64i_ext_opcode_plus_0 ::= 2;

encoding_tbl_mov ::= x64i_enc[12]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // MOV r/m8, r8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x88;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op0;
			... := zero;
		};
	};
	.1 := x64i_enc // MOV r/m16, r16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x89;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.2 := x64i_enc // MOV r/m32, r32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x89;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.3 := x64i_enc // MOV r/m64, r64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x89;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.4 := x64i_enc // MOV r8,r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x8a;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.5 := x64i_enc // MOV r16,r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x8b;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.6 := x64i_enc // MOV r32,r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x8b;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.7 := x64i_enc // MOV r64,r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x8b;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.8 := x64i_enc // MOV r/m8,imm8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xc6;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.9 := x64i_enc // MOV r/m16,imm16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0xc7;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.10 := x64i_enc // MOV r/m32,imm32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xc7;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.11 := x64i_enc // MOV r/m64,imm32
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0xc7;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
};

encoding_push ::= x64i_enc // push r64
{
	// no rex.w needed
	.legacy_prefixes := zero;
	.rex_prefix := zero;
	.opcode := 0x50;
	.ext := x64i_ext.plus_reg;
	.operand_types := x64v_enc[4]
	{
		.0 := x64v_enc.r;
		... := zero;
	};
	.clobbers := x64_clobber[4]
	{
		.0 := x64_clobber.op0;
		.1 := x64_clobber.rsp;
		... := zero;
	};
};

encoding_pop ::= x64i_enc // pop r64
{
	// no rex.w needed
	.legacy_prefixes := zero;
	.rex_prefix := zero;
	.opcode := 0x58;
	.ext := x64i_ext.plus_reg;
	.operand_types := x64v_enc[4]
	{
		.0 := x64v_enc.r;
		... := zero;
	};
	.clobbers := x64_clobber[4]
	{
		.0 := x64_clobber.op0;
		.1 := x64_clobber.rsp;
		... := zero;
	};
};

encoding_nop ::= x64i_enc // 1 byte nop
{
	.legacy_prefixes := zero;
	.rex_prefix := zero;
	.opcode := 0x90;
	.ext := zero;
	.operand_types := zero;
	.clobbers := zero;
};

encoding_ret ::= x64i_enc // near ret
{
	.legacy_prefixes := zero;
	.rex_prefix := zero;
	.opcode := 0xc3;
	.ext := zero;
	.operand_types := zero;
	.clobbers := zero;
};

encoding_cbw ::= x64i_enc // cbw
{
	.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
	.rex_prefix := zero;
	.opcode := 0x98;
	.ext := zero;
	.operand_types := zero;
	.clobbers := x64_clobber[4]
	{
		.0 := x64_clobber.rax;
		... := zero;
	};
};

encoding_cwde ::= x64i_enc // cwde
{
	.legacy_prefixes := zero;
	.rex_prefix := zero;
	.opcode := 0x98;
	.ext := zero;
	.operand_types := zero;
	.clobbers := x64_clobber[4]
	{
		.0 := x64_clobber.rax;
		... := zero;
	};
};

encoding_cdqe ::= x64i_enc // cdqe
{
	.legacy_prefixes := zero;
	.rex_prefix := x64_rex_prefix.rex_w;
	.opcode := 0x98;
	.ext := zero;
	.operand_types := zero;
	.clobbers := x64_clobber[4]
	{
		.0 := x64_clobber.rax;
		... := zero;
	};
};

encoding_tbl_inc ::= x64i_enc[4]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // INC r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xFE;
		.ext := x64i_ext_opcode_plus_0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.1 := x64i_enc // INC r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0xFF;
		.ext := x64i_ext_opcode_plus_0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.2 := x64i_enc // INC r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xFF;
		.ext := x64i_ext_opcode_plus_0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.3 := x64i_enc // INC r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0xFF;
		.ext := x64i_ext_opcode_plus_0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
};

encoding_tbl_dec ::= x64i_enc[4]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // DEC r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xFE;
		.ext := x64i_ext_opcode_plus_0 + 1;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.1 := x64i_enc // DEC r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0xFF;
		.ext := x64i_ext_opcode_plus_0 + 1;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.2 := x64i_enc // DEC r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xFF;
		.ext := x64i_ext_opcode_plus_0 + 1;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.3 := x64i_enc // DEC r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0xFF;
		.ext := x64i_ext_opcode_plus_0 + 1;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
};

encoding_tbl_neg ::= x64i_enc[4]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // NEG r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xF6;
		.ext := x64i_ext_opcode_plus_0 + 3;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.1 := x64i_enc // NEG r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0xF7;
		.ext := x64i_ext_opcode_plus_0 + 3;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.2 := x64i_enc // NEG r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xF7;
		.ext := x64i_ext_opcode_plus_0 + 3;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.3 := x64i_enc // NEG r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0xF7;
		.ext := x64i_ext_opcode_plus_0 + 3;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
};

encoding_tbl_not ::= x64i_enc[4]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // NOT r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xF6;
		.ext := x64i_ext_opcode_plus_0 + 2;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.1 := x64i_enc // NOT r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0xF7;
		.ext := x64i_ext_opcode_plus_0 + 2;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.2 := x64i_enc // NOT r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0xF7;
		.ext := x64i_ext_opcode_plus_0 + 2;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.3 := x64i_enc // NOT r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0xF7;
		.ext := x64i_ext_opcode_plus_0 + 2;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
};

encoding_tbl_lea ::= x64i_enc[3]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // LEA r16,m
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x8d;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.m;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.1 := x64i_enc // LEA r32,m
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x8d;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.m;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.2 := x64i_enc // LEA r64,m
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x8d;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.m;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
};

encoding_tbl_add ::= x64i_enc[12]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // ADD r/m8, r8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x00;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.1 := x64i_enc // ADD r/m16, r16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x01;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.2 := x64i_enc // ADD r/m32, r32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x01;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.3 := x64i_enc // ADD r/m64, r64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x01;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.4 := x64i_enc // ADD r8,r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x02;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.5 := x64i_enc // ADD r16,r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x03;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.6 := x64i_enc // ADD r32,r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x03;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.7 := x64i_enc // ADD r64,r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x03;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.8 := x64i_enc // ADD r/m8,imm8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x80;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.9 := x64i_enc // ADD r/m16,imm16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x81;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.10 := x64i_enc // ADD r/m32,imm32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x81;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.11 := x64i_enc // ADD r/m64,imm32
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x81;
		.ext := x64i_ext_opcode_plus_0 + 0;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
};

encoding_tbl_sub ::= x64i_enc[12]
{
	// REX.W and operand override 0x66 is already included when necessary
	// however for non-64-bit operands no REX bits are provided at all
	// if you're encoding any of these and either operands are r8-15, you *must* add REX and any of the non-W bits you need.
	.0 := x64i_enc // SUB r/m8, r8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x28;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.1 := x64i_enc // SUB r/m16, r16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x29;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.2 := x64i_enc // SUB r/m32, r32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x29;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.3 := x64i_enc // SUB r/m64, r64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x29;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.r;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.4 := x64i_enc // SUB r8,r/m8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x2a;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.5 := x64i_enc // SUB r16,r/m16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x2b;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.6 := x64i_enc // SUB r32,r/m32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x2b;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.7 := x64i_enc // SUB r64,r/m64
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x2b;
		.ext := x64i_ext.reg;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.r;
			.1 := x64v_enc.rm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			.1 := x64_clobber.op1;
			... := zero;
		};
	};
	.8 := x64i_enc // SUB r/m8,imm8
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x80;
		.ext := x64i_ext_opcode_plus_0 + 5;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.9 := x64i_enc // SUB r/m16,imm16
	{
		.legacy_prefixes := x64_legacy_prefix[4]{.0 := x64_legacy_prefix.operand_size_override; ... := zero;};
		.rex_prefix := zero;
		.opcode := 0x81;
		.ext := x64i_ext_opcode_plus_0 + 5;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.10 := x64i_enc // SUB r/m32,imm32
	{
		.legacy_prefixes := zero;
		.rex_prefix := zero;
		.opcode := 0x81;
		.ext := x64i_ext_opcode_plus_0 + 5;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
	.11 := x64i_enc // SUB r/m64,imm32
	{
		.legacy_prefixes := zero;
		.rex_prefix := x64_rex_prefix.rex_w;
		.opcode := 0x81;
		.ext := x64i_ext_opcode_plus_0 + 5;
		.operand_types := x64v_enc[4]
		{
			.0 := x64v_enc.rm;
			.1 := x64v_enc.imm;
			... := zero;
		};
		.clobbers := x64_clobber[4]
		{
			.0 := x64_clobber.op0;
			... := zero;
		};
	};
};

