panic_assert_failure : func(msg : u8? -> v0)
{
	psyc_panic_begin(zero);
	putzstr(msg);
	psyc_diag_end();
	psyc_exit_failure();
};

x64_mod : enum
{
	.disp0  := 0b00;
	.disp8  := 0b01;
	.disp32 := 0b10;
	.reg	:= 0b11;
};

x64_legacy_prefix : enum
{
	// group 1
	.lock := 0xf0;
	.repnz := 0xf2;
	.repz := 0xf3;
	// group 2
	.cs_seg_override := 0x2e;
	.ss_seg_override := 0x36;
	.ds_seg_override := 0x3e;
	.es_seg_override := 0x26;
	.fs_seg_override := 0x64;
	.gs_seg_override := 0x65;
	.branch_not_taken := 0x2e;
	// group 3
	.operand_size_override := 0x66;
	// group 4
	.address_size_override := 0x67;
};

x64_rex_prefix : enum
{
	.rex   := 0b01000000;
	.rex_w := 0b01001000;// 0: operand size determined by CS.D; 1: 64-bit operand size
	.rex_r := 0b01000100;// extension of ModR/M reg
	.rex_x := 0b01000010;// extension of SIB index
	.rex_b := 0b01000001;// extension of ModR/M rm, SIB base, or Opcode reg
	.all_but_w := 0b01000111;// REX RXB, no W
	.all := 0b01001111;// REX WRXB, all high
};

x64i_ext : enum
{
	.reg      := 1; // /r
	.plus_reg := 3; // + rb
	.opcode_plus_n   := 2; // /0
	// 3 => /1
	// 4 => /2
	// etc...
};

x64i_ext_opcode_plus_0 ::= 2;

x64v_enc : enum
{
	.r := 1;
	.rm := 2;
	.imm := 3;
};

x64i_enc : struct
{
	legacy_prefixes : x64_legacy_prefix[4];
	rex_prefix : x64_rex_prefix;
	opcode : u16;
	ext : x64i_ext weak;
	operand_types : x64v_enc[4];
};

bwrite_x64i_nop_encode : func(w : bwriter mut?, nop : x64i -> v0)
{
	// ignore operands
	bwrite8(w, 0x90);
};

x64i_encode_mov : func(mov : x64i -> x64i_enc)
{
	return [encoding_tbl_mov # x64i_encoding_table_base_offset_2op(mov)];
};

x64_invalid_modrm : u8 static := 0xff;

x64i_encode_modrm : func(enc : x64i_enc mut?, operands : x64v?, operands_count : u64 -> u8)
{
	mod_bits : u8 mut := 0;
	reg_bits : u8 mut := 0;
	rm_bits : u8 mut := 0;

	rm_idx : u64 mut := -1;
	r_idx : u64 mut := -1;
	imm_idx : u64 mut := -1;

	i : u64 mut;
	for(i = 0; i < operands_count; i = i + 1)
	{
		type ::= [enc->operand_types # i];
		if(type == x64v_enc.rm)
		{
			rm_idx = i;
		}
		if(type == x64v_enc.r)
		{
			r_idx = i;
		}
		if(type == x64v_enc.imm)
		{
			imm_idx = i;
		}
	}

	rm : x64v mut := zero;
	r : x64v mut := zero;

	if(rm_idx != -1)
	{
		rm = [operands # rm_idx];

		// mod cannot be 0b11
		if(rm.v6 == 0)
		{
			// there is no displacement
			mod_bits = 0b00;
		}
		else
		{
			if(rm.v5 == 8)
			{
				mod_bits = 0b01;
			}
			if(rm.v5 == 32)
			{
				mod_bits = 0b10;
			}
		}
		rm_bits = rm.r1@s64@u8;
		if(rm_bits > 0b111)
		{
			// extend ModR/M rm
			rm_bits = (rm_bits & 0b111);
			enc->rex_prefix = (enc->rex_prefix | x64_rex_prefix.rex_b);
		}
	}
	if(r_idx != -1)
	{
		r = [operands # r_idx];

		if((imm_idx == -1) && (rm_idx == -1) && (operands_count == 2))
		{
			// both are registers
			mod_bits = 0b11;
		}
		reg_bits = r.r1@s64@u8;
		if(reg_bits > 0b111)
		{
			// extend ModR/M reg
			reg_bits = (reg_bits & 0b111);
			enc->rex_prefix = (enc->rex_prefix | x64_rex_prefix.rex_r);
		}
	}

	if(enc->ext@s64 >= x64i_ext_opcode_plus_0)
	{
		// /N
		reg_bits = (enc->ext@s64 - x64i_ext_opcode_plus_0)@u8;
	}

	// if there's an index register, or scale != 1, r/m must be 0b100
	if((rm_idx != -1) && ((rm.v3 != 0) || (rm.v4 != 1)))
	{
		if(x64v_is_mem(rm))
		{
			rm_bits = 0b100;
		}
		else
		{
			// rm is definitely a register
			// if the other thing wasnt a register then we dont have mod = 0b11
			// if its an immediate then we do still want 0b11
			if(imm_idx != -1)
			{
				mod_bits = 0b11;
			}
		}
	}

	if((enc->ext == x64i_ext.reg) && (imm_idx != -1))
	{
		return x64_invalid_modrm;
	}

	return (mod_bits << 6) | (reg_bits << 3) | rm_bits;
};

x64i_encode : func(inst : x64i -> x64i_enc)
{
	ret : x64i_enc mut;
	if(inst.tag == x64i_tag.mov)
	{
		ret = x64i_encode_mov(inst);
	}
	// todo: generate the modr/m here if necessary

	// check if any operands are extended registers/spl/dil/sil/bpl (requires base rex at least)
	i : u64 mut;
	needs_rex : bool mut := false;
	for(i = 0; i < x64i_operand_count(inst); i = i + 1)
	{
		op ::= [inst.operands # i];
		if(x64v_contains_extended_register(op) || x64v_contains_spl_dil_sil_bpl(op))
		{
			needs_rex = true;
		}
	}
	// add rex prefix if we absolutely need one (crucially: dont add it unless we need it, because its an extra byte to every instruction)
	if((ret.rex_prefix == zero) && needs_rex)
	{
		ret.rex_prefix = x64_rex_prefix.rex;
	}
	// note: rex_w is already checked because its baked into the encoding tables indexed by x64i_encoding_table_base_offset_2op et al
	// todo: check if there is an extended register in modr/m.reg => requires rex_r
	// todo: check if there is an extended register in modr/m.r/m => requires rex_b
	// todo: check if there is an extended register in SIB.index => requires rex_x
	// todo: check if there is an extended register in opcode+rd => requires rex_b
	return ret;
};

bwrite_x64i_encode : func(w : bwriter mut?, inst : x64i -> v0)
{
	// get the x64i_enc somehow (normally from an encoding tbl)
	enc ::= x64i_encode(inst);
	// rex-w is handled for us by x64i_encode, but the others arent.
	// todo: handle rex non-w bits
	if(enc.rex_prefix != zero)
	{
		bwrite8(w, enc.rex_prefix@s64);
	}

	// opcodes are 1-2 bytes
	// if its 1 byte then only print 1!!!
	if(enc.opcode <= 0xff)
	{
		bwrite8(w, enc.opcode);
	}
	else
	{
		bwrite16(w, enc.opcode);
	}

	modrm ::= x64i_encode_modrm(ref enc, inst.operands # 0, x64i_operand_count(inst));
	if(modrm != x64_invalid_modrm)
	{
		bwrite8(w, modrm);
		if((modrm.mod != 0b11) && (modrm.rm == 0b100))
		{
			// todo: need a SIB byte!!!
		}
	}
	// todo: immediates...
};
