x64_reg : enum
{
	.rax := 0;
	.rcx := 1;
	.rdx := 2;
	.rbx := 3;
	.rsp := 4;
	.rbp := 5;
	.rsi := 6;
	.rdi := 7;
	.r8 := 8;
	.r9 := 9;
	.r10 := 10;
	.r11 := 11;
	.r12 := 12;
	.r13 := 13;
	.r14 := 14;
	.r15 := 15;
};

x64v_tag : enum
{
	// immediate value
	//	v1: size 8/16/32/64
	//	v2: the actual immediate value
	.imm := 0;
	// register
	//	r1: which register to use (cannot be null)
	//	v1: size 8/16/32/64/128/256/512 (e.g x64v_tag.rax, v1 = 32 means eax, v1 = 128 means xmm0)
	.reg := 1;
	// memory operand of the form 'v1 PTR [r1v2 + r2v3 * immv4 + v5immv6]'
	//	r1: base register (ignored if v2 is 0)
	//	r2: index register (ignored if v3 is 0)
	//	v1: memory operand size 8/16/32/64/128/256/512 (e.g 8 is BYTE PTR, 64 is QWORD PTR, 256 is YWORD PTR)
	//	v2: base register size 0/8/16/32/64 (see .reg|v1 above, 0 means no base register)
	//	v3: index register size 0/8/16/32/64 (0 means no index register)
	//	v4: scale 1/2/4/8 (*must* be one of these)
	//	v5: size of the displacement immediate 8/32 only (ignored if v6 is 0)
	//	v6: value of displacement (0 means no displacement)
	.memreg := 2;
	// absolute memory address (64 bit only)
	//	v1: the address
	.addr := 3;
	//	v1: a displacement from the rip register
	//	v2: size of the displacement immediate 8/32 only
	.ripreladdr := 4;

	// the following tags are customs. you should use them as intermediate values
	// these must all be lowered to an actual x64 eventually.
	.custom0 := 8;
	.custom1 := 9;
	.custom2 := 10;
	.custom3 := 11;
};

x64v : struct
{
	tag : x64v_tag;
	r1 : x64_reg;
	r2 : x64_reg;
	v1 : u64;
	v2 : u64;
	v3 : u64;
	v4 : u64;
	v5 : u64;
	v6 : u64;
	v7 : u64;
};

// api to create x64 values

x64v_reg : func(reg : x64_reg, sz : u64 -> x64v)
{
	return x64v{.tag := x64v_tag.reg; .r1 := reg; .v1 := sz;};
};

x64v_memreg : func(memsize : u64, base_reg : x64_reg, base_regsize : u64, index_reg : x64_reg, index_regsize : u64, scale : u64, displacement : u64, displacement_size : u64 -> x64v)
{
	return x64v
	{
		.tag := x64v_tag.memreg;
		.r1 := base_reg;
		.r2 := index_reg;
		.v1 := memsize;
		.v2 := base_regsize;
		.v3 := index_regsize;
		.v4 := scale;
		.v5 := displacement_size;
		.v6 := displacement;
	};
};

x64v_addr : func(addr : u64 -> x64v)
{
	return x64v{.tag := x64v_tag.addr; .v1 := addr;};
};

x64v_ripreladdr : func(ripreladdr : u64, ripreladdr_size : u64 -> x64v)
{
	return x64v{.tag := x64v_tag.ripreladdr; .v1 := ripreladdr; .v2 := ripreladdr_size;};
};

x64v_is_custom : func(v : x64v -> bool)
{
	return ((v.tag@s64) >= (x64v_tag.custom0@s64));
};
