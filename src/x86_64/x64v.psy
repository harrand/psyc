x64_reg : enum
{
	.rax := 0;
	.rcx := 1;
	.rdx := 2;
	.rbx := 3;
	.rsp := 4;
	.rbp := 5;
	.rsi := 6;
	.rdi := 7;
	.r8 := 8;
	.r9 := 9;
	.r10 := 10;
	.r11 := 11;
	.r12 := 12;
	.r13 := 13;
	.r14 := 14;
	.r15 := 15;
};

x64v_tag : enum
{
	// immediate value
	//	v1: size 8/16/32/64
	//	v2: the actual immediate value
	.imm := 1;
	// register
	//	r1: which register to use (cannot be null)
	//	v1: size 8/16/32/64/128/256/512 (e.g x64v_tag.rax, v1 = 32 means eax, v1 = 128 means xmm0)
	.reg := 2;
	// memory operand of the form 'v1 PTR [r1v2 + r2v3 * immv4 + v5immv6]'
	//	r1: base register (ignored if v2 is 0)
	//	r2: index register (ignored if v3 is 0)
	//	v1: memory operand size 8/16/32/64/128/256/512 (e.g 8 is BYTE PTR, 64 is QWORD PTR, 256 is YWORD PTR)
	//	v2: base register size 0/8/16/32/64 (see .reg|v1 above, 0 means no base register)
	//	v3: index register size 0/8/16/32/64 (0 means no index register)
	//	v4: scale 1/2/4/8 (*must* be one of these)
	//	v5: size of the displacement immediate 8/32 only (ignored if v6 is 0)
	//	v6: value of displacement (0 means no displacement)
	.memreg := 3;
	// absolute memory address (64 bit only)
	//	v1: the address
	.addr := 4;
	//	v1: a displacement from the rip register
	//	v2: size of the displacement immediate 8/32 only
	.ripreladdr := 5;

	// the following tags are customs. you should use them as intermediate values
	// these must all be lowered to an actual x64 eventually.
	.custom0 := 8;
	.custom1 := 9;
	.custom2 := 10;
	.custom3 := 11;
};

x64v : struct
{
	tag : x64v_tag;
	r1 : x64_reg;
	r2 : x64_reg;
	v1 : u64;
	v2 : u64;
	v3 : u64;
	v4 : u64;
	v5 : u64;
	v6 : u64;
	v7 : u64;
};

// api to create x64 values

x64v_imm : func(imm : u64, immsz : u64 -> x64v)
{
	return x64v
	{
		.tag := x64v_tag.imm;
		.v1 := immsz;
		.v2 := imm;
	};
};

x64v_reg : func(reg : x64_reg, sz : u64 -> x64v)
{
	return x64v{.tag := x64v_tag.reg; .r1 := reg; .v1 := sz;};
};

x64v_memreg : func(memsize : u64, base_reg : x64_reg, base_regsize : u64, index_reg : x64_reg, index_regsize : u64, scale : u64, displacement : u64, displacement_size : u64 -> x64v)
{
	return x64v
	{
		.tag := x64v_tag.memreg;
		.r1 := base_reg;
		.r2 := index_reg;
		.v1 := memsize;
		.v2 := base_regsize;
		.v3 := index_regsize;
		.v4 := scale;
		.v5 := displacement_size;
		.v6 := displacement;
	};
};

x64v_addr : func(addr : u64 -> x64v)
{
	return x64v{.tag := x64v_tag.addr; .v1 := addr;};
};

x64v_ripreladdr : func(ripreladdr : u64, ripreladdr_size : u64 -> x64v)
{
	return x64v{.tag := x64v_tag.ripreladdr; .v1 := ripreladdr; .v2 := ripreladdr_size;};
};

x64v_is_custom : func(v : x64v -> bool)
{
	return ((v.tag@s64) >= (x64v_tag.custom0@s64));
};

x64v_size : func(v : x64v -> u64)
{
	if(v.tag == x64v_tag.imm)
	{
		return v.v1;
	}
	if(v.tag == x64v_tag.reg)
	{
		return v.v1;
	}
	if(v.tag == x64v_tag.memreg)
	{
		return v.v1;
	}
	if(v.tag == x64v_tag.addr)
	{
		return 64;
	}
	if(v.tag == x64v_tag.ripreladdr)
	{
		return v.v2;
	}
	return zero;
};

x64v_is_reg : func(v : x64v -> bool)
{
	return v.tag == x64v_tag.reg;
};

x64v_is_imm : func(v : x64v -> bool)
{
	return v.tag == x64v_tag.imm;
};

x64v_is_riprel : func(v : x64v -> bool)
{
	return v.tag == x64v_tag.ripreladdr;
};

x64v_is_mem : func(v : x64v -> bool)
{
	return v.tag == x64v_tag.memreg;
};

x64_require_same_size : func(v1 : x64v, v2 : x64v -> v0)
{
	s1 ::= x64v_size(v1);
	s2 ::= x64v_size(v2);
	if(s1 != s2)
	{
		psyc_panic_begin(zero);
		putzstr("two x64 values must be the same size");
		psyc_diag_end();
		psyc_exit_failure();
	}
};

x64v_contains_register_of_any_size : func(v : x64v, reg : x64_reg -> bool)
{
	return false;
};

x64v_contains_register : func(v : x64v, reg : x64_reg, sz : u64 -> bool)
{
	return false;
};

x64v_contains_extended_register : func(v : x64v -> bool)
{
	return
		x64v_contains_register_of_any_size(v, x64_reg.r8 )
     || x64v_contains_register_of_any_size(v, x64_reg.r9 )
     || x64v_contains_register_of_any_size(v, x64_reg.r10)
     || x64v_contains_register_of_any_size(v, x64_reg.r11)
     || x64v_contains_register_of_any_size(v, x64_reg.r12)
     || x64v_contains_register_of_any_size(v, x64_reg.r13)
     || x64v_contains_register_of_any_size(v, x64_reg.r14)
     || x64v_contains_register_of_any_size(v, x64_reg.r15);
};

x64v_contains_spl_dil_sil_bpl : func(v : x64v -> bool)
{
	return x64v_contains_register(v, x64_reg.rsp, 8)
        || x64v_contains_register(v, x64_reg.rbp, 8)
        || x64v_contains_register(v, x64_reg.rsi, 8)
        || x64v_contains_register(v, x64_reg.rdi, 8);

};
