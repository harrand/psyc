x64i_tag : enum
{
	.nop := 0;
	.mov := 1;
	.push := 2;
	.pop := 3;
	.cbw := 4;
	.cwde := 5;
	.cdqe := 6;
	.inc := 7;
	.dec := 8;
	.neg := 9;
	.not := 10;

	.lea := 11;
	.add := 12;
	.sub := 13;
	.mul := 14;
	.imul := 15;
	.div := 16;
	.idiv := 17;
	.xor := 18;
	.or := 19;
	.and := 20;

	.shl := 21;
	.sar := 22;
	.shr := 23;
	
	.call := 24;
	.jmp := 25; // jump unconditional
	.jz := 26; // jump if zero/equal
	.jnz := 27; // jump if not zero/equal
	.jl := 28; // jump if signed less (less)
	.jle := 29; // jump if signed less or equal
	.jg := 30; // jump if signed greater (greater)
	.jge := 31; // jump if signed greater or equal
	.jb := 32; // jump if unsigned less (below)
	.jbe := 33; // jump if unsigned less or equal
	.ja := 34; // jump if unsigned greater (above)
	.jae := 35; // jump if unsigned greater or equal
	.js := 36; // jump if sign bit set (i.e negativity)
	.jo := 37; // jump if overflow bit set (wrap-around is based so we ignore this)
	.test := 38;
	.cmp := 39;
	.ret := 40;
	.sete := 41;
	.movaps := 42;
	.movapd := 43;
	.movdqa := 43;
	.movups := 42;
	.movupd := 43;
	.movdqu := 43;
};

x64i : struct
{
	tag : x64i_tag;
	operands : x64v mut[4];
};

x64i_operand_count : func(inst : x64i -> u64)
{
	i : u64 mut;
	for(i = 0; i < countof typeof(inst.operands); i = i + 1)
	{
		if([inst.operands # i].tag == zero)
		{
			return i;
		}
	}
	return i;
};
