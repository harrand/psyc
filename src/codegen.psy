cgar : arena mut& mut;
mod : u64 mut;
ir : u64 mut;

cg_finish ::= func() -> v0
{
	err : u8& mut;
	LLVMVerifyModule(mod, 0, ref err);
	puts("verify says: ");
	puts(err);
	putchar(10);
};

cg_primty ::= func(p : primty) -> u64
{
	arr : u64 mut#13;
	deref(arr at ((primty.s64)@s64)) = LLVMInt64Type();
	deref(arr at ((primty.s32)@s64)) = LLVMInt32Type();
	deref(arr at ((primty.s16)@s64)) = LLVMInt16Type();
	deref(arr at ((primty.s8)@s64)) = LLVMInt8Type();

	deref(arr at ((primty.u64)@s64)) = LLVMInt64Type();
	deref(arr at ((primty.u32)@s64)) = LLVMInt32Type();
	deref(arr at ((primty.u16)@s64)) = LLVMInt16Type();
	deref(arr at ((primty.u8)@s64)) = LLVMInt8Type();

	deref(arr at ((primty.bool)@s64)) = LLVMInt1Type();
	deref(arr at ((primty.f64)@s64)) = LLVMDoubleType();
	deref(arr at ((primty.f32)@s64)) = LLVMFloatType();

	deref(arr at ((primty.v0)@s64)) = LLVMVoidType();
	return deref(arr at (p@s64));
};

// convert psyc 'ty' to LLVMTypeRef
cg_type ::= func(t : ty) -> u64
{
	if(ty_isbad(t))
	{
		psyc_panic(zero, "attempted to codegen cg_type(badtype). semal should've caught this. compiler bug.");
	}
	if((t.tag) == (tytag.prim))
	{
		return cg_primty(t.prim);
	}
	if((t.tag) == (tytag.enm))
	{
		return cg_primty(primty.s64);
	}
	if((t.tag) == (tytag.ptr))
	{
		ptr ::= t.ptr;
		u ::= deref((ptr.underlying)@ty&);
		return LLVMPointerType(cg_type(u), 0);
	}
	if((t.tag) == (tytag.strct))
	{
		psyc_panic(zero, "cg_type(structty) is NYI");
	}
	psyc_panic(zero, "control flow reached end of cg_type - compiler bug.");
	return 0;
};

cg_struct ::= func(def : structdef mut&, s : scope mut&, prog : program mut&) -> v0
{
	node ::= def->node;
	type ::= def->type;
	if(ty_isbad(type))
	{
		psyc_panic(node->loc, "cg_struct structdef's type was badtype. semal should've sorted this - compiler bug.");
	}
	strct ::= type.strct;
	// make an array for all the members.
	memarr : u64 mut& := arena_push(cgar, __sizeof(u64) * (strct.member_count));
	memtys ::= (strct.member_types)@ty&;
	i : u64 mut;
	for(i = 0, i < (strct.member_count), i = i + 1)
	{
		deref(memarr at i) = cg_type(deref(memtys at i));
	}
	(def->codegen) = LLVMStructType(memarr, strct.member_count, false@s32);
};

cg_func ::= func(fn : function mut&, s : scope mut&, prog : program mut&) -> v0
{
	(fn->codegen) = 0;
};

codegen ::= func(prog : program mut&) -> v0
{
	psyc_timed(psyc_stage.codegen);
	mod = LLVMModuleCreateWithName("Psy Program");
	ir = LLVMCreateBuilder();

	glob ::= ref(prog->global);
	structs ::= ref(glob->structs);
	funcs ::= ref(glob->funcs);

	i : u64 mut;
	for(i = 0, i < (structs->size), i = i + 1)
	{
		cg_struct((structs->data) at i, glob, prog);
	}

	for(i = 0, i < (funcs->size), i = i + 1)
	{
		cg_func((funcs->data) at i, glob, prog);
	}
	
	cg_finish();
};

codegen_setup ::= func(a : arena mut&) -> v0
{
	cgar = a;
};

== build ==
{
	add_source_file("llvm.psy");
	add_source_file("program.psy");
}
