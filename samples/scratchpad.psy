foo_nested :: struct
{
	val : i64;	
}

[[module = std]]
foo :: struct
{
	myint ::= 0;
	myscalarint : i64 := 0;
	myvectorint : i64[4];
	my_method :: (myparam : u32) -> u0
	{
		this.myvectorint[0] = 5;
		myval : i64 := 0;	
	}
	nested : foo_nested;
}

[[module = std, xyz = 5]]
get_foo :: () -> foo&
{
	f : foo;	
	return ref f;
}

morb :: () -> u0 := extern;

my_global_var : i64 := 0;

dub :: (val : i64 weak) -> i64
{
	return val * 2;
}

myfn2 :: () -> u32 := extern;
myfn :: (mypar1 : i64, mypar2 : f64 := 5@f64, mypar3 ::= 69) -> i64
{
	dub(5);
	dub(420.69);
	dub("cock :)");

	my_os ::= host_os;
	fnptr : &(i64, i32)->foo&;
	fnptr2 : &(i64)->foo&;
	fnptr3 ::= get_foo;
	fnptr3();
	x : i64 static := 5;
	y ::= x;
	myptr ::= typeinfo i64;
	myptr.name;
	myptr2 : i64& := ref mypar1;
	//foo::bar;
	defer return 123;
	if(true)
	{
		if(0@i64 weak){}
	}
	else if(x == 5)
	{
		// x = 5
	}
	else
	{
		if(y == (x * 2))
		{
			morb();
		}
	}

	if(x == y)
	{
		//x = 5;
	}
	else{}

	myfoo ::= mynamespace::foo
	{
		.nested := mynamespace::foo_nested
		{
			.val := 5
		}
		//.nested4 := detail::foo_nested{}
	};

	//mynamespace::myfoo.my_method();

	foo{}.my_method(y@u32);

	mystr : u8 const& := "hello world";
	mystaticstr ::= "goodbye everyone";

	myfoo.nested.val = (1 != 2)@i64;
	myvar1 : i32;
	myfn2();
	myvar2 : i64 := (5@f64 + (5@f64))@i64;
	myvar3 ::= ref 69;
	(123@i64&) - (69@i64&);
	myvar2 = deref myvar3 + 5;
	deref (get_foo()@i64&);

	static if(5 == x)
	{

	}

	myvar4 ::= myvar2@u64@u32;
	myvar5 ::= (myfn2() + (myvar4 * (200@u32))) / (500@u32);
	myvar6 ::= 420.69;

	if(myvar6 == (123@f64))
	{

	}

	return myfn(deref myvar3, myfn2()@f64, dub(myvar3@i64)@i64);
}

windows : bool static := true;

static if(host_os == os_windows)
{
	winapi :: namespace
	{
		UINT :: alias := u32 weak;
		HANDLE :: alias := i8&;
		DWORD :: alias := u32 weak;
		WORD :: alias := u16 weak;
		BYTE :: alias := u8 weak;
		BOOL :: alias := i32 weak;
		// Yes, these not being pointers is highly misleading.
		INT_PTR :: alias := i32 weak;
		UINT_PTR :: alias := u32 weak;
		LONG_PTR :: alias := i64 weak;
		ULONG_PTR :: alias := u64 weak;

		WPARAM :: alias := UINT_PTR weak;
		LPARAM :: alias := LONG_PTR weak;
		LRESULT :: alias := LONG_PTR weak;

		HINSTANCE :: alias := HANDLE;
		HICON :: alias := HANDLE;
		HCURSOR :: alias := HANDLE;
		HBRUSH :: alias := HANDLE;
		HMENU :: alias := HANDLE;
		HWND :: alias := HANDLE;
		HDC :: alias := HANDLE;
		// TODO: constexpr?	

		WNDCLASSEXA :: struct
		{
			//cbSize : u32 := __builtin_sizeof(WNDCLASSEX);
			cbSize : u32 := 108@u32;
			style : u32;
			lpfnWndProc : i8&;
			cbClsExtra : i32 := 0@i32;
			cbWndExtra : i32 := 0@i32;
			hInstance : HINSTANCE := null;
			hIcon : HICON := null;
			hCursor : HCURSOR := null;
			hbrBackground : HBRUSH := null;
			lpszMenuName : i8& := null;
			lpszClassName : i8&;
			hIconSm : HICON := null;
		}

		[[call = cdecl]]
		CreateWindowExA ::
		(
			dwExStyle : DWORD,
			lpClassName : i8&,
			lpWindowName : i8&,
			dwStyle : DWORD,
			x : i32,
			y : i32,
			nWidth : i32,
			nHeight : i32,
			hWndParent : HWND := null,
			hMenu : HMENU := null,
			hInstance : HINSTANCE := null,
			lpParam : i8& := null
		) -> HWND := extern;
	}
}

myvar ::= winapi::WNDCLASSEXA
{
	.lpszClassName := "hello world!"
};

== default : build ==
{
	
}