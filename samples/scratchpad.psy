123;
12345;

hio : i64 := 64;

nesteddata :: struct
{
	flak : i64;
}

mydata :: struct
{
	member : i64 := 5;
	member2 : i64 := 69;
	nested : nesteddata;
}
//xyz : mydata;
//xyz.member;

get_data :: () -> mydata
{
	ret : mydata;
	(ret.nested.flak) = 9;
	return ret;
}
//class :: typedef := mydata;

putchar :: (ch : i8) -> u0 := extern;
dub :: (val : i64) -> i64
{
	vvptr : i64&& const;
	deref vvptr = (55@u64& weak);
	vv : f64 weak := 5;
	vv = 50;

	ddd : mydata := get_data();
	ddd.member = 5;
	ptr : i64& := __builtin_malloc(123@u64);
	longptr : i64& := (ptr);
	defer __builtin_free(ptr);

	is_cringe : bool := (true == false);
	val = deref ref val;
	val = (val + (get_data().member));
	v : i64&;
	val = (val * val * val * (deref v));
	deref v = 862;
	-deref v;
	your_mum : i64 := 0;
	// return val * 2

	myint : i64 := 0;
	for myint = 0, myint == 5, myint = myint + 1
	{
		putchar(myint@i8);
	}
}

complicated :: (par1 : i64, par : i64, par3 : i64) -> i64
{
	putchar(-par@i8);	
}

poggers : i64 := 5;
morb :: (par0 : i64) -> f64
{
	poggers1 : i64;
	poggers2 : i64;
	poggers3 : i64;
	//morb2 :: (par0 : i64) -> u0 := extern;
	complicated(poggers, dub(5), get_data().member2);
	complicated(--complicated(1, 2, 3), dub(5), 690);

	if poggers1 == 59
	{
		e : i64 := 5;
	}
	else if poggers2 == 12
	{
		// ur cringe m8.
		d : i64 := 5;
		if par0 == 5
		{

		}
		else
		{
			if poggers3 == 0
			{

			}
		}
	}

	retval : f64;
	return retval;
	//return morb(5 * complicated(dub(5)));
}
morb(65);

== default : build ==
{
	set_optimisation(2);
}